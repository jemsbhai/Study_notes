#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\date{}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=blue
}
\end_preamble
\options liststotoc
\use_default_options true
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3.5cm
\headheight 1cm
\headsep 1cm
\footskip 2cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\bullet 0 0 27 -1
\bullet 1 0 15 -1
\bullet 2 0 24 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Advanced R programming
\end_layout

\begin_layout Author
(by Hadley Wickham)
\end_layout

\begin_layout Standard
\align center
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://adv-r.had.co.nz
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Programming
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
Become a R programmer from a R user.
\end_layout

\begin_layout Itemize
There are two meta-techniques that are tremendously helpful for improving
 your skills as an R programmer: 
\emph on
reading the source
\emph default
, and 
\emph on
adopting a scientific mindset
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Reading source code
\series default
 is a tremendously useful technique because it exposes you to new ways of
 doing things.
 Over time you'll develop a sense of taste as an R programmer, and even
 if you find something your taste violently objects to, it's still helpful:
 emulate the things you like and avoid the things you don't like.
\end_layout

\begin_layout Itemize
It's a great idea to start by reading the source code for the functions
 and packages that you use most frequently.
 
\end_layout

\begin_layout Itemize
If you don't understand how something works, develop a hypothesis, design
 some experiments, run them and record the results.
 This exercise is extremely useful if you can't figure it out and need to
 get help from others: you can easily show what you tried, and when you
 learn the right answer, you'll be mentally prepared to update your world
 view.
\end_layout

\end_deeper
\begin_layout Itemize
Recommended reading
\end_layout

\begin_deeper
\begin_layout Itemize
R has aspects of both functional and object-oriented (OO) programming languages,
 and learning how these aspects are expressed in R will help you translate
 your existing knowledge from other programming languages, and to help you
 identify areas where you can improve.
\end_layout

\begin_layout Itemize

\emph on
The Structure and Interpretation of Computer Programs
\emph default
 (SICP)
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

 http://mitpress.mit.edu/sicp/full-text/book/book.html
\end_layout

\end_inset

 is particularly helpful.
\end_layout

\begin_layout Itemize

\emph on
Concepts, Techniques and Models of Computer Programming
\emph default
 by Peter van Roy and Sef Haridi.
 It helps to understand that R's copy-on-modify semantics make it substantially
 easier to reason about code, and while the current implementation in R
 is not very efficient, that it is a solvable problem.
\end_layout

\begin_layout Itemize

\emph on
The Pragmatic Programmer
\emph default
, by Andrew Hunt and David Thomas.
 This book is program language agnostic, and provides great advice for how
 to be a better programmer.
\begin_inset Newpage newpage
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Foundations
\end_layout

\begin_layout Subsection
Data structures
\end_layout

\begin_layout Itemize
R's base data structures are summarized in the table below, organized by
 their dimensionality and whether they're homogeneous (all contents must
 be of the same type) or heterogeneous (the contents can be of different
 types):
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Homogeneous
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Heterogeneous
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1d
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic vector
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2d
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrix
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data frame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nd
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
\align left
Note that R has no scalar, or 0-dimensional, types.
 All scalars (single numbers or strings) are length-one vectors.
\end_layout

\begin_layout Itemize
When trying to understand the structure of an arbitrary object in R your
 most important tool is str(), short for structure: it gives a compact human
 readable description of any R data structure.
\end_layout

\end_deeper
\begin_layout Subsubsection
Vectors
\end_layout

\begin_layout Itemize
The basic data structure in R is the vector, which comes in two basic flavours:
 
\series bold
atomic vectors
\series default
 and 
\series bold
lists
\series default
.
\end_layout

\begin_deeper
\begin_layout Enumerate
Atomic vector: must have the same type in contents
\end_layout

\begin_layout Enumerate
List: the contents can have different types
\end_layout

\end_deeper
\begin_layout Itemize
Three properties of a vector:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
typeof()
\family default
: what it is
\end_layout

\begin_layout Enumerate

\family sans
length()
\family default
: how long it is
\end_layout

\begin_layout Enumerate

\family sans
attributes()
\family default
: additional arbitrary metadata, like 
\family sans
names()
\end_layout

\end_deeper
\begin_layout Itemize
Atomic vectors and lists are the building blocks for higher dimensional
 data structures.
 Atomic vectors extend to matrices and arrays, and lists are used to create
 data frames
\end_layout

\begin_layout Itemize
Each type of vector comes with an 
\family sans
as.*
\family default
 coercion function and an 
\family sans
is.*
\family default
 testing function.
 But beware.
 For historical reasons, 
\family sans
is.vector()
\family default
 returns 
\family sans
TRUE
\family default
 only if the object is a vector with no attributes apart from names.
 Use 
\family sans
is.atomic(x)
\family default
 || 
\family sans
is.list(x)
\family default
 to test if an object is actually a vector.
\end_layout

\begin_layout Enumerate

\series bold
Atomic vectors
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Missing values
\series default
 are specified with NA, which is a logical vector of length 1.
 NA will always be coerced to the correct type with 
\family sans
c()
\family default
, or you can create NA's of specific types with 
\family sans
NA_real_ (double), NA_integer_ and NA_character_
\family default
.
\end_layout

\begin_layout Itemize

\series bold
Types and tests
\series default
: 
\family sans
typeof(), is.character(), is.double(), is.integer(), is.logical()
\family default
, or, more generally, 
\family sans
is.atomic()
\family default
.
\end_layout

\begin_layout Itemize

\series bold
Coercion
\series default
: When attempt to combine different types in atomic vector they will be
 coerced to the lowest common type: (ordered from low to high) character,
 double, integer and logical.
\end_layout

\begin_deeper
\begin_layout Itemize
You can manually force one type of vector to another using a coercion function:
 
\family sans
as.character(), as.double(), as.integer(), as.logical()
\family default
.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Lists
\end_layout

\begin_deeper
\begin_layout Itemize
Lists are different from atomic vectors in that they can contain any other
 type of vector, including lists.
 You construct them using 
\family sans
list()
\family default
 instead of 
\family sans
c()
\family default
.
\end_layout

\begin_layout Itemize
Lists are sometimes called 
\series bold
recursive vectors
\series default
, because a list can contain other lists.
 This makes them fundamentally different from atomic vectors.
\end_layout

\begin_layout Itemize

\family sans
c()
\family default
 will combine several lists into one.
 If given a combination of atomic vectors and lists, c() will coerce the
 vectors to list before combining them.
 E.g.
 
\begin_inset Quotes eld
\end_inset


\family sans
y <- c(list(1, 2), c(3, 4))
\family default

\begin_inset Quotes erd
\end_inset

, y then is a list of 4.
\end_layout

\begin_layout Itemize
Lists are used to build up many of the more complicated data structures
 in R.
 For example, both 
\emph on
data frames
\emph default
, and linear models objects (as produced by lm()) are lists.
\end_layout

\begin_layout Itemize
Using the same implicit coercion rules as for c(), you can turn a list back
 into an atomic vector using unlist().
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Factors
\end_layout

\begin_deeper
\begin_layout Itemize
A factor is a vector that can contain only predefined values.
 It is R's structure for dealing with qualitative data.
\end_layout

\begin_layout Itemize
A factor is not an atomic vector, but it's built on top of an integer vector
 using an S3 class.
\end_layout

\begin_layout Itemize
Factors have 
\emph on
two key attributes
\emph default
: 
\series bold
their class()
\series default
, "factor", which controls their behavior; and 
\series bold
their levels()
\series default
, the set of allowed values.
\end_layout

\begin_layout Itemize
While factors look (and often behave) like character vectors, they are actually
 integers under the hood and you need to be careful when treating them like
 strings.
\end_layout

\begin_layout Itemize
Factors are useful when you know the possible values a variable may take,
 even if you don't see all values in a given dataset.
 Using a factor instead of a character vector makes it obvious when some
 groups contain no observations
\end_layout

\begin_layout Itemize
Sometimes when reading the data into R, the numeric variable will be coerced
 into factor if there are some missing values encoded in special way like
 .
 or -.
 We can avoid this by using na.strings argument in 
\family sans
read.csv()
\family default
: e.g.
 
\family sans
z <- read.csv(text="value
\backslash
n12
\backslash
n1
\backslash
n.
\backslash
n9", na.strings=".")
\family default
.
\end_layout

\begin_layout Itemize
To coerce the vector from a factor to numeric we need first coerce it into
 character and then from character to numeric.
 E.g.
 
\family sans
as.numeric(as.character(z$value))
\end_layout

\begin_layout Itemize
Unfortunately, most data loading functions in R automatically convert character
 vectors to factors.
 This is suboptimal, because there's no way for those functions to know
 the set of all possible levels and their optimal order.
 A global option (
\family sans
options(stringsAsFactors = FALSE)
\family default
 ) is available to control this behaviour, but it's not recommended - it
 makes it harder to share your code, and it may have unexpected consequences
 when combined with other code (either from packages, or code that you're
 
\family sans
source()
\family default
ing).
 
\begin_inset Foot
status open

\begin_layout Plain Layout
Global options make code harder to understand, because they increase the
 number of lines you need to read to understand what a function is doing.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
What makes 
\family sans
is.vector()
\family default
 and 
\family sans
is.numeric()
\family default
 fundamentally different to 
\family sans
is.list()
\family default
 and 
\family sans
is.character()
\family default
?
\end_layout

\begin_layout Itemize
Why is the default (and shortest) NA a logical vector? What's special about
 logical vectors?
\end_layout

\begin_layout Subsubsection
Attributes
\end_layout

\begin_layout Itemize
All objects can have arbitrary additional attributes.
 These can be thought of as a named list (with unique names).
 Attributes can be accessed individually with 
\family sans
attr()
\family default
 or all at once (as a list) with 
\family sans
attributes()
\family default
.
 E.g.
 
\family sans
attr(y, "my_attribute") <- "This is a vector"
\family default
; 
\family sans
str(attributes(y))
\family default
.
\end_layout

\begin_layout Itemize
The 
\family sans
structure()
\family default
 function returns a new object with modified attributes
\end_layout

\begin_layout Itemize
By default, most attributes are lost when modifying a vector (e.g.
 
\family sans
sum(y), y[1]
\family default
); the exceptions are for the most common attributes: 
\family sans
names()
\family default
 (character vector of element names), 
\family sans
class(), dim()
\family default
 (used to turn vectors into high-dimensional structures).
 
\end_layout

\begin_layout Itemize

\series bold
Names
\end_layout

\begin_deeper
\begin_layout Itemize
You can name a vector in three ways:
\end_layout

\begin_deeper
\begin_layout Itemize
During creation: 
\family sans
x <- c(a = 1, b = 2, c = 3) 
\end_layout

\begin_layout Itemize
By modifying an existing vector: 
\family sans
x <- 1:3; names(x) <- c("a", "b", "c") 
\end_layout

\begin_layout Itemize
By creating a modified vector: 
\family sans
x <- setNames(1:3, c("a", "b", "c"))
\end_layout

\end_deeper
\begin_layout Itemize
Names should be unique, because character subsetting, the biggest reason
 to use names, will only return the first match.
\end_layout

\begin_layout Itemize
Not all elements of a vector need to have a name.
 If any names are missing, 
\family sans
names()
\family default
 will return an empty string for those elements.
 If all names are missing, 
\family sans
names()
\family default
 will return 
\family sans
NULL
\family default
.
\end_layout

\begin_layout Itemize
You can create a vector without names using 
\family sans
unname(x)
\family default
, or remove names in place with 
\family sans
names(x) <- NULL
\family default
.
\end_layout

\end_deeper
\begin_layout Subsubsection
Matrices and arrays
\end_layout

\begin_layout Itemize
Adding a 
\family sans
dim()
\family default
 attribute allows an atomic vector to also be treated like a multi-dimensional
 array.
 A special case of a general array is the matrix, which has two dimensions.
\end_layout

\begin_layout Itemize
Matrices and arrays are created with 
\family sans
matrix()
\family default
 and 
\family sans
array()
\family default
, or by using the replacement form of 
\family sans
dim()
\family default
.
 E.g.
 
\family sans
array(1:12, c(2, 3, 2))
\end_layout

\begin_layout Itemize
The basic properties 
\family sans
length()
\family default
 and 
\family sans
names()
\family default
 have high-dimensional generalizations that work with matrices and arrays:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
length()
\family default
 generalizes to 
\family sans
nrow()
\family default
 and 
\family sans
ncol()
\family default
 for matrices, and 
\family sans
dim()
\family default
 for arrays.
\end_layout

\begin_layout Itemize

\family sans
names()
\family default
 generalizes to 
\family sans
rownames()
\family default
 and 
\family sans
colnames()
\family default
 for matrices, and 
\family sans
dimnames()
\family default
, a list, for arrays.
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
c()
\family default
 generalizes to 
\family sans
cbind()
\family default
 and 
\family sans
rbind() 
\family default
for matrices, and to 
\family sans
abind()
\family default
 (provided by the 
\family sans
abind
\family default
 package) for arrays.
 
\end_layout

\begin_layout Itemize
While atomic vectors are most commonly turned into matrices, the dimension
 attribute can also be set on lists to make list-matrices or list-arrays.
 
\family sans
l <- list(1:3, "a", TRUE, 1.0); dim(l) <- c(2, 2).
\end_layout

\begin_layout Subsubsection
Data frames
\end_layout

\begin_layout Itemize

\series bold
A data frame is a list of equal-length vectors.

\series default
 This makes it a 2-dimensional structure, so it shares properties of both
 the matrix and the list.
 This means that a data frame has 
\family sans
names(), colnames()
\family default
 and 
\family sans
rownames()
\family default
, although 
\family sans
names()
\family default
 and 
\family sans
colnames()
\family default
 are the same thing.
 The 
\family sans
length()
\family default
 of a data frame is the length of the underlying list and so is the same
 as 
\family sans
ncol(), nrow()
\family default
 gives the number of rows.
\end_layout

\begin_layout Itemize
As doing subsetting, you can subset a data frame like a 1d structure (where
 it behaves like a list), or a 2d structure (where it behaves like a matrix).
\end_layout

\begin_layout Itemize
By default 
\family sans
data.frame()
\family default
 converts strings into factors.
 Use 
\family sans
stringAsFactors = FALSE
\family default
 to suppress this behaviour.
\end_layout

\begin_layout Itemize

\family sans
data.frame
\family default
 is an S3 class, so its type reflects the underlying vector used to build
 it: list.
 (
\family sans
typeof()
\family default
 gives list).
 We should look at its 
\family sans
class()
\family default
 or test explicitly with 
\family sans
is.data.frame()
\family default
.
\end_layout

\begin_layout Itemize
We can combine data frames using 
\family sans
cbind()
\family default
 and 
\family sans
rbind()
\family default
.
 When combining column-wise, only the number of rows matters, the rownames
 are ignored; while when combining row-wise, the column names must match.
 If you want to combine data frames that may not have all the same variables,
 use 
\family sans
plyr::rbind.fill().
 
\end_layout

\begin_layout Itemize
Since a data frame is a list of vectors, it is possible for a data frame
 to have a column that is a list.
\end_layout

\begin_layout Itemize
Ex: 
\family sans
dfl <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
\family default
, use 
\family sans
I()
\family default
 to treat the whole list as an unit, otherwise, 
\family sans
data.frame()
\family default
 will try to used each element in the list as a column.
\end_layout

\begin_layout Subsection
Subsetting
\end_layout

\begin_layout Subsubsection
Data types
\end_layout

\begin_layout Itemize

\series bold
Atomic vectors
\series default
: x
\end_layout

\begin_deeper
\begin_layout Itemize
Five ways to subset x:
\end_layout

\begin_layout Enumerate

\series bold
Positive integers
\series default
: return elements at the specified positions
\end_layout

\begin_deeper
\begin_layout Standard
Real numbers are silently truncated to integers
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Nagative integers
\series default
: omit elements at the specified positions
\end_layout

\begin_layout Enumerate

\series bold
Logical vector
\series default
: selects elements where the corresponding logical value is TRUE.
\end_layout

\begin_deeper
\begin_layout Itemize
If logical vector is horter than the vector being subsetted, it will be
 recycled to be the same length.
\end_layout

\begin_layout Itemize
A missing value in the index always yields a missing value in the output
\end_layout

\end_deeper
\begin_layout Enumerate
With 
\series bold
nothing
\series default
: returns the origial vector unchanged.
 
\end_layout

\begin_deeper
\begin_layout Standard
Not useful in 1d but very useful in 2d
\end_layout

\end_deeper
\begin_layout Enumerate
With 
\series bold
zero
\series default
: returns a zero-length vector.
\end_layout

\begin_layout Itemize
If a vector is named, we can also subset with 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
character vector
\series default
:
\series bold
 
\series default
retuns elements with matching names.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Lists
\end_layout

\begin_deeper
\begin_layout Itemize
Subsetting a list works in exactly the same way as subsetting an atomic
 vector.
 Subsetting a list with 
\family sans
[ 
\family default
will always return a list: 
\family sans
[[
\family default
 and 
\family sans
$
\family default
, as described below, let you pull out the components of the list.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Matrices (2d) and arrays (>2d)
\end_layout

\begin_deeper
\begin_layout Itemize
We can subset higher-dimensional structures in three ways: with 
\series bold
mutiple vectors
\series default
, with 
\series bold
single vector
\series default
, or 
\series bold
with a matrix
\series default
.
 
\end_layout

\begin_layout Itemize
By default, 
\family sans
[
\family default
 will simplify the results to the lowest possible dimensionality.
 
\end_layout

\begin_layout Itemize
Because matrices and arrays are implemented as vectors with special attributes,
 we can also subset them with a single vector.
 The length of a matrix/array=nrow*ncol of it.
 In that case, they will behave like a vector.
 Arrays in R are stored in column-major order.
\end_layout

\begin_layout Itemize
Using integer matrix ( or a character matrix if named), each row in the
 matrix specifies the location of a value, with each column corresponding
 to a dimension in the array being subsetted.
 
\end_layout

\begin_layout Itemize

\family sans
upper.tri()
\family default
 returns a matrix with all uper triangle elemetns with TRUEs and others
 False for a matrix.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Data frames
\end_layout

\begin_deeper
\begin_layout Itemize
Data frames possess the characteristics of both lists and matrices: if you
 subset with a single vector, they behave like lists; if you subset with
 two vectors, they behave like matrices.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
S3 objects vs.
 S4 objects
\end_layout

\begin_deeper
\begin_layout Enumerate
S3 objects are made up of 
\emph on
atomic vectors, arrays
\emph default
 and 
\emph on
lists
\emph default
, so we can always pull apart an S3 object using the techniques described
 above and the knowledge you gain from 
\family sans
str()
\family default
.
\end_layout

\begin_layout Enumerate
There are also two additional subsetting operators that are needed for S4
 objects: 
\family sans
@
\family default
 (equivalent to 
\family sans
$
\family default
), and 
\family sans
slot()
\family default
 (equivalent to 
\family sans
[[
\family default
).
 
\family sans
@
\family default
 is more restrictive than $ in that it will return an error if the slot
 does not exist.
 
\end_layout

\end_deeper
\begin_layout Subsubsection
Subsetting operators
\end_layout

\begin_layout Itemize
Apart from 
\family sans
[
\family default
, there are two other subsetting operators: 
\family sans
[[
\family default
 and 
\family sans
$
\family default
.
 
\family sans
[[
\family default
 is similar to 
\family sans
[
\family default
, except it can only return a single value, and it allows you to pull pieces
 out of a list.
 
\emph on
When combined with character subsetting, $ is a useful shorthand for 
\family sans
[[
\family default
\emph default
.
 
\end_layout

\begin_deeper
\begin_layout Itemize
E.g.: 
\family sans
b <- list(a = list(b = list(c = list(d = 1)))) b[[c("a", "b", "c", "d")]]
 
\family default
is the same as
\family sans
 b[["a"]][["b"]][["c"]][["d"]]
\end_layout

\begin_layout Itemize
Because data frames are lists of columns, you can use [[ to extract a column
 from data frames.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Simplifying vs.
 preserving subsetting
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Simplifying subsets
\emph default
 return the simplest possible data structure that can represent the output.
\end_layout

\begin_layout Itemize

\emph on
Preserving subsetting
\emph default
 keeps the structure of the output the same as the input.
 It is generally better for programming because the result will always be
 the same type.
\end_layout

\begin_layout Itemize
Switch between subsetting and preserving for different data types
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Simplifying
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Preserving
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vector
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[[1]]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[1]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[[1]]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[1]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Factor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[1:4,drop=T]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[1:4]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[1,] or x[,1]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[1, , drop=F] or x[, 1, drop=F]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data frame
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[,1] or x[[1]]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[, 1, drop=F] or x[1]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Simplifying behaviour varies slightly between different data types:
\end_layout

\begin_deeper
\begin_layout Itemize
atomic vector: removes names
\end_layout

\begin_layout Itemize
list: return the object inside the list, not a single element list
\end_layout

\begin_layout Itemize
factor: drops any unused levels
\end_layout

\begin_layout Itemize
matrix or array: if any of the dimensions has length 1, drops that dimension.
\end_layout

\begin_layout Itemize
data frame: if output is a single column, returns a vector instead of a
 data frame
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
$
\end_layout

\begin_deeper
\begin_layout Itemize
$ is a shorthand operator, where 
\family sans
x$y
\family default
 is equivalent to 
\family sans
x[["y", exact = FALSE]]
\family default
.
\end_layout

\begin_layout Itemize
One common mistake with 
\family sans
$
\family default
 is to try and use it when you have the name of a column stored in a variable:
 
\family sans
var<-
\begin_inset Quotes erd
\end_inset

cyl
\begin_inset Quotes erd
\end_inset

; mtcars$var # wrong; mtcars[[var]] #right
\end_layout

\begin_layout Itemize
There's one important difference between $ and [[ - $ does partial matching:
 
\family sans
x <- list(abc = 1) x$a #> [1] 1 x[["a"]] #> NULL.
 
\family default
This can be avoided by using
\family sans
 options(warnPartialMatchDollar = TRUE), 
\family default
but beware of the danger of using the global option.
\end_layout

\end_deeper
\begin_layout Itemize
Missing/out of bounds indices
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operator
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Index
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Atomic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
List
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
OOB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NA
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
list(NULL)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NA_real_
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NA
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
list(NULL)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NULL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
x[0]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
list(NULL)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
[[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
OOB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Error
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Error
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
[[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NA_real_
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Error
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NULL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
[[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
NULL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Error
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Error
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Subsetting and assignment
\end_layout

\begin_layout Itemize
Indexing with a blank can be useful in conjunction with assignment because
 it will preserve the original object class and structure.
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
mtcars[] <- lapply(mtcars, as.integer)
\family default
 will retrun a dataframe
\end_layout

\begin_layout Itemize

\family sans
mtcars <- lapply(mtcars, as.integer)
\family default
 will return a list
\end_layout

\end_deeper
\begin_layout Itemize
With 
\emph on
lists
\emph default
, you can use subsetting + assignment + NULL to 
\series bold
remove
\series default
 components from a list.
 To 
\series bold
add
\series default
 a literal NULL to a list, use [ and list(NULL):
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
x <- list(a = 1, b = 2) x[["b"]] <- NULL, will remove b and result in a
 list of 1
\end_layout

\begin_layout Itemize

\family sans
y <- list(a = 1) y["b"] <- list(NULL)
\end_layout

\end_deeper
\begin_layout Subsubsection
Applications
\end_layout

\begin_layout Itemize

\series bold
Lookup tables (character subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
Character matching provides a powerful way to make lookup tables.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- c("m", "f", "u", "f", "f", "m", "m") 
\end_layout

\begin_layout Standard

\family sans
lookup <- c(m = "Male", f = "Female", u = NA) 
\end_layout

\begin_layout Standard

\family sans
lookup[x]
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard

\family sans
c(m = "Known", f = "Known", u = "Unknown")[x]
\end_layout

\begin_layout Standard
If you don't want names in the result, use 
\family sans
unname()
\family default
 to remove them.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Matching and merging by hand (integer subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
You may have a more complicated lookup table which has multiple columns
 of information:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
grades <- c(1, 2, 2, 3, 1)
\end_layout

\begin_layout Standard

\family sans
info <- data.frame( grade = 1:3, desc = c("Poor", "Good", "Excellent"), fail
 = c(T, F, F) )
\end_layout

\begin_layout Standard

\family sans
\emph on
# Using match
\end_layout

\begin_layout Standard

\family sans
id <- match(grades, info$grade) info[id, ]
\end_layout

\begin_layout Standard

\family sans
\emph on
#> grade desc fail 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1 1 Poor TRUE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 2 2 Good FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 2.1 2 Good FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 3 3 Excellent FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1.1 1 Poor TRUE 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Using rownames 
\end_layout

\begin_layout Standard

\family sans
rownames(info) <- info$grade 
\end_layout

\begin_layout Standard

\family sans
info[as.character(grades), ] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> grade desc fail 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1 1 Poor TRUE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 2 2 Good FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 2.1 2 Good FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 3 3 Excellent FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1.1 1 Poor TRUE
\end_layout

\end_deeper
\begin_layout Itemize
If you have multiple columns to match on, you'll need to first collapse
 them to a single column (with 
\family sans
interaction()
\family default
, 
\family sans
paste()
\family default
, or 
\family sans
plyr::id()
\family default
).
 You can also use
\family sans
 merge()
\family default
 or 
\family sans
plyr::join()
\family default
, which do the same thing for you.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Random samples/bootstrap (integer subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
You can use integer indices to perform random sampling or bootstrapping
 of a vector or data frame.
 You use 
\family sans
sample()
\family default
 to generate a vector of indices, and then use subsetting to access the
 values.
\end_layout

\begin_layout Itemize
The arguments of 
\family sans
sample()
\family default
 control the number of samples to extract, and whether or not sampling with
 replacement is done.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Ordering (integer subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
order()
\family default
 takes a vector as input and returns an integer vector describing how the
 subsetted vector should be ordered:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- c("b", "c", "a") 
\end_layout

\begin_layout Standard

\family sans
order(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 3 1 2
\emph default
 
\end_layout

\begin_layout Standard

\family sans
x[order(x)] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" "b" "c"
\end_layout

\end_deeper
\begin_layout Itemize
To break ties, you can supply additional variables to 
\family sans
order()
\family default
, and you can change from ascending to descending order using 
\family sans
decreasing = TRUE
\family default
.
 By default, any missing values will be put at the end of the vector: however,
 you can remove them with 
\family sans
na.last = NA
\family default
 or put at the front with 
\family sans
na.last = FALSE
\family default
.
\end_layout

\begin_layout Itemize
More concise, but less flexible, functions are available for sorting vectors,
 
\family sans
sort()
\family default
, and data frames, 
\family sans
plyr::arrange()
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Expanding aggregated counts (integer subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
Sometimes you get a data frame where identical rows have been collapsed
 into one and a count column has been added.
 rep() and integer subsetting make it easy to uncollapse the data by subsetting
 with a repeated row index:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1)) 
\end_layout

\begin_layout Standard

\family sans
rep(1:nrow(df), df$n) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 1 1 2 2 2 2 2 3 
\end_layout

\begin_layout Standard

\family sans
df[rep(1:nrow(df), df$n), ]
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Removing columns from data frame (character subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
There are two ways to remove columns from a data frame.
 
\end_layout

\begin_deeper
\begin_layout Itemize
You can set individual columns to NULL
\end_layout

\begin_layout Itemize
Or you can subset to return only the columns you want
\end_layout

\begin_layout Itemize
If you know the columns you don't want, use set operations to work out which
 colums to keep:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
df[setdiff(names(df), "z")]
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Selecting rows based on a condition (logical subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
Because it allows you to easily combine conditions from multiple columns,
 logical subsetting is probably the mostly commonly used technique for extractin
g rows out of a data frame.
\end_layout

\begin_layout Itemize
Remember to use the vector boolean operators & and |, not the short-circuiting
 scalar operators && and || which are more useful inside if statements.
 Don't forget [De Morgan's laws]:
\end_layout

\begin_deeper
\begin_layout Itemize
!(X & Y) is the same as !X | !Y 
\end_layout

\begin_layout Itemize
!(X | Y) is the same as !X & !Y
\end_layout

\begin_layout Itemize
!(X & !(Y | Z)) simplifies to !X | !!(Y|Z), and then to !X | Y | Z.
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
subset()
\family default
 is a specialised shorthand function for subsetting data frames, and saves
 some typing because you don't need to repeat the name of the data frame.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Boolean algebra vs sets (logical & integer subsetting)
\end_layout

\begin_deeper
\begin_layout Itemize
It's useful to be aware of the natural equivalence between set operations
 (integer subsetting) and boolean algebra (logical subsetting).
\end_layout

\begin_layout Itemize
Using set operations is more effective when:
\end_layout

\begin_deeper
\begin_layout Itemize
You want to find the first (or last) 
\family sans
TRUE
\end_layout

\begin_layout Itemize
You have very few 
\family sans
TRUE
\family default
s and very many 
\family sans
FALSE
\family default
s; a set representation may be faster and require less storage
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
which()
\family default
 allows you to convert a boolean representation to an integer representation.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- sample(10) < 4 
\end_layout

\begin_layout Standard

\family sans
which(x)
\end_layout

\begin_layout Standard

\family sans
#> [1] 3 5 6
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
x & y <-> intersect(x, y)
\end_layout

\begin_layout Itemize

\family sans
x | y <-> union(x, y)
\end_layout

\begin_layout Itemize

\family sans
x & !y <-> setdiff(x, y)
\end_layout

\begin_layout Itemize

\family sans
xor(x, y) <-> setdiff(union(x,y), intersect(x, y))
\end_layout

\begin_layout Itemize
Also beware that 
\family sans
x[-which(y)]
\family default
 is not equivalent to 
\family sans
x[!y]
\family default
: if y is all 
\family sans
FALSE
\family default
, 
\family sans
which(y)
\family default
 will be 
\family sans
integer(0)
\family default
 and 
\family sans
-integer(0)
\family default
 is still 
\family sans
integer(0)
\family default
, so you'll get no values, instead of all values.
 In general, avoid switching from logical to integer subsetting unless you
 want, for example, the first or last 
\family sans
TRUE
\family default
 value.
\end_layout

\end_deeper
\begin_layout Itemize
How would you random permute the columns of a data frame? (This is an important
 technique in random forests).
 Can you simultaneously permute the rows and columns in one step?
\end_layout

\begin_layout Itemize
How would you select a random sample of m rows from a data frame? What if
 the sample had to be contiguous (i.e.
 with an initial row, a final row, and every row in between)?
\end_layout

\begin_layout Subsection
Vocabulary
\end_layout

\begin_layout Subsubsection
The basics
\end_layout

\begin_layout Itemize
The first function to learn: ?
\end_layout

\begin_layout Itemize
Important operators and assignment: 
\family sans
%in%, match, =, <-, <<-, $, [, [[, head, tail, subset, with, assign, get
\end_layout

\begin_layout Itemize
Comparision: 
\family sans
all.euqal, identical, !=, ==, >, >=, <, <=, is.na, complete.cases, is.finite
\end_layout

\begin_layout Itemize
Basic math: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
*, +, -, /, ^, %%, %/%, 
\end_layout

\begin_layout Itemize

\family sans
abs, sign, 
\end_layout

\begin_layout Itemize

\family sans
acos, asin, atan, atan2, 
\end_layout

\begin_layout Itemize

\family sans
sin, cos, tan, 
\end_layout

\begin_layout Itemize

\family sans
ceiling, floor, round, trunc, signif, 
\end_layout

\begin_layout Itemize

\family sans
exp, log, log10, log2, sqrt
\end_layout

\begin_layout Itemize

\family sans
max, min, prod, sum
\end_layout

\begin_layout Itemize

\family sans
cummax, cummin, cumprod, cumsum, diff
\end_layout

\begin_layout Itemize

\family sans
pmax, pmin
\end_layout

\begin_layout Itemize

\family sans
range
\end_layout

\begin_layout Itemize

\family sans
mean, meadian, cor, sd, var
\end_layout

\begin_layout Itemize

\family sans
rle
\end_layout

\end_deeper
\begin_layout Itemize
Functions: 
\family sans
function, missing, on.exit, return, invisible
\end_layout

\begin_layout Itemize
Logical & sets: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
&, |, !, xor
\end_layout

\begin_layout Itemize

\family sans
all, any
\end_layout

\begin_layout Itemize

\family sans
intersect, union, setdiff, setequal
\end_layout

\begin_layout Itemize

\family sans
which
\end_layout

\end_deeper
\begin_layout Itemize
Vector and matrices
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
c, matrix
\end_layout

\end_deeper
\begin_layout Itemize
Automatic coercision rules character > numeric > logical
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
length, dim, ncol, nrow
\end_layout

\begin_layout Itemize

\family sans
cbind, rbind
\end_layout

\begin_layout Itemize

\family sans
names, colnames, rownames
\end_layout

\begin_layout Itemize

\family sans
t
\end_layout

\begin_layout Itemize

\family sans
diag
\end_layout

\begin_layout Itemize

\family sans
sweep
\end_layout

\begin_layout Itemize

\family sans
as.matrix, data.matrix
\end_layout

\end_deeper
\begin_layout Itemize
Making vectors
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
c
\end_layout

\begin_layout Itemize

\family sans
rep, rep_len
\end_layout

\begin_layout Itemize

\family sans
seq, seq_len, seq_along
\end_layout

\begin_layout Itemize

\family sans
rev
\end_layout

\begin_layout Itemize

\family sans
sample
\end_layout

\begin_layout Itemize

\family sans
choose, factorial, combn
\end_layout

\begin_layout Itemize

\family sans
(is/as).(character/numeric/logical/...)
\end_layout

\end_deeper
\begin_layout Itemize
Lists & data.frames
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
list, unlist
\end_layout

\begin_layout Itemize

\family sans
data.frame, as.data.frame
\end_layout

\begin_layout Itemize

\family sans
split
\end_layout

\begin_layout Itemize

\family sans
expand.grid
\end_layout

\end_deeper
\begin_layout Itemize
Control flow
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
if, &&, || (short circuiting)
\end_layout

\begin_layout Itemize

\family sans
for, while
\end_layout

\begin_layout Itemize

\family sans
next, break
\end_layout

\begin_layout Itemize

\family sans
switch
\end_layout

\begin_layout Itemize

\family sans
ifelse
\end_layout

\end_deeper
\begin_layout Subsubsection
Common data structures
\end_layout

\begin_layout Itemize
Date time
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
ISOdate, ISOdatetime, strftime, strptime, date 
\end_layout

\begin_layout Itemize

\family sans
difftime 
\end_layout

\begin_layout Itemize

\family sans
julian, months, quarters, weekdays 
\end_layout

\begin_layout Itemize

\family sans
library(lubridate)
\end_layout

\end_deeper
\begin_layout Itemize
Character manipulation 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
grep, agrep 
\end_layout

\begin_layout Itemize

\family sans
gsub 
\end_layout

\begin_layout Itemize

\family sans
strsplit 
\end_layout

\begin_layout Itemize

\family sans
chartr 
\end_layout

\begin_layout Itemize

\family sans
nchar 
\end_layout

\begin_layout Itemize

\family sans
tolower, toupper 
\end_layout

\begin_layout Itemize

\family sans
substr 
\end_layout

\begin_layout Itemize

\family sans
paste 
\end_layout

\begin_layout Itemize

\family sans
library(stringr)
\end_layout

\end_deeper
\begin_layout Itemize
Factors 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
factor, levels, nlevels 
\end_layout

\begin_layout Itemize

\family sans
reorder, relevel 
\end_layout

\begin_layout Itemize

\family sans
cut, findInterval 
\end_layout

\begin_layout Itemize

\family sans
interaction 
\end_layout

\begin_layout Itemize

\family sans
options(stringsAsFactors = FALSE)
\end_layout

\end_deeper
\begin_layout Itemize
Array manipulation 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
array 
\end_layout

\begin_layout Itemize

\family sans
dim 
\end_layout

\begin_layout Itemize

\family sans
dimnames 
\end_layout

\begin_layout Itemize

\family sans
aperm l
\end_layout

\begin_layout Itemize

\family sans
ibrary(abind)
\end_layout

\end_deeper
\begin_layout Subsubsection
Statistics
\end_layout

\begin_layout Itemize
Ordering and tabulating 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
duplicated, unique 
\end_layout

\begin_layout Itemize

\family sans
merge 
\end_layout

\begin_layout Itemize

\family sans
order, rank, quantile 
\end_layout

\begin_layout Itemize

\family sans
sort table, ftable
\end_layout

\end_deeper
\begin_layout Itemize
Linear models 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
fitted, predict, resid, rstandard 
\end_layout

\begin_layout Itemize

\family sans
lm, glm 
\end_layout

\begin_layout Itemize

\family sans
hat, influence.measures 
\end_layout

\begin_layout Itemize

\family sans
logLik, df, deviance 
\end_layout

\begin_layout Itemize

\family sans
formula, ~, I 
\end_layout

\begin_layout Itemize

\family sans
anova, coef, confint, vcov 
\end_layout

\begin_layout Itemize

\family sans
contrasts
\end_layout

\end_deeper
\begin_layout Itemize
Miscellaneous tests 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
apropos("
\backslash

\backslash
.test$")
\end_layout

\end_deeper
\begin_layout Itemize
Random variables 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
(q, p, d, r) * (beta, binom, cauchy, chisq, exp, f, gamma, geom, hyper,
 lnorm, logis, multinom, nbinom, norm, pois, signrank, t, unif, weibull,
 wilcox, birthday, tukey)
\end_layout

\end_deeper
\begin_layout Itemize
Matrix algebra 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
crossprod, tcrossprod 
\end_layout

\begin_layout Itemize

\family sans
eigen, qr, svd %
\end_layout

\begin_layout Itemize

\family sans
*%, %o%, outer 
\end_layout

\begin_layout Itemize

\family sans
rcond 
\end_layout

\begin_layout Itemize

\family sans
solve
\end_layout

\end_deeper
\begin_layout Subsubsection
Working with R
\end_layout

\begin_layout Itemize
Workspace 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
ls, exists, rm 
\end_layout

\begin_layout Itemize

\family sans
getwd, setwd 
\end_layout

\begin_layout Itemize

\family sans
q 
\end_layout

\begin_layout Itemize

\family sans
source 
\end_layout

\begin_layout Itemize

\family sans
install.packages, library, require
\end_layout

\end_deeper
\begin_layout Itemize
Help 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
help, ? 
\end_layout

\begin_layout Itemize

\family sans
help.search 
\end_layout

\begin_layout Itemize

\family sans
apropos 
\end_layout

\begin_layout Itemize

\family sans
RSiteSearch 
\end_layout

\begin_layout Itemize

\family sans
citation 
\end_layout

\begin_layout Itemize

\family sans
demo 
\end_layout

\begin_layout Itemize

\family sans
example 
\end_layout

\begin_layout Itemize

\family sans
vignette
\end_layout

\end_deeper
\begin_layout Itemize
Debugging 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
traceback 
\end_layout

\begin_layout Itemize

\family sans
browser 
\end_layout

\begin_layout Itemize

\family sans
recover 
\end_layout

\begin_layout Itemize

\family sans
options(error = ) 
\end_layout

\begin_layout Itemize

\family sans
stop, warning, message 
\end_layout

\begin_layout Itemize

\family sans
tryCatch, try 
\end_layout

\end_deeper
\begin_layout Subsubsection
I/O
\end_layout

\begin_layout Itemize
Output 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
print, cat message, warning 
\end_layout

\begin_layout Itemize

\family sans
dput 
\end_layout

\begin_layout Itemize

\family sans
format sink, capture.output
\end_layout

\end_deeper
\begin_layout Itemize
Reading and writing data 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
data 
\end_layout

\begin_layout Itemize

\family sans
count.fields 
\end_layout

\begin_layout Itemize

\family sans
read.csv, write.csv 
\end_layout

\begin_layout Itemize

\family sans
read.delim, write.delim 
\end_layout

\begin_layout Itemize

\family sans
read.fwf readLines, writeLines 
\end_layout

\begin_layout Itemize

\family sans
readRDS, saveRDS 
\end_layout

\begin_layout Itemize

\family sans
load, save 
\end_layout

\begin_layout Itemize

\family sans
library(foreign)
\end_layout

\end_deeper
\begin_layout Itemize
Files and directories 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
dir 
\end_layout

\begin_layout Itemize

\family sans
basename, dirname, tools::file_ext 
\end_layout

\begin_layout Itemize

\family sans
file.path path.expand, normalizePath 
\end_layout

\begin_layout Itemize

\family sans
file.choose 
\end_layout

\begin_layout Itemize

\family sans
file.copy, file.create, file.remove, file.rename, dir.create 
\end_layout

\begin_layout Itemize

\family sans
file.exists, file.info 
\end_layout

\begin_layout Itemize

\family sans
tempdir, tempfile 
\end_layout

\begin_layout Itemize

\family sans
download.file, library(downloader)
\end_layout

\end_deeper
\begin_layout Subsection
Functions
\end_layout

\begin_layout Subsubsection
Components of a function
\end_layout

\begin_layout Itemize
All 
\family sans
R
\family default
 functions have three parts: 
\end_layout

\begin_deeper
\begin_layout Itemize
the 
\family sans
body()
\family default
, the code inside the function.
\end_layout

\begin_layout Itemize
the 
\family sans
formals()
\family default
, the list of arguments which controls how you can cal the function.
\end_layout

\begin_layout Itemize
the 
\family sans
environment()
\family default
, the 
\begin_inset Quotes eld
\end_inset

map
\begin_inset Quotes erd
\end_inset

 of the location of the function's variables.
\end_layout

\end_deeper
\begin_layout Itemize
When you print a function in R, it shows you these three important components.
 If the environment isn't displayed, it means that the function was created
 in the global environment.
\end_layout

\begin_layout Itemize
The assignment forms of 
\family sans
body()
\family default
, 
\family sans
formals()
\family default
, and 
\family sans
environment()
\family default
 can also be used to modify functions.
\end_layout

\begin_layout Itemize
Like all objects in R, functions can also possess any number of additional
 
\family sans
attributes()
\family default
.
 For example, you can can set the class() and add a custom print() method.
\end_layout

\begin_layout Itemize
One attribute used by base R is "srcref", short for 
\emph on
source reference
\emph default
, which points to the source code used to create the function.
 Unlike body(), this contains code comments and other formatting.
\end_layout

\begin_layout Itemize

\series bold
Primitive functions
\end_layout

\begin_deeper
\begin_layout Itemize
There is one exception to the rule that functions have three components.
 Primitive functions, like 
\family sans
sum
\family default
, call C code directly with 
\family sans
.Primitive()
\family default
 and contain no R code.
 Therefore their 
\family sans
formals(), body()
\family default
 and 
\family sans
environment()
\family default
 are all 
\family sans
NULL.
\end_layout

\begin_layout Itemize
Primitive functions are only found in the 
\family sans
base
\family default
 package, and since they operate at a low level, they can be more efficient
 (primitive replacement functions don't have to make copies), and can have
 different rules for argument matching (e.g.
 
\family sans
switch
\family default
 and 
\family sans
call
\family default
).
\end_layout

\begin_layout Itemize
This, however, comes at a cost of behaving differently from all other functions
 in 
\family sans
R
\family default
.
 Hence 
\family sans
R
\family default
 core generally avoids creating them unless there is no other option.
\end_layout

\begin_layout Itemize
Q: Create a list of all primitive functions in R.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lt<-ls("package:base", all = TRUE)
\end_layout

\begin_layout Standard

\family sans
mark<-numeric(length(lt)) 
\end_layout

\begin_layout Standard

\family sans
for (i in 1:length(lt)){ mark[i]<-is.null(environment(get(lt[i]))) }
\end_layout

\begin_layout Standard

\family sans
lt[mark==1]
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Lexical scoping
\end_layout

\begin_layout Itemize
Scoping is the set of rules that govern how R looks up the value of a symbol.
\end_layout

\begin_layout Itemize
Understanding scoping allows you to:
\end_layout

\begin_deeper
\begin_layout Enumerate
build tools by composing functions
\end_layout

\begin_layout Enumerate
overrule the usual evaluation rules and do metaprogramming
\end_layout

\end_deeper
\begin_layout Itemize
R has two types of scoping: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
lexical scoping
\series default
, implemented automatically at the language level
\end_layout

\begin_layout Enumerate

\series bold
dynamic scoping
\series default
, used in selecting functions to save typing during interactive analysis.
 
\end_layout

\end_deeper
\begin_layout Itemize
Lexical scoping looks up symbol values based on how functions were nested
 when they were created, not how they are nested when they are called.
 
\end_layout

\begin_layout Itemize
There are four basic principles behind R's implementation of lexical scoping:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
name masking 
\end_layout

\begin_deeper
\begin_layout Itemize
If a name isn't defined inside a function, R will look one level up.
\end_layout

\begin_layout Itemize
The same rules apply if a function is defined inside another function: look
 inside the current function, then where that function was defined, and
 so on, all the way up to the global environment, and then on to other loaded
 packages.
\end_layout

\begin_layout Itemize
The same rules apply to closures, functions created by other functions.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
j <- function(x) { 
\end_layout

\begin_layout Plain Layout

\family sans
y <- 2 
\end_layout

\begin_layout Plain Layout

\family sans
function() { 
\end_layout

\begin_layout Plain Layout

\family sans
c(x, y) 
\end_layout

\begin_layout Plain Layout

\family sans
} 
\end_layout

\begin_layout Plain Layout

\family sans
} 
\end_layout

\begin_layout Plain Layout

\family sans
k <- j(1) 
\end_layout

\begin_layout Plain Layout

\family sans
k()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It works because 
\family sans
k
\family default
 preserves the environment in which it was defined and because the environment
 includes the value of 
\family sans
y
\family default
.
\end_layout

\begin_layout Itemize

\emph on
Environments
\emph default
 gives some pointers on how you can dive in and figure out what values are
 stored in the environment associated with each function.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
functions vs.
 variables 
\end_layout

\begin_deeper
\begin_layout Itemize
The same principles apply regardless of the type of associated value - finding
 functions works exactly the same way as finding variables
\end_layout

\begin_layout Itemize
For functions, there is one small tweak to the rule.
 If you are using a name in a context where it's obvious that you want a
 function (e.g.
 f(3)), R will ignore objects that are not functions while it is searching.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
n <- function(x) x / 2 
\end_layout

\begin_layout Plain Layout

\family sans
o <- function() { 
\end_layout

\begin_layout Plain Layout

\family sans
n <- 10 n(n) 
\end_layout

\begin_layout Plain Layout

\family sans
} 
\end_layout

\begin_layout Plain Layout

\family sans
o() 
\end_layout

\begin_layout Plain Layout

\family sans
\emph on
#> [1] 5
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
However, using the same name for functions and other objects will make for
 confusing code, and is generally best avoided.
\end_layout

\end_deeper
\begin_layout Enumerate
a fresh start 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
exists
\family default
: it returns 
\family sans
TRUE
\family default
 if there's a variable of that name, otherwise it returns 
\family sans
FALSE
\family default
.)
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
j <- function() { 
\end_layout

\begin_layout Plain Layout

\family sans
if (!exists("a")) { 
\end_layout

\begin_layout Plain Layout

\family sans
a <- 1 
\end_layout

\begin_layout Plain Layout

\family sans
} else { 
\end_layout

\begin_layout Plain Layout

\family sans
a <- a + 1 
\end_layout

\begin_layout Plain Layout

\family sans
} 
\end_layout

\begin_layout Plain Layout

\family sans
print(a) 
\end_layout

\begin_layout Plain Layout

\family sans
} 
\end_layout

\begin_layout Plain Layout

\family sans
j()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
It returns the same value, 1, every time.
 This is because every time a function is called, a new environment is created
 to host execution.
 A function has no way to tell what happened the last time it was run; each
 invocation is completely independent.
\end_layout

\end_deeper
\begin_layout Enumerate
dynamic lookup
\end_layout

\begin_deeper
\begin_layout Itemize
Lexical scoping determines where to look for values, not when to look for
 them.
 R looks for values when the function is run, not when it's created.
 This means that the output of a function can be different depending on
 objects outside its environment.
\end_layout

\begin_layout Itemize
It means the function is no longer 
\emph on
self-contained
\emph default
.
 This is a common error - if you make a spelling mistake in your code, you
 won't get an error when you create the function, and you might not even
 get one when you run the function, depending on what variables are defined
 in the global environment.
\end_layout

\begin_layout Itemize
Function 
\family sans
findGloabals()
\family default
 in package 
\family sans
codetools
\family default
 can list all the external dependencies of a function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() x + 1 
\end_layout

\begin_layout Standard

\family sans
codetools::findGlobals(f) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "+" "x"
\end_layout

\end_deeper
\begin_layout Itemize
We can mannually change the environment of the function to the emptyenv(),
 an evenironment which contains absolutely nothing:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
environment(f) <- emptyenv() 
\end_layout

\begin_layout Standard

\family sans
f() 
\end_layout

\begin_layout Standard

\family sans
#> Error: could not find function "+"
\end_layout

\begin_layout Itemize
This doesn't work because R relies on lexical scoping to find everything,
 even the + operator.
 
\end_layout

\begin_layout Itemize
It's never possible to make a function completely self-contained because
 you must always rely on functions defined in base R or other packages.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsubsection
Every operation is a function call
\end_layout

\begin_layout Itemize

\family sans
To understand computations in R, two slogans are helpful:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
Everything that exists is an object.
\end_layout

\begin_layout Itemize

\family sans
Everything that happens is a function call.
\end_layout

\end_deeper
\begin_layout Itemize
Note that `, the backtick, lets you refer to functions or variables that
 have otherwise reserved or illegal names:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 10; y <- 5
\end_layout

\begin_layout Standard

\family sans
`+`(x, y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 15
\end_layout

\begin_layout Standard

\family sans
`if`(i == 1, print("yes!"), print("no."))
\end_layout

\begin_layout Standard

\family sans
`{`(print(1), print(2), print(3))
\end_layout

\end_deeper
\begin_layout Itemize
In the following examples, note the difference b/t 
\family sans
`+`
\family default
 and 
\family sans

\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset


\family default
.
 The first one is the value of the object called +, and the second is a
 string containing the character +.
 The 2nd works because 
\family sans
\bar under
lapply
\family default
 can be given the name of a function instead of the function itself
\bar default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
sapply(1:5, `+`, 3) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4 5 6 7 8
\emph default
 
\end_layout

\begin_layout Standard

\family sans
sapply(1:5, "+", 3) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4 5 6 7 8
\end_layout

\end_deeper
\begin_layout Itemize
A more useful application is combining 
\family sans
lapply()
\family default
 or 
\family sans
sapply()
\family default
 with subsetting:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- list(1:3, 4:9, 10:12) 
\end_layout

\begin_layout Standard

\family sans
sapply(x, "[", 2) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 5 11
\end_layout

\begin_layout Standard

\family sans
\emph on
# equivalent to 
\end_layout

\begin_layout Standard

\family sans
sapply(x, function(x) x[2]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 5 11
\end_layout

\end_deeper
\begin_layout Subsubsection
Function argumens 
\end_layout

\begin_layout Itemize
The formal arguments are a property of the function, whereas the actual
 or calling arguments can vary each time you call the function.
 
\end_layout

\begin_layout Itemize

\series bold
Calling functions
\end_layout

\begin_deeper
\begin_layout Itemize
When calling a function you can specify arguments 
\series bold
by position
\series default
, 
\series bold
by complete name
\series default
, or 
\series bold
by partial name
\series default
.
 Arguments are matched 
\series bold
first by exact name
\series default
 (perfect matching), 
\series bold
then by prefix matching
\series default
 and 
\series bold
finally by position
\series default
.
\end_layout

\begin_layout Itemize
Named arguments should always come after unnamed arguments.
 
\end_layout

\begin_layout Itemize
If a function uses 
\family sans
...

\family default
 (discussed in more detail below), you can only specify arguments listed
 after 
\family sans
...

\family default
 with their full name.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Calling a function given a list of arguments
\end_layout

\begin_deeper
\begin_layout Itemize
Suppose you had a list of function arguments, you need do.call() to send
 that list to a function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
do.call(mean, list(1:10, na.rm = TRUE)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 5.5 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Equivalent to 
\end_layout

\begin_layout Standard

\family sans
mean(1:10, na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 5.5
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Default and missing arguments
\end_layout

\begin_deeper
\begin_layout Itemize
Function arguments in R can have default values.
\end_layout

\begin_layout Itemize
Since arguments in R are evaluated lazily (more on that below), the default
 value can be defined in terms of other arguments:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
g <- function(a = 1, b = a * 2) {c(a, b) }
\end_layout

\end_deeper
\begin_layout Itemize
Default arguments can even be defined in terms of variables created 
\series bold
within
\series default
 the function.
 
\end_layout

\begin_layout Itemize
You can determine if an argument was supplied or not with the 
\family sans
missing()
\family default
 function: 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
i <- function(a, b) { c(missing(a), missing(b)) }
\end_layout

\begin_layout Standard

\family sans
i(a = 1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE TRUE
\end_layout

\begin_layout Standard

\family sans
i(1, 2) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE FALSE
\end_layout

\end_deeper
\begin_layout Itemize
We also can set the default value to 
\family sans
NULL
\family default
, and use 
\family sans
is.null()
\family default
 to check if the argument was supplied.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Lazy evaluation
\end_layout

\begin_deeper
\begin_layout Itemize
By default, R function arguments are lazy - they're only evaluated if they're
 actually used:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) { 10 } 
\end_layout

\begin_layout Standard

\family sans
f(stop("This is an error!")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10
\end_layout

\end_deeper
\begin_layout Itemize
If you want to ensure that an argument is evaluated you can use
\family sans
 force
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) { 
\series bold
force
\series default
(x) 10 } 
\end_layout

\begin_layout Standard

\family sans
f(stop("This is an error!")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: This is an error!
\end_layout

\end_deeper
\begin_layout Itemize
This is important when creating closures with lapply or a loop:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
add <- function(x) { function(y) x + y } 
\end_layout

\begin_layout Standard

\family sans
adders <- lapply(1:10, add) 
\end_layout

\begin_layout Standard

\family sans
adders[[1]](10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 20 
\end_layout

\begin_layout Standard

\family sans
adders[[10]](10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 20
\end_layout

\begin_layout Standard
x is lazily evaluated in the first time that we call one of the adder functions.
 At this point, the loop is complete and the final value of x is 10.
 Therefore all of the adder functions will add 10 on to their input.
\end_layout

\begin_layout Standard

\family sans
add <- function(x) { 
\series bold
force(x)
\series default
 function(y) x + y } 
\end_layout

\begin_layout Standard

\family sans
adders2 <- lapply(1:10, add) 
\end_layout

\begin_layout Standard

\family sans
adders2[[1]](10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 11 
\end_layout

\begin_layout Standard

\family sans
adders2[[10]](10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 20
\end_layout

\begin_layout Itemize
the force function is defined as force <- function(x) x.
 
\end_layout

\end_deeper
\begin_layout Itemize
Default arguments are evaluated inside the function.
 This means that if the expression depends on the current environment the
 results will differ depending on whether you use the default value or explicitl
y provide one.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x = ls()) { a <- 1 x }
\end_layout

\begin_layout Standard

\family sans
\emph on
# ls() evaluated inside f: 
\end_layout

\begin_layout Standard

\family sans
f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" "x"
\end_layout

\begin_layout Standard

\family sans
\emph on
# ls() evaluated in global environment: 
\end_layout

\begin_layout Standard

\family sans
f(ls())
\end_layout

\end_deeper
\begin_layout Itemize
More technically, an unevaluated argument is called a 
\series bold
promise
\series default
, or (less commonly) a 
\series bold
thunk
\series default
.
 A promise is made up of two parts:
\end_layout

\begin_deeper
\begin_layout Itemize
the expression which gives rise to the delayed computation.
 (It can be accessed with substitute.)
\end_layout

\begin_layout Itemize
the environment where the expression was created and where it should be
 evaluated.
\end_layout

\end_deeper
\begin_layout Itemize
Find more information about a promise using 
\family sans
pryr::promise_info
\family default
.
\end_layout

\begin_layout Itemize
Laziness is useful in if statements - the second statement below will be
 
\series bold
evaluated only
\series default
 if the first is true.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- NULL 
\end_layout

\begin_layout Standard

\family sans
if (!is.null(x) && x > 0) {
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
Sometimes you can also use laziness to eliminate an if statement altogether.
 For example, instead of:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
if (is.null(a)) stop("a is null") 
\end_layout

\begin_layout Standard

\family sans
#> Error: a is null
\end_layout

\begin_layout Standard
You could write:
\end_layout

\begin_layout Standard

\family sans
!is.null(a) || stop("a is null") 
\end_layout

\begin_layout Standard

\family sans
#> Error: a is null
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family sans
...
\end_layout

\begin_deeper
\begin_layout Itemize
Special argument called ..., this argument will match any arguments not otherwise
 matched, and can be easily passed on to other functions.
\end_layout

\begin_layout Itemize
This is useful if you want to collect arguments to call another function,
 but you don't want to prespecify their possible names.
\end_layout

\begin_layout Itemize
...
 is often used in conjunction with S3 generic functions to allow individual
 methods to be more flexible.
\end_layout

\begin_layout Itemize
the advantages and disadvantages of ...: it makes 
\family sans
plot()
\family default
 very flexible, but to understand how to use it, we have to carefully read
 the documentation.
 
\end_layout

\begin_layout Itemize
To capture ...
 in a form that is easier to work with, you can use 
\family sans
list(...)
\family default
.
\end_layout

\begin_layout Itemize
Using ...
 comes at a price - any misspelled arguments will not raise an error, and
 any arguments after ...
 must be fully named.
 This makes it easy for typos to go unnoticed:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
sum(1, 2, na.mr = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Special calls
\end_layout

\begin_layout Itemize

\series bold
Infix functions
\end_layout

\begin_deeper
\begin_layout Itemize
Most functions in R are "
\series bold
prefix
\series default
" operators: the name of the function comes before the arguments.
\end_layout

\begin_layout Itemize

\series bold
infix
\series default
 functions where the function name comes in between its arguments, like
 + or -.
\end_layout

\begin_layout Itemize
All user created infix functions names must start and end with % and R comes
 with the following infix functions predefined: %%, %*%, %/%, %in%, %o%,
 %x%.
\end_layout

\begin_layout Itemize
The complete list of built-in infix operators that don't need % is: ::,
 :::, $, @, ^, *, /, +, -, >, >=, <, <=, ==, !=, !, &, &&, |, ||, ~, <-,
 <<-
\end_layout

\begin_layout Itemize
Note that when creating the function, you have to put the name in quotes
 because it's a special name.
 This is just a syntactic sugar for an ordinary function call.
\end_layout

\begin_layout Itemize
as far as R is concerned there is no difference between these two expressions:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
"new" %+% " string" 
\end_layout

\begin_layout Standard

\family sans
#> [1] "new string" 
\end_layout

\begin_layout Standard

\family sans
`%+%`("new", " string") 
\end_layout

\begin_layout Standard

\family sans
#> [1] "new string"
\end_layout

\end_deeper
\begin_layout Itemize
The names of infix functions are more flexible than regular R functions:
 they can contain any sequence of characters (except "%", of course)
\end_layout

\begin_layout Itemize
R's default precedence rules mean that infix operators are composed from
 left to right:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
"%-%" <- function(a, b) paste0("(", a, " %-% ", b, ")") 
\end_layout

\begin_layout Standard

\family sans
"a" %-% "b" %-% "c" 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "((a %-% b) %-% c)"
\end_layout

\end_deeper
\begin_layout Itemize
A way of providing a default value in case the output of another function
 is 
\family sans
NULL
\family default
 (author defined function):
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
"%||%" <- function(a, b) if (!is.null(a)) a else b 
\end_layout

\begin_layout Standard

\family sans
function_that_might_return_null() %||% default value
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Replacement functions
\end_layout

\begin_deeper
\begin_layout Itemize
Replacement functions act 
\emph on
like
\emph default
 they modify their arguments in place (because they actually create a modified
 copy
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We can see that by using 
\family sans
pryr::address()
\family default
 to find the memory address of the underlying object.
 Built in functions that are implemented using .Primitive will modify in
 place
\end_layout

\end_inset

), and have the special name 
\family sans
xxx<-
\end_layout

\begin_layout Itemize
They typically have two arguments (x and value), although they can have
 more, and they must return the modified object.
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
"second<-" <- function(x, value) { x[2] <- value x } 
\end_layout

\begin_layout Standard

\family sans
x <- 1:10 
\end_layout

\begin_layout Standard

\family sans
second(x) <- 5L 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 5 3 4 5 6 7 8 9 10
\end_layout

\begin_layout Standard
When R evaluates the assignment second(x) <- 5, it notices that the left
 hand side of the <- is not a simple name, so it looks for a function named
 second<- to do the replacement.
\end_layout

\end_deeper
\begin_layout Itemize
Combining replacement and subsetting:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- c(a = 1, b = 2, c = 3) 
\end_layout

\begin_layout Standard

\family sans
names(x) 
\end_layout

\begin_layout Standard

\family sans
#> [1] "a" "b" "c" 
\end_layout

\begin_layout Standard

\family sans
names(x)[2] <- "two" 
\end_layout

\begin_layout Standard

\family sans
names(x) 
\end_layout

\begin_layout Standard

\family sans
#> [1] "a" "two" "c"
\end_layout

\begin_layout Standard
This is done as follows in R: 
\end_layout

\begin_layout Standard

\family sans
`*tmp*` <- names(x) 
\end_layout

\begin_layout Standard

\family sans
`*tmp*`[2] <- "two" 
\end_layout

\begin_layout Standard

\family sans
names(x) <- `*tmp*`
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
setdiff 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
function (x, y) { 
\end_layout

\begin_layout Standard

\family sans
x <- as.vector(x) 
\end_layout

\begin_layout Standard

\family sans
y <- as.vector(y) 
\end_layout

\begin_layout Standard

\family sans
unique(if (length(x) || length(y)) 
\end_layout

\begin_layout Standard

\family sans
x[match(x, y, 0L) == 0L] 
\end_layout

\begin_layout Standard

\family sans
else x) 
\end_layout

\begin_layout Standard

\family sans
}
\family default
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Return values
\end_layout

\begin_layout Itemize
The last expression evaluated in a function becomes the return value, the
 result of invoking the function.
\end_layout

\begin_layout Itemize
it's good style to reserve the use of an explicit return() for when you
 are returning early, such as for an error, or a simple case of the function.
\end_layout

\begin_layout Itemize
Functions can return only a single value.
 In practice, this is not a limitation because you can always return a list
 containing any number of objects.
\end_layout

\begin_layout Itemize
The functions that are the easiest to understand and reason about are 
\series bold
pure functions
\series default
: functions that always map the same input to the same output and have no
 other impact on the workspace.
 
\end_layout

\begin_layout Itemize
In other words, pure functions have 
\series bold
no side-effects
\series default
: they don't affect the state of the world in any way apart from the value
 they return.
\end_layout

\begin_layout Itemize
R protects you from one type of side-effect: most R objects have copy-on-modify
 semantics.
 So modifying a function argument does not change the original value
\begin_inset Foot
status open

\begin_layout Plain Layout
There are two important exceptions to the copy-on-modify rule: environments
 and reference classes.
 These can be modified in place, so extra care is needed when working with
 them.
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) { x$a <- 2 x } 
\end_layout

\begin_layout Standard

\family sans
x <- list(a = 1) 
\end_layout

\begin_layout Standard

\family sans
f(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 
\end_layout

\begin_layout Standard

\family sans
x$a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\end_layout

\end_deeper
\begin_layout Itemize
Note that the performance consequences are a result of R's implementation
 of copy-on-modify semantics, they are not true in general.
 
\end_layout

\begin_layout Itemize
Most base R functions are pure, with a few notable exceptions:
\end_layout

\begin_deeper
\begin_layout Itemize
library which loads a package, and hence modifies the search path.
\end_layout

\begin_layout Itemize
setwd, Sys.setenv, Sys.setlocale which change the working directory, environment
 variables and the locale respectively.
\end_layout

\begin_layout Itemize
plot and friends which produce graphical output.
\end_layout

\begin_layout Itemize
write, write.csv, saveRDS etc.
 which save output to disk.
\end_layout

\begin_layout Itemize
options and par which modify global settings.
\end_layout

\begin_layout Itemize
S4 related functions which modify global tables of classes and methods.
\end_layout

\begin_layout Itemize
Random number generators which produce different numbers each time you run
 them.
\end_layout

\end_deeper
\begin_layout Itemize
Functions can return invisible values, which are not printed out by default
 when you call the function.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f2 <- function() 
\series bold
invisible(1)
\end_layout

\begin_layout Standard

\family sans
f2() == 1
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\begin_layout Itemize
You can always force an invisible value to be displayed by wrapping it in
 parentheses.
\end_layout

\begin_layout Itemize

\family sans
on.exit()
\end_layout

\begin_deeper
\begin_layout Itemize
Another more casual way of cleaning up is the on.exit function, which is
 called when the function terminates.
 It's not as fine grained as tryCatch, but it's a bit less typing.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
in_dir <- function(path, code) { 
\end_layout

\begin_layout Standard

\family sans
cur_dir <- getwd() 
\end_layout

\begin_layout Standard

\family sans
on.exit(setwd(cur_dir))
\end_layout

\begin_layout Standard

\family sans
force(code) }
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
OO (Object Oriented) field guide
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Itemize
Central to any object-oriented system are the concepts of class and method.
 
\end_layout

\begin_layout Itemize
A 
\series bold
class
\series default
 defines the behaviour of objects by describing their attributes and their
 relationship to other classes.
\end_layout

\begin_layout Itemize
The class is also used when selecting 
\series bold
methods
\series default
, (i.e.) functions that behave differently depending on the class of their
 input.
\end_layout

\begin_layout Itemize
Classes are usually organised in a 
\series bold
hierarchy
\series default
: if a method does not exist for a child, then the parent's method is used
 instead.
 This means the child 
\series bold
inherits
\series default
 behaviour from the parent.
\end_layout

\begin_layout Itemize
R's three OO systems differ in how classes and methods are defined:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
S3
\series default
 implements a style of OO programming called 
\emph on
generic-function
\emph default
 OO, in contrast to 
\emph on
message-passing
\emph default
 OO used in Java, C++ and C#.
 In S3, while computations are still carried out via methods, a special
 type of function called a 
\series bold
generic function
\series default
 decides which method to call.
 S3 is a very casual system, it has not formal definition of classes.
\end_layout

\begin_layout Itemize

\series bold
S4
\series default
 works similarly to S3, but is more formal.
 Two major differences to S3: S4 has formal class definitions, which describe
 the representation and inheritance of each class, and has special helper
 functions for defining generics and methods; S4 also has multiple dispatch,
 which means that generic functions can pick methods based on the class
 of any number of arguments, not just one.
\end_layout

\begin_layout Itemize

\series bold
Reference classes
\series default
 (RC) are quite different from S4 and S3.
 RC implements message-passing OO, so methods belong to classes, not functions.
 
\family sans
$
\family default
 is used to separate objects and methods, so method calls look like 
\family sans
canvas$drawRect("blue")
\family default
.
 RC objects are also mutable: they don't use R's usual copy-on-modify semantics,
 but are modified in place.
\end_layout

\begin_layout Itemize

\series bold
Base types
\series default
, the internal C-level types that underlie the other OO systems.

\series bold
 
\series default
Base types are mostly manipulated using C code, but they're important to
 know about because they provide the building blocks for the other OO systems.
\end_layout

\end_deeper
\begin_layout Subsubsection
Base types
\end_layout

\begin_layout Itemize
Underlying every R object is a C structure (or struct) that describes how
 that object is stored in memory.
 
\end_layout

\begin_layout Itemize
The struct includes the contents of the object, the information needed for
 memory management, and most importantly for this section, a 
\series bold
type
\series default
.
 This is the
\series bold
 base type
\series default
 of an R object.
 
\end_layout

\begin_layout Itemize
Base types are not really an object system.
 In fact, only the R core team can create new types.
\end_layout

\begin_layout Itemize
Most common base types are atomic vectors and lists, other base types encompass
 functions, environments and other more exotic objects likes names, calls
 and promises.
\end_layout

\begin_layout Itemize
To determine an object's base type, use 
\family sans
typeof()
\family default
.
\end_layout

\begin_layout Itemize
Be aware that the names of base types are not used consistently throughout
 R: the type and the corresponding "is" function may have different names:
 for example, the type of a function is 
\begin_inset Quotes eld
\end_inset

closure
\begin_inset Quotes erd
\end_inset

 and the type of the primitive function is 
\begin_inset Quotes eld
\end_inset

builtin
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
corresponding to 
\family sans
is.function()
\family default
 and 
\family sans
is.primitive()
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Functions that behave differently for different base types are almost always
 written in C, where dispatch occurs using switch statements (e.g.
 
\family sans
switch(TYPEOF(x))
\family default
).
\end_layout

\begin_layout Itemize
S3 objects can be built on top of any base type, S4 objects use a special
 base type, and RC objects are a combination of S4 and environments (another
 base type).
\end_layout

\begin_layout Itemize
To see if an object is a pure base type, i.e.
 it doesn't also have S3, S4 or RC behaviour, check that 
\family sans
is.object(x)
\family default
 returns 
\family sans
FALSE
\family default
.
\end_layout

\begin_layout Subsubsection
S3
\end_layout

\begin_layout Itemize
It is the only OO system used in the base and stats packages, and it's the
 most commonly used system in packages.
\end_layout

\begin_layout Itemize
S3 is informal and ad hoc, but it has a certain elegance in its minimalism:
 you couldn't take any part of it away and still have a useful OO system.
\end_layout

\begin_layout Itemize

\series bold
Recognising objects, generic functions and methods
\end_layout

\begin_deeper
\begin_layout Itemize
You can check this with 
\family sans
is.object(x) & !isS4(x)
\family default
 (the second expression tests whether it's not an S4 object).
\end_layout

\begin_layout Itemize
An easier way to determine the OO system of an object is to use 
\family sans
pryr::otype()
\end_layout

\begin_layout Itemize
In S3, 
\bar under
methods are associated with functions
\bar default
, called 
\series bold
generic functions
\series default
 or 
\series bold
generics
\series default
 for short, not objects or classes.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
This is different from most of other programming languages.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To determine if a function is an S3 generic, you can look at its source
 code for a call to 
\family sans
UseMethod():
\family default
 that's the function that figures out the correct method to call, the process
 of 
\series bold
method dispatch
\series default
.
 
\end_layout

\begin_layout Itemize
pryr also provides 
\family sans
ftype()
\family default
 which describes the object system, if any, associated with a function:
 
\family sans
ftype(mean) 
\emph on
#> [1] "s3" "generic"
\end_layout

\begin_layout Itemize
Some S3 generics, like 
\family sans
[, sum
\family default
 and 
\family sans
cbind
\family default
, don't call 
\family sans
UseMethod()
\family default
 because they are implemented in C.
 Instead, they call the C functions 
\family sans
DispatchGroup()
\family default
 or 
\family sans
DispatchOrEval()
\family default
.
 These function that do method dispathc in C code are called 
\series bold
internal generics
\series default
.
\end_layout

\begin_layout Itemize
Internal generics are documented in 
\family sans
?
\begin_inset Quotes eld
\end_inset

internal generic
\begin_inset Quotes erd
\end_inset


\family default
.
 
\family sans
ftype()
\family default
 knows about these special cases too.
\end_layout

\begin_layout Itemize
The job of an S3 generic is to call an S3 method specialised for a given
 class.
\end_layout

\begin_layout Itemize
Format of the names for S3 methods is like 
\family sans
generic.class()
\family default
, e.g.
 
\family sans
print.factor()
\family default
 or 
\family sans
mean.Date()
\family default
, etc.
\end_layout

\begin_layout Itemize

\family sans
pryr::ftype()
\family default
 knows about these exceptions, so you can use it to figure out if a function
 is an S3 method or generic.
\end_layout

\begin_layout Itemize
You can see all the methods of a generic using the 
\family sans
methods()
\family default
 function: 
\family sans
methods(mean)
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
Apart from methods defined in the base package, most S3 methods will not
 be visible: use getS3method() to read their source code.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
You can also list all generics that have a method for a given class: 
\family sans
methods(class = "ts")
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
Because there's no central repository, there's no way to list all S3 classes.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Defining classes and creating objects
\end_layout

\begin_deeper
\begin_layout Itemize
To make an object an instance of a class, you just take an existing base
 object and set the class attribute.
\end_layout

\begin_layout Itemize
You can do that during creation with 
\family sans
structure()
\family default
, or after the fact with 
\family sans
attr<-().
 
\family default
However, if you're modifying an existing object, using 
\family sans
class<-() 
\family default
will more clearly communicate your intent.
\end_layout

\begin_layout Itemize
S3 objects are usually built on top of lists, or atomic vectors with attributes.
\end_layout

\begin_layout Itemize
You can determine the class of any object using 
\family sans
class(x)
\family default
, and see if an object inherits from a specific class using 
\family sans
inherits(x, "classname")
\family default
.
\end_layout

\begin_layout Itemize
The class of an S3 object can be a vector (i.e.
 belongs to more than one class), which describes behaviour from most to
 least specific.
 For example, the class of the 
\family sans
glm()
\family default
 object is 
\family sans
c("glm", "lm")
\family default
 indicating that generalised linear models inherit behaviour from linear
 models.
\end_layout

\begin_layout Itemize
Most S3 classes provide a constructor function.
 You should use it if it's available (like for 
\family sans
factor()
\family default
 and 
\family sans
data.frame()
\family default
).
 This ensures that you're creating the class with the correct components.
 Constructor functions usually have the same name as the class.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
foo <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
if (!is.numeric(x)) stop("X must be numeric") 
\end_layout

\begin_layout Standard

\family sans
structure(list(x), class = "foo") 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
Apart from developer supplied constructor functions, S3 has no checks for
 correctness.
 This means you can change the class of existing objects.
\begin_inset Foot
status open

\begin_layout Plain Layout
While you can change the type of an object, you never should.
 R doesn't protect you from yourself: you can easily shoot yourself in the
 foot.
 As long as you don't aim the gun at your foot and pull the trigger, you
 won't have a problem.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Creating new methods and generics
\end_layout

\begin_deeper
\begin_layout Itemize
To add a new generic, create a function that calls 
\family sans
UseMethod()
\family default
.
\end_layout

\begin_layout Itemize

\family sans
UseMethod()
\family default
 takes two arguments: the name of the generic function, and the argument
 to use for method dispatch.
 If you omit the second argument it will dispatch on the first argument
 to the function.
 
\end_layout

\begin_layout Itemize
There's no need to pass any of the arguments of the generic to 
\family sans
UseMethod()
\family default
.
 In fact, you shouldnt do so.
 
\family sans
UseMethod()
\family default
 uses black magic to find them out for itself.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) UseMethod("f")
\end_layout

\end_deeper
\begin_layout Itemize
A generic isn't useful without some methods.
 To add a method, you just create a regular function with the correct (
\family sans
generic.class
\family default
) name:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f.a <- function(x) "Class a"
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Method dispatch
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
UseMethod()
\family default
 creates a vector of function names, like 
\family sans
paste0("generic", ".", c(class(x), "default"))
\family default
 and looks for each in turn.
 The "default" class makes it possible to set up a fall back method for
 otherwise unknown classes:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) UseMethod("f") 
\end_layout

\begin_layout Standard

\family sans
f.a <- function(x) "Class a" 
\end_layout

\begin_layout Standard

\family sans
f.default <- function(x) "Unknown class"
\end_layout

\begin_layout Standard

\family sans
f(structure(list(), class = "a")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "Class a" 
\end_layout

\begin_layout Standard

\family sans
\emph on
# No method for b class, so uses method for a class 
\end_layout

\begin_layout Standard

\family sans
f(structure(list(), class = c("b", "a"))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "Class a" 
\end_layout

\begin_layout Standard

\family sans
\emph on
# No method for c class, so falls back to default 
\end_layout

\begin_layout Standard

\family sans
f(structure(list(), class = "c")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "Unknown class"
\end_layout

\end_deeper
\begin_layout Itemize
Group generics make it possible to implement methods for multiple generics
 with one function.
 
\end_layout

\begin_layout Itemize
The four group generics and the functions they include are:
\end_layout

\begin_deeper
\begin_layout Itemize
Math: 
\family sans
abs, sign, sqrt, floor, cos, sin, log, exp, ...
 
\end_layout

\begin_layout Itemize
Ops: 
\family sans
+, -, *, /, ^, %%, %/%, &, |, !, ==, !=, <, <=, >=, > 
\end_layout

\begin_layout Itemize
Summary: 
\family sans
all, any, sum, prod, min, max, range
\family default
 
\end_layout

\begin_layout Itemize
Complex: 
\family sans
Arg, Conj, Im, Mod, Re
\end_layout

\end_deeper
\begin_layout Itemize
Find out more about them in 
\family sans
?groupGeneric
\family default
.
\end_layout

\begin_layout Itemize
The most important thing to take away from this is to recognise that 
\family sans
Math, Ops, Summary
\family default
 and 
\family sans
Complex
\family default
 aren't real functions.
 They represent groups of functions.
 Note that inside a group generic function a special variable 
\family sans
.Generic
\family default
 provides the actual generic function called.
\end_layout

\begin_layout Itemize
If you have complex class hierarchies it's sometimes useful to call the
 "parent" method.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is an advanced technique: read about it in 
\family sans
?NextMethod.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Because methods are normal R functions, you can call them directly.
 (i.e type the full name as 
\family sans
generic.class
\family default
).
 However, this is just as dangerous as changing the class of an object.
\end_layout

\begin_layout Itemize
You can also call an S3 generic with a non-S3 object.
 Non-internal S3 generics will dispatch on the 
\series bold
implicit class
\series default
 of base types.
 (Internal generics don't do that for performance reasons.)
\end_layout

\end_deeper
\begin_layout Itemize
Carefully read 
\family sans
?"internal generic"
\family default
 .
 
\family sans
UseMethod()
\end_layout

\begin_layout Subsubsection
S4
\end_layout

\begin_layout Itemize
S4 works in a similar way to S3, but it adds formality and rigour.
 Methods still belong to functions, not classes, but:
\end_layout

\begin_deeper
\begin_layout Itemize
Classes have a formal definition, describing their fields and inheritance
 structure (parent classes).
\end_layout

\begin_layout Itemize
Method dispatch can be based on multiple arguments to a generic function,
 not just one.
\end_layout

\begin_layout Itemize
There is a special operator, 
\family sans
@
\family default
, for extracting fields (aka 
\series bold
slots
\series default
) out of an S4 object.
\end_layout

\end_deeper
\begin_layout Itemize
All S4 related code is stored in the methods package.
 This package is always available when you're running 
\family sans
R
\family default
 interactively, but is not always loaded automatically when running 
\family sans
R
\family default
 in batch mode.
 For this reason, it's a good idea to include an explicit 
\family sans
library(methods)
\family default
 whenever you're using S4.
\end_layout

\begin_layout Itemize
Good references:
\end_layout

\begin_deeper
\begin_layout Itemize
S4 system development in Bioconductor
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.bioconductor.org/help/course-materials/2010/AdvancedR/S4InBioconductor.p
df
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Book: Software for Data Analysis (by John Chambers) 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://ishare.iask.sina.com.cn/f/12201138.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Stackoverflow answers to S4 questions by Martin Morgan.
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stackoverflow.com/search?tab=votes&q=user%3a547331%20%5bs4%5d%20is%3aanswe
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Recognising objects, generic functions and methods
\end_layout

\begin_deeper
\begin_layout Itemize
You can identify an S4 object because 
\family sans
str()
\family default
 describes it as a "
\series bold
formal
\series default
" class, 
\family sans
isS4()
\family default
 is 
\family sans
TRUE
\family default
, and 
\family sans
pryr::otype()
\family default
 returns "S4".
 
\end_layout

\begin_layout Itemize
There aren't any S4 classes in the commonly used base packages (stats, graphics,
 utils, datasets, and base).
\end_layout

\begin_layout Itemize
You can determine the class of an S4 object with 
\family sans
class()
\family default
 and test if an object inherits from a specific class with 
\family sans
is().
\end_layout

\begin_layout Itemize
You can get a list of all S4 generics with 
\family sans
getGenerics()
\family default
, and a list of all S4 classes with 
\family sans
getClasses()
\family default
, but note that this list includes shim classes for S3 classes and base
 types.
\end_layout

\begin_layout Itemize
You can list all S4 methods with 
\family sans
showMethods()
\family default
, optionally restricting either by 
\family sans
generic
\family default
 or by 
\family sans
class
\family default
 (or both).
 It's also a good idea to supply 
\family sans
where = search()
\family default
 to restrict to methods available from the global environment.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Defining classes and creating objects
\end_layout

\begin_deeper
\begin_layout Itemize
In setting the class for an object in S4 is much stricter than in S3: you
 must define the representation of the class using 
\family sans
setClass()
\family default
, and create an new object with 
\family sans
new()
\family default
.
 You can find the documentation for a class with a special syntax: 
\family sans
class?className
\family default
, e.g.
 
\family sans
class?mle
\family default
.
\end_layout

\begin_layout Itemize
An S4 class has three key properties:
\end_layout

\begin_deeper
\begin_layout Itemize
A 
\series bold
name
\series default
: an alpha-numeric class identifier.
 S4 class names should use 
\series bold
UpperCamelCase
\series default
.
\end_layout

\begin_layout Itemize
A 
\bar under
named list
\bar default
 of 
\series bold
slots
\series default
 (fields), 
\bar under
providing slot names and permitted classes
\bar default
.
 For example, a person class might be represented by a character name and
 a numeric age: 
\family sans
list(name = "character", age = "numeric")
\family default
.
\end_layout

\begin_layout Itemize
A string giving the class it inherits from, or in S4 terminology, that it
 
\series bold
contains
\series default
.
 You can provide multiple classes for multiple inheritance, but this is
 an advanced technique and it adds much complexity.
\end_layout

\end_deeper
\begin_layout Itemize
In 
\bar under
slots and contains
\bar default
 you can use S4 classes, S3 classes registered with 
\family sans
setOldClass()
\family default
, or the implicit class of a base type.
 
\bar under
In slots
\bar default
 you can also use the special class 
\family sans
ANY
\family default
 which does not restrict the input.
\end_layout

\begin_layout Itemize
S4 classes have other optional properties like a validity method that tests
 if an object is valid, and a prototype that defines slot default values.
 
\end_layout

\begin_layout Itemize
See 
\family sans
?setClass
\family default
 for more details.
\end_layout

\begin_layout Itemize
The define of the new S4 class is similar to other language like Python.
\end_layout

\begin_layout Itemize
Example: create two classes 
\begin_inset Quotes eld
\end_inset

Person
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Employee
\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Quotes eld
\end_inset

Employee
\begin_inset Quotes erd
\end_inset

 inherits the slots and methods from 
\begin_inset Quotes eld
\end_inset

Person
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
setClass("Person", 
\end_layout

\begin_layout Standard

\family sans
slots = list(name = "character", age = "numeric")) 
\end_layout

\begin_layout Standard

\family sans
setClass("Employee", 
\end_layout

\begin_layout Standard

\family sans
slots = list(boss = "Person"), 
\end_layout

\begin_layout Standard

\family sans
contains = "Person")
\end_layout

\begin_layout Standard

\family sans
alice <- new("Person", name = "Alice", age = 40) 
\end_layout

\begin_layout Standard

\family sans
john <- new("Employee", name = "John", age = 20, boss = alice)
\end_layout

\end_deeper
\begin_layout Itemize
Most S4 classes also come with a 
\series bold
constructor function
\series default
 with the same name as the class: if that exists, use it instead of calling
 new() directly.
\end_layout

\begin_layout Itemize
To access slots of an S4 object you use 
\family sans
@
\family default
 or 
\family sans
slot() 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
@ is equivalent to $, and slot() to [[.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
alice@age 
\end_layout

\begin_layout Standard

\family sans
#> [1] 40 
\end_layout

\begin_layout Standard

\family sans
slot(john, "boss") 
\end_layout

\begin_layout Standard

\family sans
#> An object of class "Person" 
\end_layout

\begin_layout Standard

\family sans
#> Slot "name": 
\end_layout

\begin_layout Standard

\family sans
#> [1] "Alice" 
\end_layout

\begin_layout Standard

\family sans
#> 
\end_layout

\begin_layout Standard

\family sans
#> Slot "age": 
\end_layout

\begin_layout Standard

\family sans
#> [1] 40
\end_layout

\end_deeper
\begin_layout Itemize
If an S4 object contains (inherits) from an S3 class or a base type, it
 will have a special 
\family sans
.Data
\family default
 slot which contains the underlying base type or S3 object.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
setClass("RangedNumeric", 
\end_layout

\begin_layout Standard

\family sans
contains = "numeric", 
\end_layout

\begin_layout Standard

\family sans
slots = list(min = "numeric", max = "numeric")) 
\end_layout

\begin_layout Standard

\family sans
rn <- new("RangedNumeric", 1:10, min = 1, max = 10) 
\end_layout

\begin_layout Standard

\family sans
rn@min 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\emph default
 
\end_layout

\begin_layout Standard

\family sans
rn@.Data 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 2 3 4 5 6 7 8 9 10
\end_layout

\end_deeper
\begin_layout Itemize
When you're interactively experimenting with S4, if you modify a class,
 make sure you also recreate any objects of that class, otherwise you'll
 end up with invalid objects.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Creating new methods and generics
\end_layout

\begin_deeper
\begin_layout Itemize
S4 provides special functions for creating new generics and methods.
\end_layout

\begin_layout Itemize

\family sans
setGeneric()
\family default
 will create a new generic or convert an existing function into a generic.
\end_layout

\begin_layout Itemize

\family sans
setMethod()
\family default
 takes the 
\bar under
name of the generic
\bar default
, 
\bar under
the classes
\bar default
 the method should be associated with and 
\bar under
a function
\bar default
 that implements the method.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
setGeneric("union") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "union" 
\end_layout

\begin_layout Standard

\family sans
setMethod("union", c(x = "data.frame", y = "data.frame"), 
\end_layout

\begin_layout Standard

\family sans
function(x, y) { unique(rbind(x, y)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
)
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "union" 
\end_layout

\end_deeper
\begin_layout Itemize
If you create a new generic from scratch, you also need to supply a function
 that calls 
\family sans
standardGeneric()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
setGeneric("myGeneric", function(x) { 
\end_layout

\begin_layout Standard

\family sans
standardGeneric("myGeneric") 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "myGeneric"
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Method dispatch
\end_layout

\begin_deeper
\begin_layout Itemize
S4 method dispatch is the same as S3 dispatch 
\bar under
if your classes only inherit from a single parent
\bar default
, and you only dispatch on one class.
\end_layout

\begin_layout Itemize
The main difference is how you set up default values: S4 uses the special
 class 
\family sans
ANY
\family default
 to match any class and "missing" to match a missing argument.
\end_layout

\begin_layout Itemize
Like S3, S4 also has group generics, documented in 
\family sans
?S4groupGeneric
\family default
, and a way to call the "parent" method, 
\family sans
callNextMethod()
\family default
.
\end_layout

\begin_layout Itemize
If you dispatch on multiple arguments, or your classes use multiple inheritance,
 things can be very complicated.
 The rules are described in 
\family sans
?Methods
\family default
, but they are complicated and it's difficult to predict which method will
 be called.
\begin_inset Foot
status open

\begin_layout Plain Layout
The author strongly suggest avoiding multiple inheritance and mutilple dispatch
 unless absolutely necessary.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
There are two functions that identify the method that will be invoked given
 the specification of a call to a generic:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\emph on
# From methods: takes generic name and class names 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
selectMethod("nobs", list("mle"))
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\emph on
# From pryr: takes an unevaluated function call 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
method_from_call(nobs(fit))
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Read 
\family sans
?Classes
\family default
 for an overview of S4 classes.
\end_layout

\begin_layout Itemize
What happens if you pass an S4 object to an S3 generic? What happens if
 you pass an S3 object to an S4 generic?
\end_layout

\begin_layout Itemize
Read 
\family sans
?setOldClass
\family default
: Registering via setOldClass allows S3 classes to appear in method signatures,
 as a slot in an S4 class, or as a superclass of an S4 class.
\end_layout

\end_deeper
\begin_layout Subsubsection
RC (Reference Classes)
\end_layout

\begin_layout Itemize
The newest OO system in R.
 They were introduced in version 2.12.
\end_layout

\begin_layout Itemize
They are fundamentally different to S3 and S4 because:
\end_layout

\begin_deeper
\begin_layout Itemize
RC methods belong to objects, not functions
\end_layout

\begin_layout Itemize
RC objects are mutable: the usual R copy-on-modify semantics do not apply
\end_layout

\begin_layout Itemize
These properties make RC objects behave more like objects do in most other
 programming languages, e.g., Python, Ruby, Java and C#.
 
\end_layout

\begin_layout Itemize
Surprisingly, reference classes are implemented in R, not C: they are a
 special S4 class that wraps around an environment.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Defining classes and creating objects
\end_layout

\begin_deeper
\begin_layout Itemize
RC classes are best used for describing stateful objects, objects that change
 over time, so we'll create a simple class to model a bank account.
\end_layout

\begin_layout Itemize
Creating a new RC class is similar to creating a new S4 class, but you use
 
\family sans
setRefClass()
\family default
 instead of 
\family sans
setClass()
\family default
.
\end_layout

\begin_layout Itemize
The first, and 
\bar under
only required argument
\bar default
, is an alpha-numeric 
\series bold
name
\series default
.
\end_layout

\begin_layout Itemize
While you can use 
\family sans
new()
\family default
 to create new RC objects, it's good style to use the object returned by
 
\family sans
setRefClass()
\family default
 to generate new objects.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Account <- setRefClass("Account") 
\end_layout

\begin_layout Standard

\family sans
Account$new() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Reference class object of class "Account"
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
setRefClass()
\family default
 also accepts a list of name-class pairs that define class 
\series bold
fields
\series default
 (equivalent to S4 slots).
 Additional named arguments passed to 
\series bold
new()
\series default
 will set initial values of the fields.
 You can get and set field values with 
\series bold
$:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Account <- setRefClass("Account", 
\end_layout

\begin_layout Standard

\family sans
fields = list(balance = "numeric"))
\end_layout

\begin_layout Standard

\family sans
a <- Account$new(balance = 100) 
\end_layout

\begin_layout Standard

\family sans
a$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 100 
\end_layout

\begin_layout Standard

\family sans
a$balance <- 200 
\end_layout

\begin_layout Standard

\family sans
a$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 200
\end_layout

\end_deeper
\begin_layout Itemize
Instead of supplying a class name for the field, you can provide a single
 argument function which will act as an accessor method.
 This allows you to add custom behaviour when getting or setting a field.
 See 
\family sans
?setRefClass
\family default
 for more details.
\end_layout

\begin_layout Itemize
Note that RC objects are 
\series bold
mutable
\series default
, i.e., they have reference semantics, and are not copied-on-modify:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
b <- a b$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 200
\emph default
 
\end_layout

\begin_layout Standard

\family sans
a$balance <- 0 
\end_layout

\begin_layout Standard

\family sans
b$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\end_layout

\end_deeper
\begin_layout Itemize
For this reason, RC objects come with a
\family sans
 copy()
\family default
 method that allow you to make a copy of the object:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
c <- a$copy() 
\end_layout

\begin_layout Standard

\family sans
c$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\emph default
 
\end_layout

\begin_layout Standard

\family sans
a$balance <- 100 
\end_layout

\begin_layout Standard

\family sans
c$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\end_layout

\end_deeper
\begin_layout Itemize
RC methods are associated with a class and can modify its fields in place.
 In the following example, note that you access the value of fields with
 their name, and modify them with 
\family sans
<<-
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Account <- setRefClass("Account", 
\end_layout

\begin_layout Standard

\family sans
fields = list(balance = "numeric"), 
\end_layout

\begin_layout Standard

\family sans
methods = list( 
\end_layout

\begin_layout Standard

\family sans
withdraw = function(x) { 
\end_layout

\begin_layout Standard

\family sans
balance <<- balance - x 
\end_layout

\begin_layout Standard

\family sans
}, 
\end_layout

\begin_layout Standard

\family sans
deposit = function(x) { 
\end_layout

\begin_layout Standard

\family sans
balance <<- balance + x 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
)
\end_layout

\begin_layout Standard

\family sans
a <- Account$new(balance = 100) 
\end_layout

\begin_layout Standard

\family sans
a$deposit(100) 
\end_layout

\begin_layout Standard

\family sans
a$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 200
\end_layout

\end_deeper
\begin_layout Itemize
The final important argument to 
\family sans
setRefClass()
\family default
 is 
\family sans
contains
\family default
.
 This is the name of the parent RC class to inherit behaviour from.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
NoOverdraft <- setRefClass("NoOverdraft", 
\end_layout

\begin_layout Standard

\family sans
contains = "Account", 
\end_layout

\begin_layout Standard

\family sans
methods = list( 
\end_layout

\begin_layout Standard

\family sans
withdraw = function(x) { 
\end_layout

\begin_layout Standard

\family sans
if (balance < x) stop("Not enough money") 
\end_layout

\begin_layout Standard

\family sans
balance <<- balance - x
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
accountJohn <- NoOverdraft$new(balance = 100) 
\end_layout

\begin_layout Standard

\family sans
accountJohn$deposit(50) 
\end_layout

\begin_layout Standard

\family sans
accountJohn$balance 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 150 
\end_layout

\begin_layout Standard

\family sans
accountJohn$withdraw(200) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: Not enough money
\end_layout

\end_deeper
\begin_layout Itemize
All reference classes eventually inherit from 
\family sans
envRefClass
\family default
.
 It provides useful methods like 
\family sans
copy()
\family default
 (shown above), 
\family sans
callSuper()
\family default
 (to call the parent field), 
\family sans
field()
\family default
 (to get the value of a field given its name), 
\family sans
export()
\family default
 (equivalent to 
\family sans
as
\family default
) and 
\family sans
show()
\family default
 (overridden to control printing).
\begin_inset Foot
status open

\begin_layout Plain Layout
See the inheritance section in setRefClass() for more details.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Recognising objects and methods
\end_layout

\begin_deeper
\begin_layout Itemize
You can recognise 
\bar under
RC objects because they are S4 objects
\bar default
 (
\family sans
isS4(x)
\family default
) that inherit from "
\family sans
refClass
\family default
" (
\family sans
is(x, "refClass")
\family default
).
 
\family sans
pryr::otype()
\family default
 will return "RC".
 
\bar under
RC methods are also S4 objects
\bar default
, with class 
\family sans
refMethodDef
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Method dispatch
\end_layout

\begin_deeper
\begin_layout Itemize
Method dispatch is very simple in RC because methods are associated with
 classes, not functions.
 When you call 
\family sans
x$f()
\family default
, R will look for a method f in the class of x, then in its parent, then
 its parent's parent, and so on.
 From within a method, you can call the parent method directly with 
\family sans
callSuper(...)
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
Exercises questions.
\end_layout

\begin_layout Subsubsection
Picking a system
\end_layout

\begin_layout Itemize
S3 is a little quirky, but it gets the job done with a minimum of code.
\end_layout

\begin_layout Itemize
If you are creating more complicated systems of interrelated objects, S4
 may be more appropriate.
 
\end_layout

\begin_layout Itemize
If you've mastered S3, S4 is relatively easy to pick up: the ideas are all
 the same, it is just more formal, more strict and more verbose.
\end_layout

\begin_layout Itemize
Resources to learn S4 
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
Bioconductor
\family default
 package: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.google.com/search?q=bioconductor+s4
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
Matrix
\family default
 package: 
\family sans
vignette("Intro2Matrix", package = "Matrix")
\end_layout

\end_deeper
\begin_layout Itemize
If you've programmed in mainstream OO language, RC will seem very natural.
 But because they can introduce side-effects through mutable state, they
 are harder to understand
\end_layout

\begin_layout Itemize
Generally, when using RC objects you want to minimise side effects as much
 as possible, and use them only where mutable states are absolutely required.
 The majority of functions should still be "functional", and free of side
 effects.
 
\end_layout

\begin_layout Subsection
Environments
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Itemize
Understanding environments is important to understanding scoping.
\end_layout

\begin_layout Itemize
what an environment is and how to inspect and manipulate them 
\end_layout

\begin_layout Itemize
the four types of environments associated with a function 
\end_layout

\begin_layout Itemize
how to work in an environment outside of a function with 
\family sans
local()
\family default
 
\end_layout

\begin_layout Itemize
the four ways of binding names to values in an environment
\end_layout

\begin_layout Subsubsection
Environment basics
\end_layout

\begin_layout Itemize

\series bold
What is an environment?
\end_layout

\begin_deeper
\begin_layout Itemize
The job of an environment is to associate, or bind, a set of names to a
 set of values.
\end_layout

\begin_layout Itemize
Environments are the data structures that power scoping.
 
\end_layout

\begin_layout Itemize
An environment is very similar to a list, with three important exceptions:
\end_layout

\begin_deeper
\begin_layout Itemize
Environments have reference semantics.
 So R's usual copy on modify rules do not apply.
 Whenever you modify an environment, you modify every copy.
\end_layout

\begin_layout Itemize
Environments have parents.
 If an object is not found in an environment, then R will look at its parent
 (and so on).
 
\end_layout

\begin_layout Itemize
There is only one exception: the 
\series bold
empty
\series default
 environment does not have a parent.
\begin_inset Foot
status open

\begin_layout Itemize
It's rare to talk about the children of an environment because there are
 no back links: given an environment we have no way to find its children.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Every object in an environment must have a name.
 And, those names must be unique.
\end_layout

\end_deeper
\begin_layout Itemize
Technically, an environment is made up of a 
\series bold
frame
\series default
, a collection of named objects (like a list), and a reference to a parent
 environment.
\end_layout

\begin_layout Itemize
As well as powering scoping, environments can also be useful data structures
 because they have reference semantics and can work like a 
\series bold
hashtable
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Manipulatin gand inspecting environments
\end_layout

\begin_deeper
\begin_layout Itemize
You can create environments with 
\family sans
new.env()
\family default
, see their contents with 
\family sans
ls()
\family default
, and inspect their parent with 
\family sans
parent.env()
\family default
.
\end_layout

\begin_layout Itemize
You can modify environments in the same way you modify lists:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
ls(e) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" 
\end_layout

\begin_layout Standard

\family sans
e$a <- 1 
\end_layout

\begin_layout Standard

\family sans
ls(e) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" 
\end_layout

\begin_layout Standard

\family sans
e$a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\end_layout

\end_deeper
\begin_layout Itemize
By default ls only shows names that don't begin with ..
 Use 
\family sans
all.names = TRUE
\family default
 (or all for short) to show all bindings in an environment.
\end_layout

\begin_layout Itemize
Another useful technique to view an environment is to coerce it to a list:
 
\family sans
as.list(env)
\end_layout

\begin_layout Itemize
You can extract elements of an environment using 
\family sans
$ 
\family default
or 
\family sans
[[
\family default
, or 
\family sans
get
\family default
().
 While 
\family sans
$
\family default
 and 
\family sans
[[
\family default
 will only look within an environment, 
\family sans
get
\family default
, using the 
\bar under
regular scoping rules
\bar default
, will also look in the parent if needed.
 
\family sans
$
\family default
 and 
\family sans
[[
\family default
 will return 
\family sans
NULL
\family default
 if the name is not found, while get returns an error.
\end_layout

\begin_layout Itemize
Deleting objects from environments works a little differently from lists.
 With a list you can remove an entry by setting it to 
\family sans
NULL
\family default
.
 Working in environments, instead you need to use 
\family sans
rm()
\family default
.
 
\family sans
E.g.
 rm("a", envir = e)
\end_layout

\begin_layout Itemize
Generally, when you create your own environment, you want to manually set
 the parent environment to the empty environment.
 This ensures you don't accidentally inherit objects from somewhere else:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
e1 <- new.env() 
\end_layout

\begin_layout Standard

\family sans
get("x", e1) 
\end_layout

\begin_layout Standard

\family sans
#> [1] 1
\end_layout

\begin_layout Standard

\family sans
e2 <- new.env(parent = 
\series bold
emptyenv
\series default
()) 
\end_layout

\begin_layout Standard

\family sans
get("x", e2) 
\end_layout

\begin_layout Standard

\family sans
#> Error: object 'x' not found
\end_layout

\end_deeper
\begin_layout Itemize
You can determine if a binding exists in a environment with the 
\family sans
exists()
\family default
 function.
 Like 
\family sans
get()
\family default
, the default is to follow regular scoping rules and look in parent environments.
 If you don't want this behavior, use 
\family sans
inherits = FALSE
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
exists("x", e1) 
\end_layout

\begin_layout Standard

\family sans
#> [1] TRUE 
\end_layout

\begin_layout Standard

\family sans
exists("x", e1, inherits = FALSE) 
\end_layout

\begin_layout Standard

\family sans
#> [1] FALSE
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Special environments
\end_layout

\begin_deeper
\begin_layout Itemize
There are a few special environments that you can access directly:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
globalenv()
\family default
: the user's workspace (top-level), the most common one;
\begin_inset Foot
status open

\begin_layout Plain Layout
The parent of the global environment is one of the packages you have loaded
 (the exact order will depend on the order in which packages were loaded).
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
baseenv()
\family default
: the environment of the base package, its parent is the empty environment.
\end_layout

\begin_layout Itemize

\family sans
emptyenv()
\family default
: the 
\bar under
ultimate ancestor
\bar default
 of all environments, the 
\bar under
only environment without a parent
\bar default
.
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
search()
\family default
 lists all environments between and including the global and base environments.
\end_layout

\begin_deeper
\begin_layout Itemize
This is called the search path because any object in these environments
 can be found from the top-level interactive workspace.
\end_layout

\begin_layout Itemize
It contains an environment for each loaded package and for each object (environm
ent, list or Rdata file) that you've 
\family sans
attach()
\family default
ed.
\end_layout

\begin_layout Itemize
It also contains a special environment called 
\family sans
Autoloads
\family default
 which is used to save memory by only loading package objects (like big
 datasets) when needed.
\end_layout

\end_deeper
\begin_layout Itemize
You can access the environments of any environment on the search list using
 
\family sans
as.environment()
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Where
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
pryr::where
\family default
 is built to tell us the environment where a variable is located.
 E.g.
 
\family sans
where(
\begin_inset Quotes eld
\end_inset

mean
\begin_inset Quotes erd
\end_inset

) #> <environment: base>
\end_layout

\begin_layout Itemize

\family sans
where()
\family default
 obeys the regular rules of variable scoping, but instead of returning the
 value associated with a name, it returns the environment in which it was
 defined.
\end_layout

\begin_layout Itemize

\family sans
where
\family default
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
#> function (name, env = parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> { 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> stopifnot(is.character(name), length(name) == 1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> env <- to_env(env) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> if (identical(env, emptyenv())) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> stop("Can't find ", name, call.
 = FALSE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> } 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> if (exists(name, env, inherits = FALSE)) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> env 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> } 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> else { 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> where(name, parent.env(env)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> } 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> } 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: namespace:pryr>
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
It's natural to work with environments recursively, so we'll see this style
 of function structure frequently.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
There are three main components:
\end_layout

\begin_deeper
\begin_layout Itemize
the base case (what happens when we've recursed up to the empty environment)
\end_layout

\begin_layout Itemize
a Boolean that determines if we've found what we wanted
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that to check if the environment is the same as the empty environment,
 we need to use identical().
 Unlike the element-wise ==, this performs a whole object comparison.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
the recursive statement that re-calls the function using the parent of the
 current environment.
\end_layout

\end_deeper
\begin_layout Itemize
Write your own version of 
\family sans
get()
\family default
 using a function written in the style of 
\family sans
where()
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
get2<-function(name,env=parent.frame()){
\end_layout

\begin_layout Standard

\family sans
stopifnot(is.character(name),length(name)==1)
\end_layout

\begin_layout Standard

\family sans
if (identical(env,emptyenv())){ 
\end_layout

\begin_layout Standard

\family sans
stop ("Can't find",name,fall.=F) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
if (exists(name,env,inherits=F)){ 
\end_layout

\begin_layout Standard

\family sans
env[[name]] 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
get2(name,parent.env(env)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Function environments
\end_layout

\begin_layout Itemize

\series bold
The environment where the function is created
\end_layout

\begin_deeper
\begin_layout Itemize
Most of the time, you do not create environments directly.
 They are created as a consequence of working with functions.
\end_layout

\begin_layout Itemize
When a function is created, it gains a reference to the environment where
 it was made.
 This is the parent, or enclosing, environment of the function used by lexical
 scoping.
 
\end_layout

\begin_deeper
\begin_layout Standard
You can access this environment with the 
\family sans
environment()
\family default
 function: 
\family sans
environment(plot) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: namespace:graphics>
\end_layout

\end_deeper
\begin_layout Itemize
The enclosing environment is particularly important for closures:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
plus <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
function(y) x + y 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
plus_one <- plus(1) 
\end_layout

\begin_layout Standard

\family sans
plus_one(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 11
\emph default
 
\end_layout

\begin_layout Standard

\family sans
plus_two <- plus(2) 
\end_layout

\begin_layout Standard

\family sans
plus_two(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 12
\end_layout

\begin_layout Standard

\family sans
environment(plus_one) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x106f1e788>
\emph default
 
\end_layout

\begin_layout Standard

\family sans
parent.env(environment(plus_one)) 
\end_layout

\begin_layout Standard

\family sans
#> <environment: R_GlobalEnv>
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
The environment where the function resides
\end_layout

\begin_deeper
\begin_layout Itemize
The environment of a function (use 
\family sans
funenv()
\family default
 to check) and the environment where it resides (use 
\family sans
where()
\family default
 to check) might be different.
\end_layout

\begin_layout Itemize
The environment where the function lives determines how we find the function.
\end_layout

\begin_layout Itemize
The environment of the function determines how we find values inside the
 function.
\end_layout

\begin_layout Itemize
This important distinction is what enables package 
\family sans
namespaces
\family default
 to work.
\end_layout

\begin_layout Itemize
The package environment contains only functions and objects that should
 be visible to the user, but the namespace environment contains both 
\bar under
internal and external functions
\bar default
.
\end_layout

\begin_layout Itemize
This mechanism makes it possible for packages to have internal objects that
 can be accessed by its functions, but not by external functions.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
The environment created when a function is run
\end_layout

\begin_deeper
\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
if (!exists("a", 
\series bold
inherits = FALSE
\series default
)) { 
\end_layout

\begin_layout Standard

\family sans
message("Defining a") 
\end_layout

\begin_layout Standard

\family sans
a <- 1 
\end_layout

\begin_layout Standard

\family sans
} else { 
\end_layout

\begin_layout Standard

\family sans
a <- a + 1 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
a 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard
It will return the same value each and every time it is called.
 This is because each time a function is called, a new environment is created
 to host execution.
\end_layout

\end_deeper
\begin_layout Itemize
Calling 
\family sans
environment()
\family default
 with no arguments returns the environment in which the call was made, so
 we can use it to confirm that functions have new hosting environments at
 every invocation.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
list( 
\end_layout

\begin_layout Standard

\family sans
e = environment(), 
\end_layout

\begin_layout Standard

\family sans
p = parent.env(environment()) 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
str(f()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> List of 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ e:<environment: 0x10528b5f0> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ p:<environment: R_GlobalEnv>
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
The environment where the function is called
\end_layout

\begin_deeper
\begin_layout Itemize
Example
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
x <- 10 
\end_layout

\begin_layout Standard

\family sans
function() { 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
g <- f() 
\end_layout

\begin_layout Standard

\family sans
x <- 20 
\end_layout

\begin_layout Standard

\family sans
g()
\end_layout

\begin_layout Standard

\family sans
\emph on
#[1] 10
\end_layout

\begin_layout Itemize
The top-level x is a red herring: using the regular scoping rules, 
\family sans
\bar under
g()
\family default
 looks first where it is defined and finds the value of x is 10
\bar default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
I.e.
 in lexical scoping, function looks for the object in the defining environment
 first.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
However, it is still meaningful to ask what value x is associated with in
 the environment where 
\family sans
g()
\family default
 is called.
 x is 10 in the environment where 
\family sans
g()
\family default
 is defined, but it is 20 in the environment where 
\family sans
g()
\family default
 is called.
\end_layout

\end_deeper
\begin_layout Itemize
We can access this environment using the confusingly named 
\family sans
parent.frame()
\family default
.
 
\bar under
This function returns the environment where the function is called
\bar default
.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f2 <- function() { 
\end_layout

\begin_layout Standard

\family sans
x <- 10 
\end_layout

\begin_layout Standard

\family sans
function() { 
\end_layout

\begin_layout Standard

\family sans
def <- get("x", environment()) 
\end_layout

\begin_layout Standard

\family sans
cll <- get("x", parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
list(defined = def, called = cll)
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
g2 <- f2() 
\end_layout

\begin_layout Standard

\family sans
x <- 20 
\end_layout

\begin_layout Standard

\family sans
str(g2()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> List of 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ defined: num 10 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ called : num 20
\end_layout

\end_deeper
\begin_layout Itemize
We can get a list of all calling environments using 
\family sans
sys.frames():
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
In more complicated scenarios, there's not just one parent call, but a sequence
 of calls which lead all the way back to the initiating function, called
 from the top-level.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 0 
\end_layout

\begin_layout Standard

\family sans
y <- 10 
\end_layout

\begin_layout Standard

\family sans
f <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
g(x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
g <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
x <- 2 
\end_layout

\begin_layout Standard

\family sans
h(x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
h <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
x <- 3 
\end_layout

\begin_layout Standard

\family sans
i(x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
i <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
x <- 4 
\end_layout

\begin_layout Standard

\family sans
sys.frames() 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
es <- f() 
\end_layout

\begin_layout Standard

\family sans
sapply(es, function(e) get("x", e, inherits = TRUE)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [1] 1 2 3 4 
\end_layout

\begin_layout Standard

\family sans
sapply(es, function(e) get("y", e, inherits = TRUE)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [1] 10 10 10 10
\end_layout

\end_deeper
\begin_layout Itemize
There are two separate strands of parents when a function is called: 
\bar under
calling environments
\bar default
 and 
\bar under
enclosing environments
\bar default
.
 Each calling environment will also have a stack of enclosing environments.
 
\end_layout

\begin_layout Itemize
Note that a called function has both a stack of called environments and
 a stack of enclosing environments.
 However, an environment (or a function object) has only a stack of enclosing
 environments.
\end_layout

\begin_layout Itemize
Looking up variables in the calling environment rather than in the defining
 argument is called 
\series bold
dynamic scoping
\series default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
Few languages implement dynamic scoping (Emacs Lisp is a notable exception).
 This is because dynamic scoping makes it much harder to reason about how
 a function operates: not only do you need to know how it was defined, you
 also need to know in what context it was called.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Dynamic scoping is primarily useful for developing functions that aid interactiv
e data analysis.
\end_layout

\end_deeper
\begin_layout Subsubsection
Explicit scoping with local
\end_layout

\begin_layout Itemize
Sometimes it's useful to be able to create a new scope without embedding
 inside a function.
 The local function allows you to do exactly that.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
df <- local({ 
\end_layout

\begin_layout Standard

\family sans
x <- 1:10 
\end_layout

\begin_layout Standard

\family sans
y <- runif(10) 
\end_layout

\begin_layout Standard

\family sans
data.frame(x = x, y = y) 
\end_layout

\begin_layout Standard

\family sans
})
\end_layout

\begin_layout Standard
is equivalent to:
\end_layout

\begin_layout Standard

\family sans
df <- (function() { 
\end_layout

\begin_layout Standard

\family sans
x <- 1:10 
\end_layout

\begin_layout Standard

\family sans
y <- runif(10) 
\end_layout

\begin_layout Standard

\family sans
data.frame(x = x, y = y) 
\end_layout

\begin_layout Standard

\family sans
})()
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
It's the immediately invoked function expression (IIFE).
 It's used extensively by most JavaScript libraries to avoid polluting the
 global namespace.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family sans
local
\family default
 has relatively limited uses (typically because most of the time scoping
 is best accomplished using R's regular function based rules) but it can
 be useful in conjunction with 
\family sans
<<-
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard
Example:
\end_layout

\begin_layout Standard

\family sans
a <- 10 
\end_layout

\begin_layout Standard

\family sans
my_get <- NULL 
\end_layout

\begin_layout Standard

\family sans
my_set <- NULL 
\end_layout

\begin_layout Standard

\family sans
local({ 
\end_layout

\begin_layout Standard

\family sans
a <- 1 
\end_layout

\begin_layout Standard

\family sans
my_get <<- function() { 
\end_layout

\begin_layout Standard

\family sans
a } 
\end_layout

\begin_layout Standard

\family sans
my_set <<- function(value) { 
\end_layout

\begin_layout Standard

\family sans
a <<- value 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
my_get() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\emph default
 
\end_layout

\begin_layout Standard

\family sans
my_set(20) 
\end_layout

\begin_layout Standard

\family sans
a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10
\emph default
 
\end_layout

\begin_layout Standard

\family sans
my_get() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 20
\end_layout

\end_deeper
\begin_layout Itemize
However, it can be easier to see what's going on if you avoid the implicit
 environment and create and access it explicitly:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
my_env <- new.env(parent = emptyenv()) 
\end_layout

\begin_layout Standard

\family sans
my_env$a <- 1 
\end_layout

\begin_layout Standard

\family sans
my_get <- function() { 
\end_layout

\begin_layout Standard

\family sans
my_env$a 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
my_set <- function(value) { 
\end_layout

\begin_layout Standard

\family sans
my_env$a <- value 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Subsubsection
Assignment: binding names to values
\end_layout

\begin_layout Itemize

\series bold
Definition: 
\series default
Assignment is the act of binding (or rebinding) a name to a value in an
 environment.
\end_layout

\begin_deeper
\begin_layout Itemize
It is the counterpart to scoping, the set of rules that determines how to
 find the value associated with a name.
\end_layout

\begin_layout Itemize
In R you can not only bind values to names, but you can also bind expressions
 (promises) or even functions, so that every time you access the value associate
d with a name, you get something different!
\end_layout

\end_deeper
\begin_layout Itemize
Four main ways of binding names to values in R:
\end_layout

\begin_deeper
\begin_layout Enumerate
With the regular behaviour, 
\family sans
name <- value
\family default
, the name is immediately associated with the value in the current environment.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
assign("name", value)
\family default
 works similarly, but allows assignment in any environment.
\end_layout

\end_deeper
\begin_layout Enumerate
The double arrow, 
\family sans
name <<- value
\family default
, assigns in a similar way to variable lookup, so that 
\family sans
i <<- i + 1
\family default
 modifies the binding of the original
\family sans
 i
\family default
, which is not necessarily in the current environment.
\end_layout

\begin_layout Enumerate
Lazy assignment, 
\family sans
delayedAssign("name", expression)
\family default
, binds an expression that isn't evaluated until you look up the name.
\end_layout

\begin_layout Enumerate
Active assignment, 
\family sans
makeActiveBinding("name", function, environment)
\family default
 binds the name to a function, so it is "active" and can return a different
 value each time the name is found.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Regular binding
\end_layout

\begin_deeper
\begin_layout Itemize
Regular assignment immediately creates a binding between a name and a value
 in the current environment.
\end_layout

\begin_layout Itemize
There are two types of names: 
\series bold
syntactic
\series default
 and 
\series bold
non-syntactic
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Generally, syntactic names consist of letters, digits, .
 and _, and must start with a letter or .
 not followed by a number (so .a and ._ are syntactic but .1 is not).
\begin_inset Foot
status open

\begin_layout Plain Layout
There are also a number of reserved words (e.g.
 
\family sans
TRUE, NULL, if, function
\family default
, see 
\family sans
make.names()
\family default
).
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A syntactic name can be used on the left hand side of 
\family sans
<-.
\end_layout

\begin_layout Itemize
However, a name can actually be any sequence of characters; if it's non-syntacti
c you just need to do a little more work:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
`a + b` <- 3 
\end_layout

\begin_layout Standard

\family sans
`:)` <- "smile" 
\end_layout

\begin_layout Standard

\family sans
` ` <- "spaces" 
\end_layout

\begin_layout Standard

\family sans
ls() 
\end_layout

\begin_layout Standard

\family sans
# [1] " " ":)" "a + b" 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family sans
<-
\family default
 creates a binding in the current environment.
 There are three techniques to create a binding in another environment:
\end_layout

\begin_deeper
\begin_layout Enumerate
treating an environment like a list
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
e <- new.env() 
\end_layout

\begin_layout Standard

\family sans
e$a <- 1
\end_layout

\end_deeper
\begin_layout Enumerate
use assign(), which has three important arguments: the 
\bar under
name
\bar default
, the 
\bar under
value
\bar default
, and the 
\bar under
environment
\bar default
 in which to create the binding
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
e <- new.env() 
\end_layout

\begin_layout Standard

\family sans
assign("a", 1, envir = e)
\end_layout

\end_deeper
\begin_layout Enumerate
evaluate 
\family sans
<-
\family default
 inside the environment.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
e <- new.env()
\end_layout

\begin_layout Standard

\family sans
eval(quote(a <- 1), e)
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout Standard

\family sans
evalq(a <- 1, e)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Constants: 
\series default
Variables whose values can not be changed; they can only be bound once,
 and never re-dound.
\end_layout

\begin_deeper
\begin_layout Itemize
We can simulate constants in R using 
\family sans
lockBinding
\family default
, or the infix 
\family sans
%<c-%
\family default
 found in 
\family sans
pryr
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 10 
\end_layout

\begin_layout Standard

\family sans
lockBinding(as.name("x"), globalenv()) 
\end_layout

\begin_layout Standard

\family sans
x <- 15
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: no binding for "x" 
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard

\family sans
x %<c-% 20 
\end_layout

\begin_layout Standard

\family sans
x <- 30 
\end_layout

\begin_layout Standard

\family sans
#> Error: cannot change value of locked binding for 'x'
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
lockBinding()
\family default
 is used to prevent you from modifying objects inside packages:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
assign("mean", function(x) sum(x) / length(x), env = baseenv())
\family default
 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: cannot change value of locked binding for 'mean'
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
<<-
\end_layout

\begin_deeper
\begin_layout Itemize
The regular assignment arrow, 
\series bold
<-
\series default
, always creates a variable in the current environment.
 The special assignment arrow, 
\family sans
<<-
\family default
, never creates a variable in the current environment, but instead modifies
 an existing variable 
\bar under
found by walking up the parent environments
\bar default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 0 
\end_layout

\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
g <- function() { 
\end_layout

\begin_layout Standard

\family sans
x <<- 2 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
g() 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\end_layout

\begin_layout Standard

\family sans
h <- function() { 
\end_layout

\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
x <<- 2 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
h() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\emph default
 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2
\end_layout

\end_deeper
\begin_layout Itemize
If <<- doesn't find an existing variable, it will create one in the global
 environment.
 
\bar under
This is usually undesirable
\bar default
, because global variables introduce non-obvious dependencies between functions.
\end_layout

\begin_layout Itemize
name 
\family sans
<<-
\family default
 value is equivalent to 
\family sans
assign("name", value, inherits = TRUE)
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
rebind <- function(name, value, env = parent.frame()) { 
\end_layout

\begin_layout Standard

\family sans
if (identical(env, emptyenv())) { 
\end_layout

\begin_layout Standard

\family sans
stop("Can't find ", name, call.
 = FALSE) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
if (exists(name, envir = env, inherits = FALSE)) {
\end_layout

\begin_layout Standard

\family sans
assign(name, value, envir = env) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
rebind(name, value, parent.env(env)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
rebind("a", 10) 
\end_layout

\begin_layout Standard

\family sans
a <- 5 
\end_layout

\begin_layout Standard

\family sans
rebind("a", 10) 
\end_layout

\begin_layout Standard

\family sans
a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10
\end_layout

\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
g <- function() { 
\end_layout

\begin_layout Standard

\family sans
rebind("x", 2) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
g() 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Delayed bindings
\end_layout

\begin_deeper
\begin_layout Itemize
Rather than assigning the result of an expression immediately, it creates
 and stores a promise to evaluate the expression when needed (much like
 the default lazy evaluation of arguments in R functions)
\end_layout

\begin_layout Itemize
We can create delayed bindings with the special assignment operator %<d-%,
 provided by the pryr package.
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we need to be careful with more complicated expressions because
 user-created infix functions have very high precedence.
 They're higher in precedence than every other infix operator apart from
 
\family sans
^, $, @, and ::
\family default
.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(pryr) a %<d-% 1 
\end_layout

\begin_layout Standard

\family sans
system.time(a) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0 0 0
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
%<d-%
\family default
 is a wrapper around the base 
\family sans
delayedAssign()
\family default
 function, which you may need to use directly if you need more control.
 
\family sans
delayedAssign()
\family default
 has four parameters:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
x
\family default
: a variable name given as a quoted string 
\end_layout

\begin_layout Itemize

\family sans
value
\family default
: an unquoted expression to be assigned to x 
\end_layout

\begin_layout Itemize

\family sans
eval.env
\family default
: the environment in which 
\bar under
to evaluate
\bar default
 the expression 
\end_layout

\begin_layout Itemize

\family sans
assign.env
\family default
: the environment in which 
\bar under
to create
\bar default
 the binding
\end_layout

\end_deeper
\begin_layout Itemize
One application of 
\family sans
delayedAssign
\family default
 is 
\family sans
autoload
\family default
, a function that powers 
\family sans
library()
\family default
.
 
\family sans
autoload
\family default
 makes R behave as if the code and data in a package is loaded in memory,
 but it doesn't actually do any work until you call one of the functions
 or access a dataset.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Active bindings
\end_layout

\begin_deeper
\begin_layout Itemize
You can create active bindings where the value is recomputed every time
 you access the name:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x %<a-% runif(1) 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.4428
\emph default
 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.3233
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
%<a-%
\family default
 is a wrapper for the base function 
\family sans
makeActiveBinding()
\family default
.
 You may want to use this function directly if you want more control.
 It has three arguments:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
sym
\family default
: a variable name, represented as a name object or a string 
\end_layout

\begin_layout Itemize

\family sans
fun
\family default
: a single argument function.
 Getting the value of sym calls fun with zero arguments, and setting the
 value of sym calls fun with one argument, the value.
 
\end_layout

\begin_layout Itemize

\family sans
env
\family default
: the environment in which to create the binding.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Exceptions and debugging
\end_layout

\begin_layout Subsubsection
Debugging, condition handling and defensive programming
\end_layout

\begin_layout Itemize

\series bold
Debugging
\series default
: how to fix unanticipated problems
\end_layout

\begin_layout Itemize

\series bold
Condition handling
\series default
: how functions can communicate problems and how you can take action based
 on those communications.
\begin_inset Foot
status open

\begin_layout Plain Layout
Function authors can also communicate with their users with 
\family sans
print()
\family default
 or 
\family sans
cat()
\family default
, but I think that's a bad idea because it's hard to capture and selectively
 ignore this sort of output.
 Printed output is not a condition, so you can't use any of the useful condition
 handling tools you'll learn about below.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
Fatal errors
\bar default
 are raised by 
\family sans
stop()
\family default
 and force all execution to terminate.
 Errors are used when there is no way for a function to continue.
\end_layout

\begin_layout Itemize

\bar under
Warnings
\bar default
 are generated by 
\family sans
warning()
\family default
 and are used to display potential problems, such as when some elements
 of a vectorised input are invalid, like 
\family sans
log(-1:2)
\family default
.
\end_layout

\begin_layout Itemize

\bar under
Messages
\bar default
 are generated by 
\family sans
message()
\family default
 and are used to give informative output in a way that can easily be suppressed
 by the user (
\family sans
?suppressMessages()
\family default
).
\end_layout

\begin_layout Standard
Recommended readings for condition handling in R:
\end_layout

\begin_layout Enumerate
A prototype of a condition system for R (by Robert Gentleman & Luke Tierney)
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
This describes an early version of R's condition system.
 The implementation has changed somewhat since this was written, but it
 provides a good overview of how the pieces fit together, and some motivation
 for the design.
\end_layout

\end_deeper
\begin_layout Enumerate
Beyond Exception Handling: Conditions and Restarts (by Peter Seibel) 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.h
tml
\end_layout

\end_inset

 or 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://adv-r.had.co.nz/beyond-exception-handling.html
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
This describes exception handling in Lisp, which happens to be very similar
 to R's approach.
 It provides useful motivation and more sophisticated examples.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Defensive programming
\series default
: how to avoid common problems before they occur
\end_layout

\begin_deeper
\begin_layout Itemize
The basic principle of defensive programming is to 
\emph on
"fail fast
\emph default
", to raise an error as soon as you know there's something wrong, rather
 than trying to silently struggle through.
\end_layout

\begin_layout Itemize
In R, this has three particular applications: 
\bar under
checking that inputs are correct
\bar default
, 
\bar under
avoiding non-standard evaluation
\bar default
, and 
\bar under
avoiding functions that can return different types of output
\bar default
.
\end_layout

\end_deeper
\begin_layout Subsubsection
Debugging techniques 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Finding your bug is a process of confirming the many things that you believe
 are true  until you find one which is not true.
  Norm Matloff
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are four steps:
\end_layout

\begin_layout Enumerate

\series bold
Realize that you have a bug
\end_layout

\begin_deeper
\begin_layout Standard
You can't fix a bug until you know it exists.
 This is one reason why automated test suites are important when producing
 high-quality code.
 Read more about automated testing here: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://adv-r.had.co.nz/Testing.html
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Make it repeatable
\end_layout

\begin_deeper
\begin_layout Itemize
Generally, you will start with a big block of code that you know causes
 the error and then slowly whittle it down to get to the smallest possible
 snippet that still causes the error.
\end_layout

\begin_layout Itemize

\series bold
Binary search
\series default
 is particularly useful for this.
 To do a binary search, you repeatedly remove half of the code until you
 find the bug.
 This is fast because, with each step, you reduce the amount of code to
 look through by half.
\end_layout

\begin_layout Itemize
If you're using automated testing, this is also a good time to create an
 automated test case.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Figure out where it is
\end_layout

\begin_deeper
\begin_layout Standard
It's a great idea to adopt the scientific method.
 Generate hypotheses, design experiments to test them and record your results.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Fix it and test it
\end_layout

\begin_deeper
\begin_layout Standard
It's very useful to have automated tests in place.
 Not only does this help to ensure that you've actually fixed the bug, it
 also helps to ensure you haven't introduced any new bugs in the process.
\end_layout

\begin_layout Standard
In the absence of automated tests, make sure to carefully record the correct
 output, and check against the inputs that previously failed.
\end_layout

\end_deeper
\begin_layout Subsubsection
Debugging tools
\end_layout

\begin_layout Itemize
There are three key debugging tools:
\begin_inset Foot
status open

\begin_layout Plain Layout
You shouldn't need to use these tools when writing new functions.Instead
 of trying to write one big function all at once, work interactively on
 small pieces.
 If you start small, you can quickly identify why something doesn't work.
 But if you start large, you may end up struggling to identify the source
 of the problem.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
RStudio's error inspector and 
\family sans
traceback()
\family default
 which list the sequence of calls that lead to the error.
\end_layout

\begin_layout Itemize
RStudio's "Rerun with Debug" tool and 
\family sans
options(error = browser)
\family default
 which open an interactive session where the error occurred.
\end_layout

\begin_layout Itemize
RStudio's breakpoints and 
\family sans
browser()
\family default
 which open an interactive session at an arbitrary location in the code.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Determing the sequence of calls
\end_layout

\begin_deeper
\begin_layout Itemize
The first tool is the 
\series bold
call stack
\series default
, the sequence of calls that lead up to an error.
 
\family sans
traceback()
\end_layout

\begin_layout Itemize
If you're calling code that you 
\family sans
source()
\family default
d into R, the traceback will also display the location of the function,
 in the form 
\family sans
filename.r#linenumber
\family default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
These are clickable in Rstudio, and will take you to the corresponding line
 of code in the editor.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Sometimes this is enough information to let you track down the error and
 fix it.
 However, it's usually not: it shows you where the error occurred, but not
 why.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Browsing on error
\end_layout

\begin_deeper
\begin_layout Itemize
You can use the 
\family sans
error
\family default
 option which specifies a function to run when an error occurs.
 The function most similar to Rstudio's debug is 
\family sans
browser():
\family default
 this will start an interactive console in the environment where the error
 occurred.
\end_layout

\begin_layout Itemize
Use 
\family sans
options(error = browser)
\family default
 to turn it on, re-run the previous command, then use 
\family sans
options(error = NULL)
\family default
 to return to the default error behaviour.
 We can also automate this with the following function: 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
browseOnce <- function() { 
\end_layout

\begin_layout Standard

\family sans
old <- getOption("error") 
\end_layout

\begin_layout Standard

\family sans
function() { 
\end_layout

\begin_layout Standard

\family sans
options(error = old) 
\end_layout

\begin_layout Standard

\family sans
browser() 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
options(error = browseOnce())
\end_layout

\begin_layout Standard

\family sans
f <- function() stop("!") 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Enters browser
\emph default
 
\end_layout

\begin_layout Standard

\family sans
f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Runs normally 
\end_layout

\begin_layout Standard

\family sans
f()
\end_layout

\end_deeper
\begin_layout Itemize
There are two other useful functions that you can use with the error option:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
recover
\family default
 is a step up from 
\family sans
browser
\family default
, as it allows you to enter the environment of any of the calls in the call
 stack.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is useful because often the root cause of the error is a number of
 calls back.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
dump.frames
\family default
 is an equivalent to 
\family sans
recover
\family default
 for non-interactive code.
 It creates a 
\family sans
last.dump.rda
\family default
 file in the current working directory.
 Then, in a later interactive R session, you load that file, and use 
\family sans
debugger()
\family default
 to enter an interactive debugger with the same interface as 
\family sans
recover()
\family default
.
 This allows interactive debugging of batch code.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
# In batch R process ---- 
\end_layout

\begin_layout Standard

\family sans
dump_and_quit <- function() { 
\end_layout

\begin_layout Standard

\family sans
# Save debugging info to file last.dump.rda 
\end_layout

\begin_layout Standard

\family sans
dump.frames(to.file = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Quit R with error status 
\end_layout

\begin_layout Standard

\family sans
q(status = 1) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
options(error = dump_and_quit)
\end_layout

\begin_layout Standard

\family sans
\emph on
# In a later interactive session ---- 
\end_layout

\begin_layout Standard

\family sans
load("last.dump.rda") 
\end_layout

\begin_layout Standard

\family sans
debugger()
\end_layout

\end_deeper
\begin_layout Itemize
To reset error behaviour to the default, use 
\family sans
options(error = NULL)
\family default
.
 Then errors will print a message and abort function execution.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Browsing arbitrary code
\end_layout

\begin_deeper
\begin_layout Itemize
As well as entering an interactive console on error, you can enter it at
 an arbitrary code location by using either an Rstudio breakpoint or 
\family sans
browser()
\family default
.
 
\end_layout

\begin_layout Itemize
There are two small downsides to breakpoints:
\end_layout

\begin_deeper
\begin_layout Itemize
There are few unusual situations in which breakpoints will not work: read
 breakpoint troubleshooting (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting
\end_layout

\end_inset

)for more details.
\end_layout

\begin_layout Itemize
Rstudio currently does not support conditional breakpoints, whereas you
 can always put 
\family sans
browser()
\family default
 inside an if statement.
\end_layout

\end_deeper
\begin_layout Itemize
As well as adding 
\family sans
browser()
\family default
 yourself, there are two functions that will add it to code for you:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
debug()
\family default
 inserts a browser statement in the first line of the specified function.
 
\family sans
undebug()
\family default
 will remove it, or you can use 
\family sans
debugonce()
\family default
 to browse only on the next run.
\end_layout

\begin_layout Itemize

\family sans
utils::setBreakpoint()
\family default
 works similarly, but instead of taking a function name,
\bar under
 it takes a file name and line number
\bar default
 and finds the appropriate function for you.
\end_layout

\end_deeper
\begin_layout Itemize
These two functions are both special cases of 
\family sans
trace()
\family default
, which inserts arbitrary code at any position in an existing function.
\end_layout

\begin_layout Itemize

\family sans
trace()
\family default
 is occasionally useful when you're debugging code that you don't have the
 source for.
 To remove tracing from a function, use 
\family sans
untrace()
\family default
.
\end_layout

\begin_layout Itemize
You can only perform one trace per function, but that one trace can call
 multiple functions.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
The call stack: 
\family sans
traceback()
\family default
, 
\family sans
where
\family default
 and 
\family sans
recover()
\family default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Unfortunately the call stacks printed by 
\family sans
traceback(), browser() + where
\family default
 and 
\family sans
recover()
\family default
 are not consistent.
 
\end_layout

\begin_layout Itemize
The following table shows how the call stacks from a simple nested set of
 calls are displayed by the three tools
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
traceback()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
where
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
recover()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
4: stop(
\begin_inset Quotes eld
\end_inset

Error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
where 1: stop(
\begin_inset Quotes eld
\end_inset

Error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
1: f()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
3: h(x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
where 2: h(x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
2: g(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
2: g(x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
where 3: g(x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
3: h(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
1: f()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
where 4: f()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Note that numbering is different between 
\family sans
traceback()
\family default
 and where, and 
\family sans
recover()
\family default
 displays calls in the opposite order, and omits the call to 
\family sans
stop()
\family default
.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Other types of failure
\end_layout

\begin_deeper
\begin_layout Itemize
A function may generate an unexpected warning.
\end_layout

\begin_deeper
\begin_layout Itemize
The easiest way to track down warnings is to convert them into errors with
 
\family sans
options(warn = 2)
\family default
 and use the regular debugging tools.
 
\end_layout

\begin_layout Itemize
When you do this you'll see some extra calls in the call stack, like 
\family sans
doWithOneRestart(), withOneRestart(), withRestarts()
\family default
 and 
\family sans
.signalSimpleWarning()
\family default
.
 Ignore these: they are internal functions used to turn warnings into errors.
\end_layout

\end_deeper
\begin_layout Itemize
A function may generate an unexpected message.
 
\end_layout

\begin_deeper
\begin_layout Itemize
There's no built in tool to help solve this problem, but it's possible to
 create one:
\begin_inset Foot
status open

\begin_layout Plain Layout
As with warnings, you'll need to ignore some of the calls on the tracback
 (i.e.
 the first two and the last seven).
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
message2error <- function(code) {
\end_layout

\begin_layout Standard

\family sans
withCallingHandlers(code, message = function(e) stop(e)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
f <- function() g() 
\end_layout

\begin_layout Standard

\family sans
g <- function() message("Hi!") 
\end_layout

\begin_layout Standard

\family sans
g()
\end_layout

\begin_layout Standard

\family sans
message2error(g())
\end_layout

\begin_layout Standard

\family sans
traceback()
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
A function might never return.
\end_layout

\begin_deeper
\begin_layout Standard
This is particularly hard to debug automatically, but sometimes terminating
 the function and looking at the call stack is informative.
 Otherwise, use the basic debugging strategies described above.
\end_layout

\end_deeper
\begin_layout Itemize
The worst scenario is that your code might crash R completely, leaving you
 with no way to interactively debug your code.
\end_layout

\begin_deeper
\begin_layout Itemize
This indicates a bug in underlying C code and is hard to debug.
 Sometimes an interactive debugger, like gdb, can be useful, but describing
 how to use it is beyond the scope of this book.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Condition handlng
\end_layout

\begin_layout Standard
Some errors, however, are expected, and you want to handle them automatically.
\end_layout

\begin_layout Standard
In R, expected errors crop up most frequently when you're fitting many models
 to different datasets, such as bootstrap replicates.
 
\end_layout

\begin_layout Standard
Sometimes the model might fail to fit and throw an error, but you don't
 want to stop everything; instead you want to fit as many models as possible
 and then perform diagnostics after the fact.
\end_layout

\begin_layout Standard
In R, there are three tools for handling conditions (including errors) programma
tically:
\end_layout

\begin_layout Enumerate

\series bold
Ignore errors with 
\family sans
try()
\end_layout

\begin_deeper
\begin_layout Itemize
gives you the ability to continue execution even when an error occurs.
\end_layout

\begin_layout Itemize
If you wrap the statement that creates the error in 
\family sans
try()
\family default
, the error message will be printed but execution will continue.
\end_layout

\begin_layout Itemize
You can suppress the message with 
\family sans
try(..., silent = TRUE)
\family default
.
 To pass larger blocks of code to 
\family sans
try()
\family default
, wrap them in 
\family sans
{}
\family default
:
\end_layout

\begin_layout Itemize
You can also capture the output of the 
\family sans
try()
\family default
 function.
 If successful, it will be the last result evaluated in the block (just
 like a function); if unsuccessful it will be an (invisible) object of class
 "try-error":
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
success <- try(1 + 2) 
\end_layout

\begin_layout Standard

\family sans
failure <- try("a" + "b") 
\end_layout

\begin_layout Standard

\family sans
str(success) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> num 3 
\end_layout

\begin_layout Standard

\family sans
str(failure) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Class 'try-error' atomic [1:1] Error in "a" + "b" : non-numeric argument
 to binary operator 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> ..- attr(*, "condition")=List of 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> ..
 ..$ message: chr "non-numeric argument to binary operator" 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> ..
 ..$ call : language "a" + "b" 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> ..
 ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
try()
\family default
 is particularly useful when you're applying a function to multiple elements
 in a list:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
elements <- list(1:10, c(-1, 10), c(T, F), letters) 
\end_layout

\begin_layout Standard

\family sans
results <- lapply(elements, log) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Warning: NaNs produced
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: non-numeric argument to mathematical function 
\end_layout

\begin_layout Standard

\family sans
results <- lapply(elements, function(x) try(log(x))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Warning: NaNs produced
\end_layout

\end_deeper
\begin_layout Itemize
Then you can easily find the locations of errors with 
\family sans
sapply()
\family default
, and extract the successes or look at the inputs that lead to failures.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
is.error <- function(x) inherits(x, "try-error") 
\end_layout

\begin_layout Standard

\family sans
succeeded <- !sapply(results, is.error)
\end_layout

\begin_layout Standard

\family sans
\emph on
# look at successful results str(results[succeeded]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> List of 3 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ : num [1:10] 0 0.693 1.099 1.386 1.609 ...
 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ : num [1:2] NaN 2.3 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ : num [1:2] 0 -Inf
\end_layout

\begin_layout Standard

\family sans
\emph on
# look at inputs that failed str(elements[!succeeded]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> List of 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ : chr [1:26] "a" "b" "c" "d" ...
\end_layout

\end_deeper
\begin_layout Itemize
Another useful 
\family sans
try()
\family default
 idiom is using a default value if an expression fails.
 Simply assign the default value outside the try block, and then run the
 risky code:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
default <- NULL 
\end_layout

\begin_layout Standard

\family sans
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Handle conditions with 
\family sans
tryCatch()
\end_layout

\begin_deeper
\begin_layout Itemize
lets you specify 
\series bold
handler
\series default
 functions that control what happens when a condition is signalled.
\end_layout

\begin_layout Itemize

\family sans
tryCatch()
\family default
 is a general tool for handling conditions: as well as errors you can take
 different actions for warnings, messages and 
\bar under
interrupts.
\bar default

\begin_inset Foot
status open

\begin_layout Plain Layout
They can't be generated directly by the programmer, but are raised when
 the user attempts to terminate execution by pressing Ctrl + Break, Escape,
 or Ctrl + C (depending on the platform).
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
With 
\family sans
tryCatch()
\family default
 you map conditions to handlers, named functions that are passed the condition
 as an input.
 If a condition is signalled, 
\family sans
tryCatch
\family default
 will call the first handler whose name matches one of the classes of the
 condition.
\end_layout

\begin_layout Itemize
The only useful built-in names are 
\family sans
error, warning, message, interrupt
\family default
 and the catch-all 
\family sans
condition
\family default
.
 
\end_layout

\begin_layout Itemize
A handler function can do anything, but typically it will either return
 a value or create a more informative error message:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
show_condition <- function(code) { 
\end_layout

\begin_layout Standard

\family sans
tryCatch(code, 
\end_layout

\begin_layout Standard

\family sans
error = function(c) "error", 
\end_layout

\begin_layout Standard

\family sans
warning = function(c) "warning", 
\end_layout

\begin_layout Standard

\family sans
message = function(c) "message" 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
show_condition(stop("!")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "error" show_condition(warning("?!")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "warning" show_condition(message("?")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "message"
\end_layout

\begin_layout Standard

\family sans
\emph on
# If no condition is captured, tryCatch returns the value of the input 
\end_layout

\begin_layout Standard

\family sans
show_condition(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10
\end_layout

\end_deeper
\begin_layout Itemize
You can use
\family sans
 tryCatch()
\family default
 to implement 
\family sans
try()
\family default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
Note the use of 
\family sans
conditionMessage()
\family default
 to extract the message associated with the original error.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
try2 <- function(code, silent = FALSE) { 
\end_layout

\begin_layout Standard

\family sans
tryCatch(code, error = function(c) { 
\end_layout

\begin_layout Standard

\family sans
msg <- conditionMessage(c) 
\end_layout

\begin_layout Standard

\family sans
if (!silent) message("Error: ", c) 
\end_layout

\begin_layout Standard

\family sans
invisible(structure(msg, class = "try-error")) 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
try2(1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 
\end_layout

\begin_layout Standard

\family sans
try2(stop("Hi")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: Error in doTryCatch(return(expr), name, parentenv, handler): Hi
 
\end_layout

\begin_layout Standard

\family sans
try2(stop("Hi"), silent = TRUE)
\end_layout

\end_deeper
\begin_layout Itemize
As well as returning default values when a condition is signalled, handlers
 can be used to make 
\bar under
more informative
\bar default
 error messages.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
read.csv2 <- function(file, ...) { 
\end_layout

\begin_layout Standard

\family sans
tryCatch(read.csv(file, ...), error = function(c) { 
\end_layout

\begin_layout Standard

\family sans
c$message <- paste0(c$message, " ( in ", file, ")") 
\end_layout

\begin_layout Standard

\family sans
stop(c) 
\end_layout

\begin_layout Standard

\family sans
})
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
read.csv("code/dummy.csv") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: duplicate 'row.names' are not allowed 
\end_layout

\begin_layout Standard

\family sans
read.csv2("code/dummy.csv") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: duplicate 'row.names' are not allowed ( in code/dummy.csv)
\end_layout

\end_deeper
\begin_layout Itemize
Catching interrupts can be useful if you want to take special action when
 the user tries to abort running code.
\begin_inset Foot
status open

\begin_layout Plain Layout
This can be useful for clean up (e.g.
 deleting files, closing connections).
 This is functionally equivalent to using 
\family sans
on.exit()
\family default
 but it can wrap smaller chunks of code than an entire function.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
# Don't let the user interrupt the code
\emph default
 
\end_layout

\begin_layout Standard

\family sans
i <- 1 
\end_layout

\begin_layout Standard

\family sans
while(i < 3) { 
\end_layout

\begin_layout Standard

\family sans
tryCatch({ 
\end_layout

\begin_layout Standard

\family sans
Sys.sleep(0.5) 
\end_layout

\begin_layout Standard

\family sans
message("Try to escape") 
\end_layout

\begin_layout Standard

\family sans
}, interrupt = function(x) { 
\end_layout

\begin_layout Standard

\family sans
message("Try again!") i <<- i + 1 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
tryCatch()
\family default
 has one other argument: 
\family sans
finally
\family default
, which specifies a block of code (not a function) to run regardless of
 whether of the initial expression succeeds or fails.
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
withCallingHandlers():
\end_layout

\begin_deeper
\begin_layout Itemize
is a variant of 
\family sans
tryCatch()
\family default
 that runs its handlers in a different context.
 It is rarely needed, but is useful to be aware of.
\end_layout

\begin_layout Itemize
There are two main differences between the functions:
\end_layout

\begin_deeper
\begin_layout Itemize
The return value of 
\family sans
tryCatch()
\family default
 handlers is returned by 
\family sans
tryCatch()
\family default
, where the return value of 
\family sans
withCallingHandlers()
\family default
 handlers is ignored: 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() stop("!") 
\end_layout

\begin_layout Standard

\family sans
tryCatch(f(), error = function(e) 1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\emph default
 
\end_layout

\begin_layout Standard

\family sans
withCallingHandlers(f(), error = function(e) 1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: !
\end_layout

\end_deeper
\begin_layout Itemize
The handlers in 
\family sans
withCallingHandlers()
\family default
 are called in the context of the call that generated the condition; the
 handlers in 
\family sans
tryCatch()
\family default
 are called in the context of 
\family sans
tryCatch()
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() 
\end_layout

\begin_layout Standard

\family sans
g() g <- function() 
\end_layout

\begin_layout Standard

\family sans
h() h <- function() stop("!")
\end_layout

\begin_layout Standard

\family sans
\series bold
tryCatch
\series default
(f(), error = function(e) print(sys.calls())) 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
sys.calls() is the run-time equivalent of traceback(), listing all calls
 leading to the current function.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\emph on
# [[1]] tryCatch(f(), error = function(e) print(sys.calls())) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[2]] tryCatchList(expr, classes, parentenv, handlers) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[3]] tryCatchOne(expr, names, parentenv, handlers[[1L]]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[4]] value[[3L]](cond)
\end_layout

\begin_layout Standard

\family sans
\series bold
withCallingHandlers
\series default
(f(), error = function(e) print(sys.calls())) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[1]] withCallingHandlers(f(), error = function(e) print(sys.calls()))
 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[2]] f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[3]] g() 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[4]] h() 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[5]] stop("!") 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[6]] .handleSimpleError(function (e) print(sys.calls()), "!", quote(h()))
 
\end_layout

\begin_layout Standard

\family sans
\emph on
# [[7]] h(simpleError(msg, call))
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
These subtle differences are rarely useful, except when you're trying to
 capture exactly what went wrong and pass it on to another function.
 For most purposes, you should never need to use 
\family sans
withCallingHandlers()
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Custom signal classes
\end_layout

\begin_deeper
\begin_layout Itemize
One of the challenges of error handling in R is that most functions just
 call 
\family sans
stop()
\family default
 with a string.
 
\end_layout

\begin_layout Itemize
This is error prone, not only because the text of the error might change
 over time, but also because many error messages are translated, so the
 message might be completely different to what you expect.
\end_layout

\begin_layout Itemize
Conditions are S3 classes, so you can define your own classes if you want
 to distinguish different types of error.
\end_layout

\begin_layout Itemize
Each condition signalling function, 
\family sans
stop(), warning()
\family default
 and 
\family sans
message()
\family default
 can be given either a list of strings, or a custom S3 condition object.
\end_layout

\begin_layout Itemize
Custom condition objects are not used very often, but are very useful because
 they make it possible for the user to respond to different errors in different
 ways.
 
\end_layout

\begin_layout Itemize
Custom constructor function for conditions: must contain 
\family sans
message
\family default
 and 
\family sans
call
\family default
 components, and may contain other useful components; when creating a new
 condition, it should always inherit from conditon and one of 
\family sans
error, warning
\family default
 and 
\family sans
message
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
condition <- function(subclass, message, call = sys.call(-1), ...) {
\end_layout

\begin_layout Standard

\family sans
structure( 
\end_layout

\begin_layout Standard

\family sans
class = c(subclass, "condition"), 
\end_layout

\begin_layout Standard

\family sans
list(message = message, call = call), 
\end_layout

\begin_layout Standard

\family sans
...
 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
is.condition <- function(x) inherits(x, "condition")
\end_layout

\end_deeper
\begin_layout Itemize
You can signal an arbitrary condition with 
\family sans
signalCondition()
\family default
, but nothing will happen unless you've instantiated a custom signal handler
 (with 
\family sans
tryCatch()
\family default
 or 
\family sans
withCallingHandlers()
\family default
.
\end_layout

\begin_layout Itemize
Instead, use 
\family sans
stop()
\family default
, 
\family sans
warning()
\family default
 or 
\family sans
message()
\family default
 as appropriate to trigger the usual handling.
 R won't complain if the class of your condition doesn't match the function,
 but you should avoid this in real code.
\end_layout

\begin_layout Itemize
You can then use 
\family sans
tryCatch()
\family default
 to take different actions for different types of errors.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
custom_stop <- function(subclass, message, call = sys.call(-1), ...) { 
\end_layout

\begin_layout Standard

\family sans
c <- condition(c(subclass, "error"), message, call = call, ...) 
\end_layout

\begin_layout Standard

\family sans
stop(c) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
my_log <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
if (!is.numeric(x)) 
\end_layout

\begin_layout Standard

\family sans
custom_stop("invalid_class", "my_log() needs numeric input") 
\end_layout

\begin_layout Standard

\family sans
if (any(x < 0)) 
\end_layout

\begin_layout Standard

\family sans
custom_stop("invalid_value", "my_log() needs positive inputs")
\end_layout

\begin_layout Standard

\family sans
log(x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
tryCatch( 
\end_layout

\begin_layout Standard

\family sans
my_log("a"), 
\end_layout

\begin_layout Standard

\family sans
invalid_class = function(c) "class", 
\end_layout

\begin_layout Standard

\family sans
invalid_value = function(c) "value" 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "class"
\end_layout

\end_deeper
\begin_layout Itemize
Note that when using 
\series bold
tryCatch()
\series default
 with multiple handlers and custom classes, the first handler to match any
 class in the signal's class hierarchy is called, not the best match.
 For this reason, you need to make sure to put the most specific handlers
 first:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
tryCatch(customStop("my_error", "!"), 
\end_layout

\begin_layout Standard

\family sans
error = function(c) "error", 
\end_layout

\begin_layout Standard

\family sans
my_error = function(c) "my_error" 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "error" 
\end_layout

\begin_layout Standard

\family sans
tryCatch(custom_stop("my_error", "!"), 
\end_layout

\begin_layout Standard

\family sans
my_error = function(c) "my_error", 
\end_layout

\begin_layout Standard

\family sans
error = function(c) "error" ) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "my_error"
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Defensive programming
\end_layout

\begin_layout Itemize
Defensive programming is the art of making code fail in a well-defined manner
 even when something unexpected occurs.
 
\end_layout

\begin_layout Itemize
A key principle of defensive programming is to "
\bar under
fail fast
\bar default
": as soon as you discover something is wrong, signal an error.
\end_layout

\begin_layout Itemize
The principle of "fail fast" has three main applications in R:
\end_layout

\begin_deeper
\begin_layout Itemize
Be strict about what you accept.
\begin_inset Foot
status open

\begin_layout Plain Layout
You can use 
\family sans
stopifnot()
\family default
, the 
\family sans
assertthat
\family default
 package or simple 
\family sans
if
\family default
 statements and 
\family sans
stop()
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Avoid functions that use non-standard evaluation, like 
\family sans
subset
\family default
, 
\family sans
transform
\family default
, and 
\family sans
with
\family default
.
 
\end_layout

\begin_deeper
\begin_layout Standard
These functions save time when used interactively, but because they make
 assumptions to reduce typing, when they fail, they often fail with uninformativ
e error messages.
\end_layout

\end_deeper
\begin_layout Itemize
Avoid functions that return different types of output depending on their
 input.
 
\end_layout

\begin_deeper
\begin_layout Standard
The two biggest offenders are
\family sans
 [
\family default
 and 
\family sans
sapply()
\family default
.
 Whenever subsetting a data frame in a function, you should always use 
\family sans
drop = FALSE
\family default
, otherwise you will accidentally convert 1-column data frames into vectors.
 Similarly, never use 
\family sans
sapply()
\family default
 inside a function: always use the stricter 
\family sans
vapply()
\family default
 which will throw an error if the inputs are incorrect types and return
 the correct type of output even for zero-length inputs.
\end_layout

\end_deeper
\begin_layout Itemize
There is a tension between interactive analysis and programming.
\end_layout

\begin_deeper
\begin_layout Itemize
When you're doing an analysis, you want R to do what you mean, and if it
 guesses wrong, you'll discover it right away and you can fix it.
 
\end_layout

\begin_layout Itemize
When you're programming, you want functions with no magic that signal errors
 is anything is slightly wrong or underspecified.
 
\end_layout

\begin_layout Itemize
Keep this tension in mind when writing functions: If you're making a function
 to facilitate interactive data analysis, feel free to guess what the analyst
 wants and recover from minor misspecifications automatically; if you're
 making a function to program with, be strict, and never make guesses about
 what the caller wants.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Functional Programming
\end_layout

\begin_layout Subsection
Functional programming
\end_layout

\begin_layout Itemize
At its heart, R is a 
\series bold
functional programming
\series default
 (FP) language; it focusses on the creation and manipulation of functions.
\end_layout

\begin_layout Itemize
R has what's known as first class functions, functions that can be
\begin_inset Foot
status open

\begin_layout Plain Layout
This means that you can do anything with functions that you can do with
 vectors: you can create them inside other functions, pass them as arguments
 to functions, return them as results from functions and store multiple
 functions in a list.
 
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
created without a name, 
\end_layout

\begin_layout Itemize
assigned to variables and stored in lists, 
\end_layout

\begin_layout Itemize
returned from functions, 
\end_layout

\begin_layout Itemize
and passed as arguments to other functions.
\end_layout

\end_deeper
\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Itemize
Repetition is bad because it allows for inconsistencies (aka bugs), and
 it makes the code harder to change.
\end_layout

\begin_layout Itemize
The "
\bar under
do not repeat yourself
\bar default
", or DRY, principle, was popularised by the pragmatic programmers, Dave
 Thomas and Andy Hunt.
 This principle states that "every piece of knowledge must have a single,
 unambiguous, authoritative representation within a system".
\end_layout

\begin_layout Itemize
The ideas of FP are important because they give us new tools to reduce duplicati
on.
\end_layout

\begin_layout Itemize

\family sans
lapply()
\family default
 is called a functional, because it takes a function as an argument.
 We can use 
\family sans
lapply()
\family default
 with one small trick: rather than simply assigning the results to 
\family sans
df
\family default
 we assign them to 
\family sans
df[]
\family default
, so R's usual subsetting rules take over and we get a data frame instead
 of a list.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
fix_missing <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
x[x == -99] <- NA 
\end_layout

\begin_layout Standard

\family sans
x } 
\end_layout

\begin_layout Standard

\family sans
df[] <- lapply(df, fix_missing)
\end_layout

\end_deeper
\begin_layout Itemize
Writing simple functions that can be understood in isolation and then composed
 together to solve complex problems is an important technique for effective
 FP.
\end_layout

\begin_layout Itemize
Take advantage of another functional programming technique,
\bar under
 storing functions in lists
\bar default
, to remove this duplication:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
summary <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
funs <- c(mean, median, sd, mad, IQR) 
\end_layout

\begin_layout Standard

\family sans
lapply(funs, function(f) f(x, na.rm = TRUE)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Subsubsection
Anonymous functions
\end_layout

\begin_layout Itemize
In R, functions are objects in their own right.
 They aren't automatically bound to a name and R doesn't have a special
 syntax for creating named functions, unlike C, C++, Python or Ruby.
 
\end_layout

\begin_layout Itemize
Given the name of a function, like "
\family sans
mean
\family default
", it's possible to find the function using 
\family sans
match.fun()
\family default
.
 You can't do the opposite: given the object 
\family sans
f <- mean
\family default
, there's no way to find its name.
 
\end_layout

\begin_layout Itemize
Not all functions have a name, and some functions have more than one name.
 Functions that don't have a name are called 
\series bold
anonymous functions
\series default
.
\end_layout

\begin_layout Itemize
Like all functions in R, anoynmous functions have 
\family sans
formals(), a body()
\family default
, and a parent 
\family sans
environment()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
formals(function(x = 4) g(x) + h(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4 
\end_layout

\begin_layout Standard

\family sans
body(function(x = 4) g(x) + h(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> g(x) + h(x) 
\end_layout

\begin_layout Standard

\family sans
environment(function(x = 4) g(x) + h(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1ab1220>
\end_layout

\end_deeper
\begin_layout Itemize
You can call anonymous functions directly, but the code is a little tricky
 to read because you must use parentheses in two different ways: first,
 to call a function, and second to make it clear that you want to call the
 anonymous function 
\family sans
function(x) 3
\family default
, as opposed to calling a function named '3' (which isn't a valid function
 name) inside the anonymous function:
\begin_inset Foot
status open

\begin_layout Plain Layout
You can supply arguments to anonymous functions in all the usual ways (by
 position, exact name and partial name) but if you find yourself doing this,
 it's probably a sign that your function needs a name.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
(function(x) x + 3)(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 13
\end_layout

\begin_layout Standard

\family sans
\emph on
# Exactly the same as 
\end_layout

\begin_layout Standard

\family sans
f <- function(x) x + 3 f(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 13
\end_layout

\begin_layout Standard

\family sans
\emph on
# Doesn't do what you expect 
\end_layout

\begin_layout Standard

\family sans
function(x) 3() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function(x) 3() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1ab1220>
\end_layout

\end_deeper
\begin_layout Itemize
One of the most common uses for anonymous functions is to create closures,
 functions made by other functions.
\end_layout

\begin_layout Itemize
A good rule of thumb is that an anonymous function should fit on one line
 and shouldn't need to use 
\family sans
{}
\family default
.
 
\end_layout

\begin_layout Subsubsection
Introduction to closures
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
"An object is data with functions.
 A closure is a function with data." --- John D Cook
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
One use of anonymous functions is to create small functions that it's not
 worth naming; the other main use of anonymous functions is to create closures,
 functions written by functions.
\end_layout

\begin_layout Itemize
Closures are so called because they 
\series bold
enclose
\series default
 the environment of the parent function, and can access all variables in
 the parent.
\end_layout

\begin_layout Itemize
This is useful because it allows us to have two levels of parameters.
 One level of parameters (the parent) controls how the function works; the
 other level (the child) does the work.
\end_layout

\begin_layout Itemize
In R, almost every function is a closure, because all functions remember
 the environment in which they are created, typically either the global
 environment, if it's a function that you've written, or a package environment,
 if it's a function that someone else has written.
\end_layout

\begin_layout Itemize
The only exception are primitive functions, which call to C directly.
\end_layout

\begin_layout Itemize
One way to see the contents of the environment is to convert it to a list:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
power <- function(exponent) { function(x) x ^ exponent }
\end_layout

\begin_layout Standard

\family sans
square <- power(2)
\end_layout

\begin_layout Standard

\family sans
as.list(environment(square))
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $exponent 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2
\end_layout

\end_deeper
\begin_layout Itemize
Another way to see what's going on is to use 
\family sans
pryr::unenclose()
\family default
, which substitutes the variables defined in the enclosing environment into
 the original functon:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(pryr) 
\end_layout

\begin_layout Standard

\family sans
unenclose(square) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x^2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1ab1220>
\end_layout

\end_deeper
\begin_layout Itemize
Note that the parent environment of the closure is the environment created
 when the parent function is 
\series bold
called.
\end_layout

\begin_layout Itemize
This environment normally disappears once the function finishes executing,
 but because we return a function, the environment is captured and attached
 to the new function.
\end_layout

\begin_layout Itemize
Each time we re-run 
\family sans
power()
\family default
 a new environment is created, so each function produced by power is independent.
\end_layout

\begin_layout Itemize

\series bold
Function factories
\end_layout

\begin_deeper
\begin_layout Itemize
Function factories are most useful when:
\end_layout

\begin_deeper
\begin_layout Itemize
the different levels are more complex, with multiple arguments and complicated
 bodies
\end_layout

\begin_layout Itemize
some work only needs to be done once, when the function is generated
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Mutable state
\end_layout

\begin_deeper
\begin_layout Itemize
Having variables at two levels makes it possible to maintain state across
 function invocations, because while the function environment is refreshed
 every time, its parent environment stays constant.
\end_layout

\begin_layout Itemize
The key to managing variables at different levels is the double arrow assignment
 operator (
\family sans
<<-
\family default
).
 
\end_layout

\begin_layout Itemize
Unlike the usual single arrow assignment (<-) that always assigns in the
 current environment, the double arrow operator will 
\bar under
keep looking up the chain of parent environments until it finds a matching
 name
\bar default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Together, a static parent environment and <<- make it possible to maintain
 state across function calls.
 
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
<- will not modify the value in the parent environment (only the current
 environment, the one created when calling the function), while <<- will
 do.
 
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
new_counter <- function() { 
\end_layout

\begin_layout Standard

\family sans
i <- 0 
\end_layout

\begin_layout Standard

\family sans
function() { 
\end_layout

\begin_layout Standard

\family sans
i <<- i + 1 
\end_layout

\begin_layout Standard

\family sans
i } 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard
The new function is a closure, and its enclosing environment is the usually
 temporary environment created when new_counter is run.
 When the closures counter_one and counter_two are run, each one modifies
 the counter in a different enclosing environment and so maintain different
 counts.
\end_layout

\begin_layout Standard

\family sans
counter_one <- new_counter() 
\end_layout

\begin_layout Standard

\family sans
counter_two <- new_counter()
\end_layout

\begin_layout Standard

\family sans
counter_one() 
\emph on
# -> [1] 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\end_layout

\begin_layout Standard

\family sans
counter_one() 
\emph on
# -> [1] 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 
\end_layout

\begin_layout Standard

\family sans
counter_two() 
\emph on
# -> [1] 1
\emph default
 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The counters get around the "fresh start" limitation by not modifying variables
 in their local environment.
 Since the changes are made in the unchanging parent (or enclosing) environment,
 they are preserved across function calls.
\end_layout

\begin_layout Itemize
Modifying values in a parent environment is an important technique because
 it is one way to generate "mutable state" in R.
\end_layout

\begin_layout Itemize
Mutable state is normally hard to achieve, because every time it looks like
 you're modifying an object, 
\bar under
you're actually creating a copy and modifying that
\bar default
.
 
\end_layout

\begin_layout Itemize
That said, if you do need mutable objects, except in the simplest of cases,
 it's usually better to use the RC OO system.
 RC objects are easier to document, and provide easier ways to inherit behaviour.
\end_layout

\begin_layout Subsubsection
Lists of functions
\end_layout

\begin_layout Itemize
In R, functions can be stored in lists.
 Instead of giving a set of functions related names, you can store them
 in a list.
 
\end_layout

\begin_layout Itemize
This makes it easier to work with groups of related functions, in the same
 way a data frame makes it easier to work with groups of related vectors.
\end_layout

\begin_layout Itemize
If we want to call each functions to check that we've implemented them correctly
 and they return the same answer, we can use 
\family sans
lapply()
\family default
, either with an anonymous function, or an equivalent named function.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply(compute_mean, function(f, ...) f(...), x)
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard

\family sans
call_fun <- function(f, ...) f(...) 
\end_layout

\begin_layout Standard

\family sans
lapply(compute_mean, call_fun, x)
\end_layout

\end_deeper
\begin_layout Itemize
If we would like to remove the missings we can do:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply(funs, function(f) f(x, na.rm = TRUE))
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard

\family sans
\emph on
# Or use a named function instead of an anonymous function 
\end_layout

\begin_layout Standard

\family sans
remove_missings <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
function(...) f(..., na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
funs2 <- lapply(funs, remove_missings)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Moving lists of functions to the global environment
\end_layout

\begin_deeper
\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
simple_tag <- function(tag) { 
\end_layout

\begin_layout Standard

\family sans
function(...) paste0("<", tag, ">", paste0(...), "</", tag, ">") 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
html <- list( 
\end_layout

\begin_layout Standard

\family sans
p = simple_tag("p"), 
\end_layout

\begin_layout Standard

\family sans
b = simple_tag("b"), 
\end_layout

\begin_layout Standard

\family sans
i = simple_tag("i"), 
\end_layout

\begin_layout Standard

\family sans
img = function(path, width, height) { 
\end_layout

\begin_layout Standard

\family sans
paste0("<img src='", path, "' width='", width, "' height = '", height, '"
 />') 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
)
\end_layout

\end_deeper
\begin_layout Itemize
We store the functions in a list because we don't want them to be available
 all the time: the risk of a conflict between an existing R function and
 an HTML tag is high.
 However, keeping them in a list means that our code is more verbose than
 necessary: we need to use $ every time if we would like to use the function
 under the list.
\end_layout

\begin_layout Itemize
We have three options ot eliminate the use of 
\family sans
html$:
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
The author recommends the first option because it makes it very clear what's
 going on, and when code is being executed in a special context.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
For a very temporary effect, we can use a 
\series bold
with()
\series default
 block:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
with(html, p("This is ", b("bold"), ", ", i("italic"), " and ", b(i("bold
 italic")), " text"))
\end_layout

\end_deeper
\begin_layout Enumerate
For a longer effect, we can use 
\family sans
attach()
\family default
 to add the functions in html in to the search path.
 It's posible to undo this action using 
\family sans
detach
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
attach(html) 
\end_layout

\begin_layout Standard

\family sans
p("This is ", b("bold"), ", ", i("italic"), " and ", b(i("bold italic")),
 " text") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "<p>This is <b>bold</b>, <i>italic</i> and <b><i>bold italic</i></b>
 text</p>" 
\end_layout

\begin_layout Standard

\family sans
detach(html)
\end_layout

\end_deeper
\begin_layout Enumerate
Finally, we could copy the functions into the global environment with 
\family sans
list2env()
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\series bold
list2env(html, environment()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1ab1220> 
\end_layout

\begin_layout Standard

\family sans
p("This is ", b("bold"), ", ", i("italic"), " and ", b(i("bold italic")),
 " text") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "<p>This is <b>bold</b>, <i>italic</i> and <b><i>bold italic</i></b>
 text</p>" 
\end_layout

\begin_layout Standard

\family sans
rm(list = names(html), envir = environment())
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsubsection
Case study: numerical integration
\end_layout

\begin_layout Itemize
The idea behind numerical integration is simple: we want to find the area
 under the curve by approximating a complex curve with simpler components.
\end_layout

\begin_layout Itemize
The two simpliest approaches are the 
\bar under
midpoint
\bar default
 and 
\bar under
trapezoid
\bar default
 rules; the mid point rule approximates a curve by a rectangle, and the
 trapezoid rule by a trapezoid.
\end_layout

\begin_layout Itemize
break up the range into smaller pieces and integrate each piece using one
 of the simple rules.
 This is called 
\series bold
composite integration.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
midpoint_composite <- function(f, a, b, n = 10) { 
\end_layout

\begin_layout Standard

\family sans
points <- seq(a, b, length = n + 1) 
\end_layout

\begin_layout Standard

\family sans
h <- (b - a) / n 
\end_layout

\begin_layout Standard

\family sans
area <- 0
\end_layout

\begin_layout Standard

\family sans
for (i in seq_len(n)) { 
\end_layout

\begin_layout Standard

\family sans
area <- area + h * f((points[i] + points[i + 1]) / 2) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
area 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
trapezoid_composite <- function(f, a, b, n = 10) { 
\end_layout

\begin_layout Standard

\family sans
points <- seq(a, b, length = n + 1) 
\end_layout

\begin_layout Standard

\family sans
h <- (b - a) / n 
\end_layout

\begin_layout Standard

\family sans
area <- 0 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_len(n)) { 
\end_layout

\begin_layout Standard

\family sans
area <- area + h / 2 * (f(points[i]) + f(points[i + 1])) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
area 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
composite <- function(f, a, b, n = 10, rule) { 
\end_layout

\begin_layout Standard

\family sans
points <- seq(a, b, length = n + 1) 
\end_layout

\begin_layout Standard

\family sans
area <- 0 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_len(n)) { 
\end_layout

\begin_layout Standard

\family sans
area <- area + rule(f, points[i], points[i + 1]) } 
\end_layout

\begin_layout Standard

\family sans
area 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
composite(sin, 0, pi, n = 10, rule = midpoint)
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2.008
\end_layout

\begin_layout Standard

\family sans
composite(sin, 0, pi, n = 10, rule = trapezoid)
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1.984
\end_layout

\end_deeper
\begin_layout Itemize
It turns out that the midpoint, trapezoid, Simpson and Boole rules are all
 examples of a more general family called 
\series bold
\bar under
Newton-Cotes
\series default
\bar default
 rules.
 (They are polynomials of increasing complexity).
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
# From http://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas 
\end_layout

\begin_layout Standard

\family sans
newton_cotes <- function(coef, open = FALSE) { 
\end_layout

\begin_layout Standard

\family sans
n <- length(coef) + open 
\end_layout

\begin_layout Standard

\family sans
function(f, a, b) { 
\end_layout

\begin_layout Standard

\family sans
pos <- function(i) a + i * (b - a) / n 
\end_layout

\begin_layout Standard

\family sans
points <- pos(seq.int(0, length(coef) - 1)) 
\end_layout

\begin_layout Standard

\family sans
(b - a) / sum(coef) * sum(f(points) * coef) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
rules <- list( 
\end_layout

\begin_layout Standard

\family sans
trapezoid = newton_cotes(c(1, 1)), 
\end_layout

\begin_layout Standard

\family sans
midpoint = newton_cotes(1, open = TRUE), 
\end_layout

\begin_layout Standard

\family sans
simpson = newton_cotes(c(1, 4, 1)), 
\end_layout

\begin_layout Standard

\family sans
boole = newton_cotes(c(7, 32, 12, 32, 7)), 
\end_layout

\begin_layout Standard

\family sans
milne = newton_cotes(c(2, -1, 2), open = TRUE) 
\end_layout

\begin_layout Standard

\family sans
)
\end_layout

\end_deeper
\begin_layout Itemize
Mathematically, the next step in improving numerical integration is to move
 from a grid of evenly spaced points to a grid where the points are closer
 together near the end of the range, such as 
\series bold
Gaussian quadrature
\series default
.
 
\end_layout

\begin_layout Subsection
Functionals
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
"To become significantly more reliable, code must become more transparent.
 In particular, nested conditions and loops must be viewed with great suspicion.
 Complicated control flows confuse programmers.
 Messy code often hides bugs." --- Bjarne Stroustrup
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Itemize
Higher-order functions encompass any functions that either take a function
 as an input or return a function as output.
\end_layout

\begin_layout Itemize
The complement to a closure is a 
\series bold
functional
\series default
, a function that takes a function as an input and returns a vector as output.
\end_layout

\begin_layout Itemize
Since functions are first class objects in R, there's no difference between
 calling a function with a vector or function as input.
\end_layout

\begin_layout Itemize
Many functionals (like 
\family sans
lapply()
\family default
) offer alternatives to for loops.
 For loops have a bad rap in R, and some programmers try to eliminate them
 at all costs.
 
\end_layout

\begin_layout Itemize
The real downside of for loops is that they're not very 
\bar under
expressive
\bar default
.
 A for loop conveys that you're iterating over something, but it doesn't
 communicate the 
\bar under
higher-level task
\bar default
 you're trying to complete.
\end_layout

\begin_layout Itemize
Functionals are not as general as for loops, but by being more specific
 they allow you to communicate more clearly.
 A functional allows you to say I want to transform each element of this
 list, or each row of this array.
\end_layout

\begin_layout Itemize
As well as more clearly communicating intent, functionals reduce the chances
 of bugs, and can be more efficient.
\end_layout

\begin_layout Itemize
As well as replacements for for loops, functionals do play other roles.
 They are also useful tools for encapsulating common data manipulation tasks,
 the split-apply-combine pattern; for thinking "functionally"; and for working
 with mathematical functions.
\end_layout

\begin_layout Itemize
This will not always produce the fastest code, but it is a mistake to focus
 on speed until you know it will be a problem.
 Once you do have clear, correct code you can make it fast using the techniques
 in performance.
\end_layout

\begin_layout Subsubsection
My first functional: 
\family sans
lapply()
\end_layout

\begin_layout Itemize

\family sans
lapply()
\family default
 is written in C for performance, but we can create a simple R implementation
 that works the same way
\begin_inset Foot
status open

\begin_layout Plain Layout
From this code you can see that 
\family sans
lapply()
\family default
 will also works with vectors: both 
\family sans
length()
\family default
 and '
\family sans
[[
\family default
 work the same way for lists and vectors.
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply2 <- function(x, f, ...) { 
\end_layout

\begin_layout Standard

\family sans
out <- vector("list", length(x)) 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_along(x)) { 
\end_layout

\begin_layout Standard

\family sans
out[[i]] <- f(x[[i]], ...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
From this code, you can see that 
\family sans
lapply()
\family default
 is a wrapper around a common for loop pattern: we create a space for output,
 and then fill it in, applying 
\family sans
f()
\family default
 to each component of the list.
\end_layout

\begin_layout Itemize
All other for loop functionals build on this base, modifying either the
 input, the output, or what data the function is applied to.
 
\end_layout

\begin_layout Itemize
Since data frames are also lists, 
\family sans
lapply()
\family default
 is useful when you want to do something to each column of a data frame.
\end_layout

\begin_layout Itemize
The pieces of x are always supplied as the first argument to f.
 You can override this using R's regular function calling semantics, supplying
 additional named arguments.
 So to use 
\family sans
lapply()
\family default
 with the second argument, we just need to name the first argument:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
trims <- c(0, 0.1, 0.2, 0.5) 
\end_layout

\begin_layout Standard

\family sans
x <- rcauchy(100) 
\end_layout

\begin_layout Standard

\family sans
unlist(lapply(trims, mean, x = x))
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 12.16175 -0.09112 -0.08860 0.01817
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Looping patterns
\end_layout

\begin_deeper
\begin_layout Itemize
When using 
\family sans
lapply()
\family default
 and friends, it's useful to remember that there are usually three ways
 to loop over an vector:
\end_layout

\begin_deeper
\begin_layout Enumerate
loop over the elements of the vector: 
\family sans
for(x in xs)
\family default
 
\end_layout

\begin_layout Enumerate
loop over the numeric indices of the vector: 
\family sans
for(i in seq_along(xs))
\family default
 
\end_layout

\begin_layout Enumerate
loop over the names of the vector: 
\family sans
for(nm in names(xs))
\end_layout

\end_deeper
\begin_layout Itemize
If you're saving the results from a for loop, you usually can't use the
 first form because it makes very inefficient code.
 When extending an existing data structure, all the existing data must be
 copied every time you extend it.
\end_layout

\begin_layout Itemize
It's much better to create enough space for the output and then fill it
 in, using the second looping form.
\end_layout

\begin_layout Itemize
Corresponding to the three ways to use a for loop there are three ways to
 use 
\family sans
lapply()
\family default
 with an object:
\begin_inset Foot
status open

\begin_layout Plain Layout
Typically you use the first form because 
\family sans
lapply()
\family default
 takes care of saving the output for you.
 However, if you need to know the position or the name of the element you're
 working with, you'll need to use the second or third form; they give you
 both the position of the object (i, nm) and its value (
\family sans
xs[[i]], xs[[nm]]
\family default
).
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply(xs, function(x) {}) 
\end_layout

\begin_layout Standard

\family sans
lapply(seq_along(xs), function(i) {}) 
\end_layout

\begin_layout Standard

\family sans
lapply(names(xs), function(nm) {})
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
For loop functional: friends of
\family sans
 lapply()
\end_layout

\begin_layout Itemize
The art of using functionals is to recognise what common looping patterns
 are implemented in existing base functionals, and then use them instead
 of loops.
\end_layout

\begin_layout Itemize
if you discover you're duplicating the same looping pattern in many places,
 you should extract it out into its own function.
\end_layout

\begin_layout Itemize

\series bold
Vector output: 
\family sans
sapply
\family default
 and 
\family sans
vapply
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
sapply()
\family default
 and 
\family sans
vapply()
\family default
 are very similar to 
\family sans
lapply()
\family default
 except they will simplify their output to produce an atomic vector.
\end_layout

\begin_layout Itemize

\family sans
sapply()
\family default
 guesses, while 
\family sans
vapply()
\family default
 takes an additional argument specifying the output type.
\end_layout

\begin_layout Itemize

\family sans
sapply()
\family default
 is useful for interactive use because it saves typing, but if you use it
 inside your functions you will get weird errors if you supply the wrong
 type of input.
\end_layout

\begin_layout Itemize

\family sans
vapply()
\family default
 is more verbose, but gives more informative error messages and never fails
 silently, 
\bar under
so is better suited for use inside other functions
\bar default
.
\end_layout

\begin_layout Itemize
When given a data frame 
\family sans
sapply()
\family default
 and 
\family sans
vapply()
\family default
 give the same results.
 
\end_layout

\begin_layout Itemize
When given an empty list, 
\family sans
sapply()
\family default
 has no basis to guess the correct type of output, and returns 
\family sans
NULL
\family default
, instead of the more correct zero-length logical vector.
\end_layout

\begin_layout Itemize
If the function returns results of different types or lengths, 
\family sans
sapply()
\family default
 will silently return a list, while 
\family sans
vapply()
\family default
 will throw an error.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
sapply()
\family default
 is fine for interactive use because you'll normally notice if something
 went wrong, but it's dangerous when writing functions.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
sapply()
\family default
 is a thin wrapper around 
\family sans
lapply()
\family default
, transforming a list into a vector in the final step; 
\family sans
vapply()
\family default
 reimplements 
\family sans
lapply()
\family default
 but assigns results into a vector (or matrix) of the appropriate type instead
 of into a list.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Multiple inputs: 
\family sans
Map
\family default
 (and 
\family sans
mapply
\family default
)
\end_layout

\begin_deeper
\begin_layout Itemize
With 
\family sans
lapply()
\family default
, only one argument to the function varies; the others are fixed.
 This makes it poorly suited for some problems.
\end_layout

\begin_layout Itemize

\family sans
Map
\family default
, a variant of 
\family sans
lapply()
\family default
, where all arguments vary:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
unlist(Map(weighted.mean, xs, ws)) 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
Note that the order of arguments is a little different: with Map() the function
 is the first argument, with lapply() it's the second.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.6704 0.6874 0.5362 0.5220 0.6120 0.4238 0.3535 0.4999 0.5025 0.4427
\end_layout

\end_deeper
\begin_layout Itemize
This is equivalent to 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
stopifnot(length(x) == length(w)) 
\end_layout

\begin_layout Standard

\family sans
out <- vector("list", length(x)) 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_along(x)) { 
\end_layout

\begin_layout Standard

\family sans
out[[i]] <- weighted.mean(x[[i]], w[[i]]) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
There's a natural equivalence between 
\family sans
Map()
\family default
 and 
\family sans
lapply()
\family default
 because you can always convert a 
\family sans
Map()
\family default
 to an 
\family sans
lapply()
\family default
 that iterates over indices, but using 
\family sans
Map()
\family default
 is more concise, and more clearly indicates what you're trying to do.
\end_layout

\begin_layout Itemize

\family sans
Map
\family default
 is useful whenever you have two (or more) lists (or data frames) that you
 need to process in parallel.
\end_layout

\begin_layout Itemize
If some of the arguments should be fixed, and not varying, you need to use
 an anonymous function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws)
\end_layout

\end_deeper
\begin_layout Itemize
Compared to 
\family sans
mapply():
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
Map()
\family default
 is equivalent to mapply with 
\family sans
simplify = FALSE
\family default
, which is almost always what you want.
\end_layout

\begin_layout Itemize
Instead of using an anonymous function to provide constant inputs, 
\family sans
mapply
\family default
 has the 
\family sans
MoreArgs
\family default
 argument which takes a list of extra arguments that will be supplied, as
 is, to each call.
 This breaks R's usual lazy evaluation semantics, and is inconsistent with
 other functions.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Rolling computations
\end_layout

\begin_deeper
\begin_layout Itemize
You can often create your own by recognising common looping structures and
 implementing your own wrapper.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
rollmean <- function(x, n) { 
\end_layout

\begin_layout Standard

\family sans
out <- rep(NA, length(x))
\end_layout

\begin_layout Standard

\family sans
offset <- trunc(n / 2) 
\end_layout

\begin_layout Standard

\family sans
for (i in (offset + 1):(length(x) - n + offset - 1)) { 
\end_layout

\begin_layout Standard

\family sans
out[i] <- mean(x[(i - offset):(i + offset - 1)]) } 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- seq(1, 3, length = 1e2) + runif(1e2) plot(x)
\end_layout

\begin_layout Standard

\family sans
lines(rollmean(x, 5), col = "blue", lwd = 2) 
\end_layout

\begin_layout Standard

\family sans
lines(rollmean(x, 10), col = "red", lwd = 2)
\end_layout

\end_deeper
\begin_layout Itemize
But if the noise was more variable (i.e.
 it had a longer tail) you might worry that your rolling mean was too sensitive
 to the occasional outlier and instead implement a rolling median.
\end_layout

\begin_layout Itemize
To modify 
\family sans
rollmean()
\family default
 to 
\family sans
rollmedian()
\family default
 all you need to do is replace mean with median inside the loop, but instead
 of copying and pasting to create a new function, we could extract the idea
 of computing a rolling summary into its own function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
rollapply <- function(x, n, f, ...) { 
\end_layout

\begin_layout Standard

\family sans
out <- rep(NA, length(x))
\end_layout

\begin_layout Standard

\family sans
offset <- trunc(n / 2) 
\end_layout

\begin_layout Standard

\family sans
for (i in (offset + 1):(length(x) - n + offset - 1)) { 
\end_layout

\begin_layout Standard

\family sans
out[i] <- f(x[(i - offset):(i + offset - 1)], ...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
plot(x) 
\end_layout

\begin_layout Standard

\family sans
lines(rollapply(x, 5, median), col = "red", lwd = 2)
\end_layout

\end_deeper
\begin_layout Itemize
The internal loop looks pretty similar to a vapply() loop, so we could rewrite
 the function as:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
rollapply <- function(x, n, f, ...) { 
\end_layout

\begin_layout Standard

\family sans
offset <- trunc(n / 2) 
\end_layout

\begin_layout Standard

\family sans
locs <- (offset + 1):(length(x) - n + offset - 1) 
\end_layout

\begin_layout Standard

\family sans
vapply(locs, function(i) f(x[(i - offset):(i + offset - 1)], ...), numeric(1))
 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Parallelisation
\end_layout

\begin_deeper
\begin_layout Itemize
One thing that's interesting about the defintions of 
\family sans
lapply()
\family default
 is that because each iteration is isolated from all others, the order in
 which they are computed doesn't matter.
 
\end_layout

\begin_layout Itemize
This has a very important consequence: since we can compute each element
 in any order, it's easy to dispatch the tasks to different cores, and compute
 in parallel.
 This is what 
\family sans
mclapply()
\family default
 (and 
\family sans
mcMap
\family default
) in the parallel package do:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(parallel) 
\end_layout

\begin_layout Standard

\family sans
unlist(mclapply(1:10, sqrt, mc.cores = 4)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1.000 1.414 1.732 2.000 2.236 2.449 2.646 2.828 3.000 3.162
\end_layout

\end_deeper
\begin_layout Itemize
In this case 
\family sans
mclapply()
\family default
 is actually slower than 
\family sans
lapply()
\family default
, because the cost of the individual computations is low, and some additional
 work is needed to send the computation to the different cores then collect
 the results together.
 
\end_layout

\begin_layout Itemize
In a more realistic example, we see more of an advantage:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
boot_lm <- function(i, data, formula) { 
\end_layout

\begin_layout Standard

\family sans
boot_df <- function(data) data[sample(nrow(data), rep = T), ] 
\end_layout

\begin_layout Standard

\family sans
rsquared <- function(mod) summary(mod)$r.square 
\end_layout

\begin_layout Standard

\family sans
rsquared(lm(formula, data = boot_df(data))) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
system.time(lapply(1:500, boot_lm,formula='mpg ~ wt + disp',data=mtcars))
 
\end_layout

\begin_layout Standard

\family sans
\emph on
# user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
# 1.701 0.110 1.798 
\end_layout

\begin_layout Standard

\family sans
system.time(mclapply(1:5,boot_lm,mc.cores=2,formula='mpg ~ wt + disp',data=mtcars)
) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
# 0.038 0.070 0.051 
\end_layout

\end_deeper
\begin_layout Itemize
It is rare to get an exactly linear improvement with increasing number of
 cores, but if your code uses 
\family sans
lapply()
\family default
 or 
\family sans
Map()
\family default
, this is an easy way to improve performance.
\end_layout

\end_deeper
\begin_layout Subsubsection
Data structure functionals
\end_layout

\begin_layout Itemize
another family of functionals works to eliminate loops for common data manipulat
ion tasks.
\end_layout

\begin_deeper
\begin_layout Itemize
base functions for working with matrices: 
\family sans
apply()
\family default
, 
\family sans
sweep()
\family default
 and 
\family sans
outer()
\end_layout

\begin_layout Itemize

\family sans
tapply()
\family default
, which summarises a vector divided into groups by the values of another
 vector
\end_layout

\begin_layout Itemize
the 
\family sans
plyr
\family default
 package, which generalises the ideas of 
\family sans
tapply()
\family default
 to work with inputs of data frames, lists and arrays, and outputs of data
 frames, lists, arrays and nothing
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Matrix and array operations
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
apply()
\family default
 is a variant of 
\family sans
sapply()
\family default
 that works with matrices and arrays.
 You can think of it as an operation that summarises a matrix or array,
 collapsing each row or column to a single number.
\end_layout

\begin_layout Itemize
It has four arguments:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
X
\family default
, the matrix or array to summarise 
\end_layout

\begin_layout Itemize

\family sans
MARGIN
\family default
, an integer vector giving the dimensions to summarise over, 1 = rows, 2
 = columns, etc 
\end_layout

\begin_layout Itemize

\family sans
FUN
\family default
, a summary function 
\end_layout

\begin_layout Itemize

\family sans
...

\family default
 other arguments 
\bar under
passed on to 
\family sans
FUN
\end_layout

\end_deeper
\begin_layout Itemize
There are a few caveats to using 
\family sans
apply()
\family default
: it does not have a simplify argument, so you can never be completely sure
 what type of output you will get.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This generally means that 
\family sans
apply()
\family default
 is not safe to use inside a function, unless you carefully check the inputs.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
apply()
\family default
 is also not idempotent in the sense that if the summary function is the
 identity operator, the output is not always the same as the input
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
You can put high-dimensional arrays back in the right order using 
\family sans
aperm()
\family default
, or use 
\family sans
plyr::aaply()
\family default
, which is idempotent.
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
a1 <- apply(a, 1, identity) 
\end_layout

\begin_layout Standard

\family sans
identical(a, a1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE 
\end_layout

\begin_layout Standard

\family sans
identical(a, t(a1)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE 
\end_layout

\begin_layout Standard

\family sans
a2 <- apply(a, 2, identity) 
\end_layout

\begin_layout Standard

\family sans
identical(a, a2) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
sweep() 
\family default
is a function that allows you to "sweep" out the values of a summary statistic.
\end_layout

\begin_layout Itemize
It is most often useful in conjunction with 
\family sans
apply()
\family default
 and it often used to standardise arrays in some way.
 The following example scales the rows of a matrix so that all values lie
 between 0 and 1.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- matrix(rnorm(20, 0, 10), nrow = 4) 
\end_layout

\begin_layout Standard

\family sans
x1 <- sweep(x, 1, apply(x, 1, min)) 
\end_layout

\begin_layout Standard

\family sans
x2 <- sweep(x1, 1, apply(x1, 1, max), "/")
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
outer()
\family default
 takes multiple vector inputs and creates a matrix or array output where
 the input function is run over every combination of the inputs:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
# Create a times table 
\end_layout

\begin_layout Standard

\family sans
outer(1:9, 1:9, "*") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1,] 1 2 3 4 5 6 7 8 9 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [2,] 2 4 6 8 10 12 14 16 18 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [3,] 3 6 9 12 15 18 21 24 27 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [4,] 4 8 12 16 20 24 28 32 36 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [5,] 5 10 15 20 25 30 35 40 45 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [6,] 6 12 18 24 30 36 42 48 54 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [7,] 7 14 21 28 35 42 49 56 63 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [8,] 8 16 24 32 40 48 56 64 72 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [9,] 9 18 27 36 45 54 63 72 81
\end_layout

\end_deeper
\begin_layout Itemize
Good places to learn more about 
\family sans
apply()
\family default
 and friends are:
\end_layout

\begin_deeper
\begin_layout Itemize
"Using apply, sapply, lapply in R" by Peter Werner.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://petewerner.blogspot.com/2012/12/using-apply-sapply-lapply-in-r.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
"The infamous apply function" by Slawa Rokicki.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://rforpublichealth.blogspot.no/2012/09/the-infamous-apply-function.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
"The R apply function  a tutorial with examples" by axiomOfChoice.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://forgetfulfunctor.blogspot.com/2011/07/r-apply-function-tutorial-with-exampl
es.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The stack overflow question "R Grouping functions: sapply vs.
 lapply vs.
 apply.
 vs.
 tapply vs.
 by vs.
 aggregate vs".
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stackoverflow.com/questions/3505701
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Group apply
\end_layout

\begin_deeper
\begin_layout Itemize
You can think about 
\family sans
tapply()
\family default
 as a generalisation to 
\family sans
apply()
\family default
 that allows for "ragged" arrays, where each row can have different numbers
 of columns.
\end_layout

\begin_layout Itemize
It's easiest to understand how 
\family sans
tapply()
\family default
 works by first creating a "ragged" data structure from the inputs.
 This is the job of the 
\family sans
split()
\family default
 function, which takes two inputs and 
\bar under
returns a list
\bar default
, where all the elements in the first vector with equal entries in the second
 vector get put in the same element of the list:
\end_layout

\begin_layout Itemize
Then you can see that 
\family sans
tapply()
\family default
 is just the combination of 
\family sans
split()
\family default
 and 
\family sans
sapply()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
tapply2 <- function(x, group, f, ..., simplify = TRUE) { 
\end_layout

\begin_layout Standard

\family sans
pieces <- split(x, group) 
\end_layout

\begin_layout Standard

\family sans
sapply(pieces, f, simplify = simplify) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
tapply2(pulse, group, length) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> A B 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 10 12 
\end_layout

\begin_layout Standard

\family sans
tapply2(pulse, group, mean) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> A B 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 70.50 74.67
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
The 
\family sans
plyr
\family default
 package
\end_layout

\begin_deeper
\begin_layout Itemize
One challenge with using the base functionals is that they have grown organicall
y over time, and have been written by multiple authors.
 This means that they are not very consistent.
 For example,
\end_layout

\begin_deeper
\begin_layout Itemize
The simplify argument is called 
\family sans
simplify
\family default
 in tapply() and sapply(), but SIMPLIFY for 
\family sans
mapply()
\family default
, and 
\family sans
apply()
\family default
 lacks the argument altogether.
\end_layout

\begin_layout Itemize

\family sans
vapply()
\family default
 is a variant of 
\family sans
sapply()
\family default
 that allows you to describe what the output should be, but there are no
 corresponding variants of
\family sans
 tapply(), apply()
\family default
, or
\family sans
 Map()
\family default
.
\end_layout

\begin_layout Itemize
The first argument to most functionals is the vector, but the first argument
 to 
\family sans
Map()
\family default
 is the function.
\end_layout

\end_deeper
\begin_layout Itemize
Additionally, if you think about the combination of input and output types,
 base R only provides a partial set of functions.
 This was one of the driving forces behind the creation of the 
\family sans
plyr
\family default
 package, which provides consistently named functions with consistently
 named arguments and implements all combinations of input and output data
 structures:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
list
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
data frame
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
array
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
llply
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ldply
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
laply
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data frame
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dlply
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ddply
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
daply
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
array
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
alply
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
adply
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aaply
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Each of these functions splits up the input, applies a function to each
 piece and then joins the results back together.
 
\end_layout

\begin_layout Itemize
Overall, this process is called "
\series bold
split-apply-combine
\series default
", and you can read more about it and 
\family sans
plyr
\family default
 in The Split-Apply-Combine Strategy for Data Analysis (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.jstatsoft.org/v40/i01/
\end_layout

\end_inset

), an open-access article published in the Journal of Statistical Software.
\end_layout

\end_deeper
\begin_layout Subsubsection
Functional programming
\end_layout

\begin_layout Itemize
Another way of thinking about functionals is as a set of general tools for
 altering, subsetting and collapsing lists.
\end_layout

\begin_layout Itemize
Every functional programming has three tools for this: 
\family sans
Map()
\family default
, 
\family sans
Reduce()
\family default
, and 
\family sans
Filter()
\family default
.
\end_layout

\begin_layout Itemize

\family sans
\series bold
Reduce()
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
Reduce()
\family default
 recursively reduces a vector, x, to a single value by recursively calling
 a function f with two arguments at a time.
\end_layout

\begin_layout Itemize
It combines the first two elements with f, then combines the result of that
 call with the third element, and so on.
\end_layout

\begin_layout Itemize
Reduce is also known as 
\series bold
fold
\series default
, because it folds together adjacent elements in the list.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Reduce(`+`, 1:3) ((1 + 2) + 3)
\end_layout

\begin_layout Standard

\family sans
Reduce(sum, 1:3) sum(sum(1, 2), 3)
\end_layout

\end_deeper
\begin_layout Itemize
the essence of 
\family sans
Reduce()
\family default
 can be described by a simple for loop
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The real 
\family sans
Reduce()
\family default
 is more complicated because it includes arguments to control whether the
 values are reduced from the left or from the right (
\family sans
right
\family default
), an optional initial value (
\family sans
init
\family default
), and an option to output every intermediate result (
\family sans
accumulate
\family default
).
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Reduce2 <- function(f, x) { 
\end_layout

\begin_layout Standard

\family sans
out <- x[[1]] 
\end_layout

\begin_layout Standard

\family sans
for(i in seq(2, length(x))) { 
\end_layout

\begin_layout Standard

\family sans
out <- f(out, x[[i]]) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
Reduce is an elegant way of turning binary functions into functions that
 can deal with any number of arguments.
\end_layout

\begin_layout Itemize
It's useful for implementing many types of recursive operations, like merges
 and intersections.
 For example, imagine you had a list of numeric vectors, and you wanted
 to find the values that occurred in every element:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
l <- replicate(5, sample(1:10, 15, rep = T), simplify = FALSE) 
\end_layout

\begin_layout Standard

\family sans
l 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 5 8 4 3 5 4 3 6 5 3 7 3 8 10 10 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[2]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 2 3 4 9 3 5 6 5 2 5 9 7 4 9
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[3]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 8 6 9 8 7 8 4 10 10 9 4 10 7 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[4]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 1 1 5 2 6 8 10 5 9 4 1 3 1 9 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[5]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 8 3 4 1 1 8 3 1 2 8 4 4 5 10
\end_layout

\begin_layout Standard
You could do that by intersecting each element in turn:
\end_layout

\begin_layout Standard

\family sans
intersect(intersect(intersect(intersect(l[[1]], l[[2]]), l[[3]]), l[[4]]),
 l[[5]]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4
\end_layout

\begin_layout Standard
That's hard to read because of the dagwood sandwich problem, and is equivalent
 to:
\end_layout

\begin_layout Standard

\family sans
Reduce(intersect, l) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Predicate functionals
\end_layout

\begin_deeper
\begin_layout Itemize
A 
\series bold
predicate
\series default
 is a function that returns a 
\bar under
single
\bar default
 
\family sans
TRUE
\family default
 or 
\family sans
FALSE
\family default
, like 
\family sans
is.character
\family default
, 
\family sans
all
\family default
, or 
\family sans
is.NULL
\family default
.
 
\family sans
is.na
\family default
 isn't a predicate function because it returns a vector of values.
 
\end_layout

\begin_layout Itemize
There are three useful predicate functionals in base R: 
\family sans
Filter()
\family default
, 
\family sans
Find()
\family default
 and 
\family sans
Position()
\family default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
Filter
\family default
: returns a new vector containing only elements where the predicate is 
\family sans
TRUE
\family default
.
\end_layout

\begin_layout Itemize

\family sans
Find()
\family default
: return the first element that matches the predicate (or the last element
 if 
\family sans
right = TRUE
\family default
).
\end_layout

\begin_layout Itemize

\family sans
Position()
\family default
: return the position of the first element that matches the predicate (or
 the last element if 
\family sans
right = TRUE
\family default
).
\end_layout

\end_deeper
\begin_layout Itemize
Another useful functional makes it easy to generate a logical vector from
 a list (or a data frame) and a predicate:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
where <- function(f, x) { 
\end_layout

\begin_layout Standard

\family sans
vapply(x, f, logical(1)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
compact <- function(x) 
\series bold
Filter
\series default
(function(y) !is.null(y), x)
\end_layout

\begin_deeper
\begin_layout Standard
It removes all null elements from a list
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Mathematical functionals
\end_layout

\begin_layout Itemize
Functionals are very common in mathematics.
 The limit, the maximum, the roots (the set of points where 
\family sans
f(x) = 0
\family default
), and the definite integral are all functionals: given a function, they
 return a single number (or a vector of numbers).
\end_layout

\begin_layout Itemize
There are three functions that work with functions that return a single
 numeric value:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
integrate:
\family default
 find the area under the curve given by 
\family sans
f 
\end_layout

\begin_layout Itemize

\family sans
uniroot
\family default
: find where 
\family sans
f 
\family default
hits zero 
\end_layout

\begin_layout Itemize

\family sans
optimise
\family default
: find location of lowest (or highest) value of 
\family sans
f
\end_layout

\end_deeper
\begin_layout Itemize
Maximum likelihood estimation (MLE) is a natural fit for functional programming
 because we have a well defined problem domain and a general technique to
 solve it.
\end_layout

\begin_layout Itemize
In MLE, we have two sets of parameters: the data, which is fixed for a given
 problem, and the parameters, which will vary as we try to find the maximum.
 That fits naturally with closures because we can have two layers of parameters
 to a closure.
\end_layout

\begin_deeper
\begin_layout Standard
Example: Poisson distribution
\end_layout

\begin_layout Standard

\family sans
poisson_nll <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
n <- length(x)
\end_layout

\begin_layout Standard

\family sans
function(lambda) { 
\end_layout

\begin_layout Standard

\family sans
n * lambda - sum(x) * log(lambda) # + terms not involving lambda 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
nll1 <- poisson_nll(c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)) 
\end_layout

\begin_layout Standard

\family sans
optimise(nll1, c(0, 100))$minimum 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 32.1
\end_layout

\end_deeper
\begin_layout Itemize
Another important mathematical functional is 
\family sans
optim()
\family default
.
 It is a generalisation of 
\family sans
optimise()
\family default
 to more than one dimension.
\end_layout

\begin_layout Itemize
If you're interested in how 
\family sans
optim()
\family default
 works, you might want to explore the 
\family sans
Rvmmin
\family default
 package, which provides a pure-R implementation of 
\family sans
optim()
\family default
.
\end_layout

\begin_layout Itemize
Challenge: read about the 
\series bold
fixed point algorithm
\series default
.
 Complete the exercises using 
\family sans
R
\family default
.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Converting loops to functionals, and when it's not possible
\end_layout

\begin_layout Itemize
Sometimes it's possible to torture your code to make it work, but it's usually
 not a good idea: for loops are verbose and not very expressive, but all
 R programmers are familiar with them.
\end_layout

\begin_layout Itemize
three types of loop that you shouldn't try and convert into a functional:
\end_layout

\begin_deeper
\begin_layout Itemize
modifying in place 
\end_layout

\begin_layout Itemize
recursive functions 
\end_layout

\begin_layout Itemize
while loops
\end_layout

\end_deeper
\begin_layout Itemize
Stackoverflow is a good resource for learning more about converting for
 loops to use functionals.
 A couple of questions and answers that are particularly helpful are:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Alternative to loops in 
\family sans
R
\family default

\begin_inset Quotes erd
\end_inset

 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stackoverflow.com/a/14520342/16632
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Speed up the loop operation in 
\family sans
R
\family default

\begin_inset Quotes erd
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stackoverflow.com/a/2970284/16632
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Modifying in place
\end_layout

\begin_deeper
\begin_layout Itemize
If you need to modify part of an existing data frame, it's often better
 to use a for loop.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
trans <- list( 
\end_layout

\begin_layout Standard

\family sans
disp = function(x) x * 0.0163871, 
\end_layout

\begin_layout Standard

\family sans
am = function(x) factor(x, levels = c("auto", "manual")) 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
for(var in names(trans)) { 
\end_layout

\begin_layout Standard

\family sans
mtcars[[var]] <- trans[[var]](mtcars[[var]]) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
We couldn't normally use 
\family sans
lapply()
\family default
 to replace this loop directly, but it is possible to replace the loop with
 
\family sans
lapply()
\family default
 by using 
\family sans
<<-
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply(names(trans), function(var) { 
\end_layout

\begin_layout Standard

\family sans
mtcars[[var]] <<- trans[[var]](mtcars[[var]]) 
\end_layout

\begin_layout Standard

\family sans
})
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
to understand what mtcars[[var]] <<- ...
 does, you have to understand not only how <<- works, but also what x[[y]]
 <<- z does behind the scenes.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Recursive functions
\end_layout

\begin_deeper
\begin_layout Itemize
Another case where it's hard to convert a for loop into a functional is
 when the relationship is defined recursively.
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
exps <- function(x, alpha) { 
\end_layout

\begin_layout Standard

\family sans
s <- numeric(length(x) + 1) 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_along(s)) { 
\end_layout

\begin_layout Standard

\family sans
if (i == 1) { s[i] <- x[i] 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
s[i] <- alpha * x[i - 1] + (1 - alpha) * s[i - 1] } 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
s 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- runif(10) 
\end_layout

\begin_layout Standard

\family sans
exps(x, 0.5) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.8535 0.8535 0.4356 0.6452 0.4794 0.5209 0.5795 0.5397 0.6378 0.7732 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [11] 0.4325
\end_layout

\begin_layout Standard
We can't eliminate the for loop because none of the functionals we've seen
 allow the output at position
\family sans
 i
\family default
 to depend on the input and output at position 
\family sans
i - 1
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
Another solution for eliminate the for loop in these cases is to solve the
 
\series bold
recurrence relation
\series default
 (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Recurrence_relation#Solving
\end_layout

\end_inset

), removing the recursion and replacing it with explicit references.
 This requires a new set of tools, and is mathematically challenging, but
 it can pay off by producing a simpler function.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
While loops
\end_layout

\begin_deeper
\begin_layout Itemize
the 
\family sans
while
\family default
 loop: this keeps running code until a condition is met.
\end_layout

\begin_layout Itemize

\family sans
while
\family default
 loops are more general than 
\family sans
for
\family default
 loops because you can rewrite every for loop as a while loop, but you can't
 do the opposite.
\end_layout

\begin_layout Itemize
Not every 
\family sans
while
\family default
 loop can be turned into a 
\family sans
for
\family default
 loop, because many while loops don't know in advance how many times they
 will be run:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
i <- 0 
\end_layout

\begin_layout Standard

\family sans
while(TRUE) { 
\end_layout

\begin_layout Standard

\family sans
if (runif(1) > 0.9) break 
\end_layout

\begin_layout Standard

\family sans
i <- i + 1 
\end_layout

\begin_layout Standard

\family sans
}
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
This is equivalent to counting how many times a Bernoulli trial with p =
 0.1 is run before it is successful: this is a geometric random variable
 so you could replace the above code with i <- rgeom(1, 0.1).
 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This is a common situation when you're writing simulations: one of the random
 parameters in your simulation may be how many times a process occurs.
\end_layout

\end_deeper
\begin_layout Subsubsection
A family of functions (case study)
\end_layout

\begin_layout Enumerate
start by defining a very simple plus function, that takes two scalar arguments:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
add <- function(x, y) { 
\end_layout

\begin_layout Standard

\family sans
stopifnot(length(x) == 1, length(y) == 1, 
\end_layout

\begin_layout Standard

\family sans
is.numeric(x), is.numeric(y)) 
\end_layout

\begin_layout Standard

\family sans
x + y 
\end_layout

\begin_layout Standard

\family sans
}
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
We're using R's existing addition operator here, which does much more, but
 the focus in this section is on how we can take very very simple functions
 and extend them to do more
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
We really should also have some way to deal with missing values.
 A helper function will make this a bit easier: if x is missing it should
 return y, if y is missing it should returns x, and if both x and y are
 missing then it should returns another argument to the function: identity.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
rm_na <- function(x, y, identity) { 
\end_layout

\begin_layout Standard

\family sans
if (is.na(x) && is.na(y)) { 
\end_layout

\begin_layout Standard

\family sans
identity
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else if (is.na(x)) { 
\end_layout

\begin_layout Standard

\family sans
y 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
rm_na(NA, 10, 0) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10 
\end_layout

\begin_layout Standard

\family sans
rm_na(10, NA, 0) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10 
\end_layout

\begin_layout Standard

\family sans
rm_na(NA, NA, 0) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\end_layout

\end_deeper
\begin_layout Enumerate
That allows us to write a version of add that can deal with missing values
 if needed: (and it often is!)
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
add <- function(x, y, na.rm = FALSE) { 
\end_layout

\begin_layout Standard

\family sans
if (na.rm && (is.na(x) || is.na(y))) rm_na(x, y, 0) else x + y } 
\end_layout

\begin_layout Standard

\family sans
add(10, NA) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] NA
\emph default
 
\end_layout

\begin_layout Standard

\family sans
add(10, NA, na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10 
\end_layout

\begin_layout Standard

\family sans
add(NA, NA) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] NA 
\end_layout

\begin_layout Standard

\family sans
add(NA, NA, na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\end_layout

\end_deeper
\begin_layout Enumerate
Now we have the basics working, we can extend this function to deal with
 more complicated inputs.
 The first way we might want to extend it is add more than two numbers together.
 This is a simple application of 
\family sans
Reduce
\family default
: if the input is 
\family sans
c(1, 2, 3)
\family default
, then we want to compute 
\family sans
add(1, add(2, 3))
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
r_add <- function(xs, na.rm = TRUE) { 
\end_layout

\begin_layout Standard

\family sans
Reduce(function(x, y) add(x, y, na.rm = na.rm), xs) } 
\end_layout

\begin_layout Standard

\family sans
r_add(c(1, 4, 10))
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 15
\end_layout

\begin_layout Standard
However: 
\end_layout

\begin_layout Standard

\family sans
r_add(NA, na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] NA
\emph default
 
\end_layout

\begin_layout Standard

\family sans
r_add(numeric()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> NULL
\end_layout

\begin_layout Itemize
These are incorrect: in the first case we get a missing value even thought
 we've explicitly asked for them to be ignored, and in the second case we
 get NULL, instead of a length 1 numeric vector (as for every other set
 of inputs).
\end_layout

\begin_layout Itemize
The two problems are related: if we give 
\family sans
Reduce()
\family default
 a length one vector it doesn't have anything to reduce, so it just returns
 the input; if we give it a length 0 input it always returns 
\family sans
NULL
\family default
.
\end_layout

\begin_layout Itemize
There are two ways to fix this: we can concatenate 0 to every input vector,
 or we can use the init argument to 
\family sans
Reduce()
\family default
 (which effectively does the same thing):
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
r_add <- function(xs, na.rm = TRUE) { 
\end_layout

\begin_layout Standard

\family sans
Reduce(function(x, y) add(x, y, na.rm = na.rm), c(0, xs)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
r_add(c(1, 4, 10)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 15 
\end_layout

\begin_layout Standard

\family sans
r_add(NA, na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0 
\end_layout

\begin_layout Standard

\family sans
r_add(numeric()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0
\begin_inset Foot
status open

\begin_layout Plain Layout

\family sans
(This is equivalent to sum())
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
It would also be nice to have a vectorised version of add so that we can
 give it two vectors of numbers to add in parallel.
 We have two ways, using 
\family sans
Map()
\family default
 or 
\family sans
vapply()
\family default
, to implement this:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
v_add <- function(x, y, na.rm = TRUE) { 
\end_layout

\begin_layout Standard

\family sans
stopifnot(length(x) == length(y), 
\end_layout

\begin_layout Standard

\family sans
is.numeric(x), is.numeric(y)
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
Map(function(x, y) add(x, y, na.rm = na.rm), x, y) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
v_add <- function(x, y, na.rm = TRUE) { 
\end_layout

\begin_layout Standard

\family sans
stopifnot(length(x) == length(y), 
\end_layout

\begin_layout Standard

\family sans
is.numeric(x), is.numeric(y)
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
vapply(seq_along(x), function(i) add(x[i], y[i], na.rm = na.rm), 
\end_layout

\begin_layout Standard

\family sans
numeric(1)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
v_add(1:10, 1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 4 6 8 10 12 14 16 18 20 
\end_layout

\begin_layout Standard

\family sans
v_add(numeric(), numeric()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> numeric(0)
\end_layout

\begin_layout Standard

\family sans
v_add(c(1, NA), c(1, NA)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 0 
\end_layout

\begin_layout Standard

\family sans
v_add(c(1, NA), c(1, NA), na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 0
\end_layout

\end_deeper
\begin_layout Enumerate
Another variant of adding is the cumulative sum: it's like the reductive
 version, but we see every step along the way to the final result.
 This is easy to implement with 
\family sans
Reduce()
\family default
's accumuate argument:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
c_add <- function(xs, na.rm = FALSE) { 
\end_layout

\begin_layout Standard

\family sans
Reduce(function(x, y) add(x, y, na.rm = na.rm), xs, accumulate = TRUE) } 
\end_layout

\begin_layout Standard

\family sans
c_add(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 3 6 10 15 21 28 36 45 55 
\end_layout

\begin_layout Standard

\family sans
c_add(10:1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10 19 27 34 40 45 49 52 54 55
\end_layout

\end_deeper
\begin_layout Enumerate
Finally, we might want to define versions for more complicated data structures
 like matrices.
 We could create row and col variants that sum across rows and columns respectiv
ely, or we could go the whole hog and define an array version that would
 sum across any arbitrary dimensions of an array.
 These are easy to implement: they're a combination of 
\family sans
add()
\family default
 and 
\family sans
apply()
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
row_sum <- function(x, na.rm = TRUE) apply(x, 1, add, na.rm = na.rm) 
\end_layout

\begin_layout Standard

\family sans
col_sum <- function(x, na.rm = TRUE) apply(x, 2, add, na.rm = na.rm) 
\end_layout

\begin_layout Standard

\family sans
arr_sum <- function(x, dim, na.rm = TRUE) apply(x, dim, add, na.rm = na.rm)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
(These are equivalent to rowSums() and colSums())
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family sans
There are two main reasons to create our own functions although they're
 existing in base R:
\end_layout

\begin_deeper
\begin_layout Enumerate
we've created all our variants from a very simple binary operator (add)
 and a well-tested functional (
\family sans
Reduce, Map
\family default
 and 
\family sans
apply
\family default
), so we know all the variants will behave consistently.
\end_layout

\begin_layout Enumerate
we've seen the infrastructure for addition, so we can now adapt it to other
 operators that might not have the full suite variants in base 
\family sans
R
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
The downside of this approach is that these implementations are unlikely
 to be efficient (For example, 
\family sans
colSums(x)
\family default
 is much faster than 
\family sans
apply(x, 2, sum)
\family default
).
\end_layout

\begin_layout Itemize
External resource: List out of lambda (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stevelosh.com/blog/2013/03/list-out-of-lambda/
\end_layout

\end_inset

)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
a blog article by Steve Losh that explores how you can produces higher level
 language structures (like lists) out of more primitive language features
 (like closures, aka lambdas)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Function operators
\end_layout

\begin_layout Itemize

\series bold
Function operators
\series default
: functions that take one (or more) functions as input and return a function
 as output.
\end_layout

\begin_layout Itemize
Function operators are a FP technique related to functionals, but where
 functionals abstract away common uses of loops, 
\bar under
function operators abstract over common uses of anonymous functions
\bar default
.
 
\end_layout

\begin_layout Itemize
Like functionals, there's nothing you can't do without them; but they can
 make your code more readable, more expressive and faster to write.
\end_layout

\begin_layout Itemize
we'll start to build up tools that replace standard anonymous functions
 with specialised equivalents that allow us to communicate our intent more
 clearly.
\end_layout

\begin_layout Itemize
learn about partial application and the partial() function.
 Partial application encapsulates the use of an anonymous function to supply
 default arguments, and leads to the succinct code.
\end_layout

\begin_layout Itemize
an important use of FOs: you can eliminate parameters to a functional by
 instead transforming the input function.
 This approach allows your functionals to be more extensible: as long as
 the inputs and outputs of the function remain the same, your functional
 can be extended in ways you haven't thought of.
\end_layout

\begin_layout Itemize
To explore four types of function operators (FOs).
 Function operators can:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
add behaviour
\series default
 while leaving the function otherwise unchanged, like automatically logging
 when the function is run, ensuring a function is run only once, or delaying
 the operation of a function.
\end_layout

\begin_layout Enumerate

\series bold
change output
\series default
, for example by returning a value if the function throws an error, or negating
 the result of a logical predicate.
\end_layout

\begin_layout Enumerate

\series bold
change input
\series default
, like partially evaluating the function, converting a function that takes
 multiple arguments to a function that takes a list, or automatically vectorisin
g a function.
\end_layout

\begin_layout Enumerate

\series bold
combine functions
\series default
, for example, combining the results of predicate functions with boolean
 operators, or composing multiple function calls.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
In other languages
\end_layout

\begin_deeper
\begin_layout Standard
Function operators are used extensively in FP languages like Haskell, and
 are common in Lisp, Scheme and Clojure.
 They are an important part of modern JavaScript programming, like in the
 underscore.js library, and are particularly common in CoffeeScript, since
 the syntax for anonymous functions is so concise.
 Stack based languages like Forth and Factor use function operators almost
 exclusively, since it is rare to refer to variables by name.
 Python's decorators are just function operators by a different name.
 They are very rare in Java, because it's difficult to manipulate functions
 (although possible if you wrap them up in strategy-type objects), and also
 rare in C++; while it's possible to create objects that work like functions
 ("functors") by overloading the () operator, modifying these objects with
 other functions is not a common programming technique.
 That said, C++ 11 adds partial application (std::bind) to the standard
 library.
\end_layout

\end_deeper
\begin_layout Subsubsection
Behavioural FOs
\end_layout

\begin_layout Itemize
The first class of FOs are those that leave the inputs and outputs of a
 function unchanged, but add some extra behaviour.
 
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_deeper
\begin_layout Itemize
imagine we want to download a long vector of urls with 
\family sans
download.file()
\family default
.
 That's pretty simple with 
\family sans
lapply()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply(urls, download.file, quiet = TRUE)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
This example ignores the fact that download.file also needs a file name,
 so pretend it has a useful default for the purposes of this exposition.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Because we have a long list we want to print some output so that we know
 it's working (we'll print a .
 every ten urls), and we also want to avoid hammering the server, so we
 add a small delay to the function between each call.
 That leads to a rather more complicated for loop (we can no longer use
 lapply() because we need an external counter):
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
i <- 1 for(url in urls) { 
\end_layout

\begin_layout Standard

\family sans
i <- i + 1 
\end_layout

\begin_layout Standard

\family sans
if (i %% 10 == 0) cat(".") 
\end_layout

\begin_layout Standard

\family sans
Sys.delay(1) 
\end_layout

\begin_layout Standard

\family sans
download.file(url, quiet = TRUE) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
Reading this code is quite hard because we are using low-level functions,
 and it's not obvious (without some thought), what the overall objective
 is.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Useful behavioural FOs
\end_layout

\begin_deeper
\begin_layout Itemize
Function 
\family sans
delay_by()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
delay_by <- function(delay, f) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
Sys.sleep(delay)
\end_layout

\begin_layout Standard

\family sans
f(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
system.time(runif(100)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.000 0.000 
\series bold
0.001 
\end_layout

\begin_layout Standard

\family sans
system.time(delay_by(1, runif)(100)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.000 0.001 
\series bold
1.001
\end_layout

\end_deeper
\begin_layout Itemize
Function 
\family sans
dot_every()
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Notice that I've made the function the last argument to each FO.
 This makes it read a little better when we compose multiple function operators.
 
\end_layout

\end_inset

: more complicated because it needs to modify state in the parent environment
 using 
\family sans
<<-
\family default
.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
dot_every <- function(n, f) { 
\end_layout

\begin_layout Standard

\family sans
i <- 1 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
if (i %% n == 0) cat(".")
\end_layout

\begin_layout Standard

\family sans
i <<- i + 1 f(...) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- lapply(1:100, runif) 
\end_layout

\begin_layout Standard

\family sans
x <- lapply(1:100, dot_every(10, runif)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> ..........
\end_layout

\end_deeper
\begin_layout Itemize
Two other tasks that we can solve with a behaviour FO are:
\end_layout

\begin_deeper
\begin_layout Enumerate
Logging a time stamp and message to a file everytime a fnction is run
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
log_to <- function(path, message, f) {
\end_layout

\begin_layout Standard

\family sans
stopifnot(file.exists(path))
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
cat(Sys.time(), ": ", message, sep = "", file = path, append = TRUE) 
\end_layout

\begin_layout Standard

\family sans
f(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Enumerate
Ensuring that if the first input is NULL then the output is NULL
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
maybe <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
function(x, ...) { 
\end_layout

\begin_layout Standard

\family sans
if (is.null(x)) return(NULL) 
\end_layout

\begin_layout Standard

\family sans
f(x, ...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Memoisation
\end_layout

\begin_deeper
\begin_layout Itemize
Another thing you might worry about when downloading multiple files is accidenta
lly downloading the same file multiple times.
\end_layout

\begin_layout Itemize
You could avoid it by calling unique on the list of input urls, or manually
 managing a data structure that mapped the url to the result.
\end_layout

\begin_layout Itemize
An alternative approach is to use memoisation: a way of modifying a function
 to automatically cache its results.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(memoise)
\end_layout

\begin_layout Standard

\family sans
slow_function <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
Sys.sleep(1) 
\end_layout

\begin_layout Standard

\family sans
10 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
system.time(slow_function()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.000 0.001 1.000 
\end_layout

\begin_layout Standard

\family sans
system.time(slow_function()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0 0 1 
\end_layout

\begin_layout Standard

\family sans
fast_function <- memoise(slow_function) 
\end_layout

\begin_layout Standard

\family sans
system.time(fast_function()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.000 0.001 1.001 
\end_layout

\begin_layout Standard

\family sans
system.time(fast_function()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0 0 0
\end_layout

\end_deeper
\begin_layout Itemize
Memoisation is an example of a classic tradeoff in computer science: 
\bar under
trading space for speed
\bar default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A memoised function uses more memory (because it stores all of the previous
 inputs and outputs), but is much faster.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It is useful when the computation we do is recursively and depends on the
 previous results the function's calculated.
\end_layout

\begin_layout Itemize
A somewhat more realistic use case is implementing the Fibonacci series.
 The Fibonacci series is defined recursively: the first two values are 1
 and 1, then f(n) = f(n - 1) + f(n - 2).
 Memoising fib() makes the implementation much faster because each value
 is only computed once, and then remembered.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
fib <- function(n) { 
\end_layout

\begin_layout Standard

\family sans
if (n < 2) return(1) 
\end_layout

\begin_layout Standard

\family sans
fib(n - 2) + fib(n - 1) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
system.time(fib(23)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.220 0.007 0.227 
\end_layout

\begin_layout Standard

\family sans
system.time(fib(24)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.344 0.000 0.344
\end_layout

\begin_layout Standard

\family sans
fib2 <- memoise(function(n) { 
\end_layout

\begin_layout Standard

\family sans
if (n < 2) return(1) 
\end_layout

\begin_layout Standard

\family sans
fib2(n - 2) + fib2(n - 1) 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
system.time(fib2(23)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.004 0.000 0.004 
\end_layout

\begin_layout Standard

\family sans
system.time(fib2(24)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.001 0.000 0.001
\end_layout

\end_deeper
\begin_layout Itemize
It doesn't make sense to memoise all functions.
 The example below shows that a memoised random number generator is no longer
 random:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
runifm <- memoise(runif) 
\end_layout

\begin_layout Standard

\family sans
runifm(5) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.9671 0.7691 0.8748 0.6358 0.5873 
\end_layout

\begin_layout Standard

\family sans
runifm(5) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.9671 0.7691 0.8748 0.6358 0.5873
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
download <- dot_every(10, memoise(delay_by(1, download.file)))
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Capturing function invocations
\end_layout

\begin_deeper
\begin_layout Itemize
One challenge with functionals is that it can be hard to see what's going
 on - it's not easy to pry open the internals like it is with a for loop.
\end_layout

\begin_layout Itemize
The tee function, defined below, has three arguments, all functions: f,
 the original function; on_input, a function that's called with the inputs
 to f, and on_output a function that's called with the output from f.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
ignore <- function(...) NULL 
\end_layout

\begin_layout Standard

\family sans
tee <- function(f, on_input = ignore, on_output = ignore) {
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
input <- if (nargs() == 1) c(...) else list(...) 
\end_layout

\begin_layout Standard

\family sans
on_input(input) 
\end_layout

\begin_layout Standard

\family sans
output <- f(...) 
\end_layout

\begin_layout Standard

\family sans
on_output(output) 
\end_layout

\begin_layout Standard

\family sans
output 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
We can use 
\family sans
tee
\family default
 to look into how uniroot finds where x and cos(x) intersect:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
g <- function(x) cos(x) - x 
\end_layout

\begin_layout Standard

\family sans
zero <- uniroot(g, c(-5, 5))
\end_layout

\begin_layout Standard

\family sans
\emph on
# The location where the function is evaluated, i.e.
 root
\end_layout

\begin_layout Standard

\family sans
zero <- uniroot(tee(g, on_input = print), c(-5, 5)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] -5 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 5 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.283662 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.875203 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.72298 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.738631 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.739085 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.739024 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.739085 
\end_layout

\begin_layout Standard

\family sans
\emph on
# The value of the function 
\end_layout

\begin_layout Standard

\family sans
zero <- uniroot(tee(g, on_output = print), c(-5, 5)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 5.28366 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] -4.71634 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.676375 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] -0.234363 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.0268568 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.00076012 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] -0.000000260399 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.000101887 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] -0.000000260399
\end_layout

\end_deeper
\begin_layout Itemize
We might want to capture the sequence of the calls.
 To do that we create a function called 
\family sans
remember()
\family default
 that remembers every argument it was called with, and retrieves them when
 coerced into a list.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
remember <- function() { 
\end_layout

\begin_layout Standard

\family sans
memory <- list() 
\end_layout

\begin_layout Standard

\family sans
f <- function(...) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# This is inefficient! 
\end_layout

\begin_layout Standard

\family sans
memory <<- append(memory, list(...)) 
\end_layout

\begin_layout Standard

\family sans
invisible() 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
structure(f, class = "remember") 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
as.list.remember <- function(x, ...) { 
\end_layout

\begin_layout Standard

\family sans
environment(x)$memory 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
print.remember <- function(x, ...) { 
\end_layout

\begin_layout Standard

\family sans
cat("Remembering...
\backslash
n") 
\end_layout

\begin_layout Standard

\family sans
str(as.list(x)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
Now we can see exactly how 
\family sans
uniroot
\family default
 zeros in on the final answer:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
locs <- remember() 
\end_layout

\begin_layout Standard

\family sans
vals <- remember() 
\end_layout

\begin_layout Standard

\family sans
zero <- uniroot(tee(g, locs, vals), c(-5, 5)) 
\end_layout

\begin_layout Standard

\family sans
x <- sapply(as.list.remember(locs), "[[", 1) 
\end_layout

\begin_layout Standard

\family sans
error <- sapply(as.list.remember(vals), "[[", 1) 
\end_layout

\begin_layout Standard

\family sans
plot(x, type = "b"); .abline(h = 0.739, col = "grey50")
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Output FOs
\end_layout

\begin_layout Itemize
This could be quite simple, or it could fundamentally change the operation
 of the function, returning something completely different to its usual
 output.
 
\end_layout

\begin_layout Itemize

\series bold
Minor modifications
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
base::Negate
\family default
 and 
\family sans
plyr::failwith
\family default
 offer two minor, but useful, modifications of a function that are particularly
 handy in conjunction with functionals.
\end_layout

\begin_layout Itemize

\family sans
Negate
\family default
 takes a function that returns a logical vector (a predicate function),
 and returns the negation of that function.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Negate <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
function(...) !f(...) } 
\end_layout

\begin_layout Standard

\family sans
(Negate(is.null))(NULL) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE
\end_layout

\end_deeper
\begin_layout Itemize
Application: function to remove all null elements from a list
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
compact <- function(x) Filter(Negate(is.null), x)
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
plyr::failwith()
\family default
 turns a function that throws an error into a function that returns a default
 value when there's an error.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
failwith <- function(default = NULL, f, quiet = FALSE) {
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
out <- default 
\end_layout

\begin_layout Standard

\family sans
try(out <- f(...), silent = quiet) 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} l
\end_layout

\begin_layout Standard

\family sans
og("a") 
\end_layout

\begin_layout Standard

\family sans
#> Error: non-numeric argument to mathematical function 
\end_layout

\begin_layout Standard

\family sans
failwith(NA, log)("a") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] NA 
\end_layout

\begin_layout Standard

\family sans
failwith(NA, log, quiet = TRUE)("a") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] NA
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
failwith()
\family default
 is very useful in conjunction with functionals: instead of the failure
 propagating and terminating the higher-level loop, you can complete the
 iteration and then find out what went wrong.
 
\end_layout

\begin_layout Itemize
imagine you're fitting a set of generalised linear models (glms) to a list
 of data frames.
 Sometimes glms fail because of optimisation problems.
 You still want to try to fit all the models, then once that's complete,
 look at the data sets that failed to fit:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
# If any model fails, all models fail to fit: 
\end_layout

\begin_layout Standard

\family sans
models <- lapply(datasets, glm, formula = y ~ x1 + x2 * x3) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# If a model fails, it will get a NULL value 
\end_layout

\begin_layout Standard

\family sans
models <- lapply(datasets, failwith(NULL, glm), formula = y ~ x1 + x2 *
 x3)
\end_layout

\begin_layout Standard

\family sans
\emph on
# remove failed models (NULLs) with compact 
\end_layout

\begin_layout Standard

\family sans
ok_models <- compact(models) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# use where to extract the datasets corresponding to failed models 
\end_layout

\begin_layout Standard

\family sans
failed_data <- datasets[vapply(models, is.null, logical(1))]
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Changing what a function does
\end_layout

\begin_deeper
\begin_layout Itemize
Instead of returning the original return value, we can return some other
 effect of the function evaluation.
\end_layout

\begin_deeper
\begin_layout Enumerate
Return text that the function 
\family sans
print()
\family default
ed:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
capture_it <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
capture.output(f(...))
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
str_out <- capture_it(str) 
\end_layout

\begin_layout Standard

\family sans
str(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> int [1:10] 1 2 3 4 5 6 7 8 9 10 
\end_layout

\begin_layout Standard

\family sans
str_out(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] " int [1:10] 1 2 3 4 5 6 7 8 9 10"
\end_layout

\end_deeper
\begin_layout Enumerate
Return how long a function took to run:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
time_it <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
system.time(f(...)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard
Then we can use this function to revise the functional in previous chapter:
\end_layout

\begin_layout Standard

\family sans
compute_mean <- list( 
\end_layout

\begin_layout Standard

\family sans
base = function(x) mean(x), 
\end_layout

\begin_layout Standard

\family sans
sum = function(x) sum(x) / length(x) ) x <- runif(1e6)
\end_layout

\begin_layout Standard

\family sans
\emph on
# Instead of using an anonymous function to time 
\end_layout

\begin_layout Standard

\family sans
lapply(compute_mean, function(f) system.time(f(x))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $base 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.007 0.000 0.007 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $sum 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.004 0.000 0.005
\end_layout

\begin_layout Standard

\family sans
\emph on
# We can compose function operators 
\end_layout

\begin_layout Standard

\family sans
call_fun <- function(f, ...) f(...) 
\end_layout

\begin_layout Standard

\family sans
lapply(compute_mean, time_it(call_fun), x) 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
Can not directly use time_it in lapply, which will cause error, instead
 we need to use call_fun to help.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\emph on
#> $base 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.007 0.000 0.008 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $sum 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> user system elapsed 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 0.004 0.000 0.004
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
In this example, there's not a huge benefit to using function operators,
 because the composition is simple and we're applying the same operator
 to each function.
 Generally, using function operators is more effective when you are using
 multiple operators or if the gap between creating them and using them is
 large.
\end_layout

\end_deeper
\begin_layout Subsubsection
Input FOs
\end_layout

\begin_layout Itemize

\series bold
Prefilling function arguments: partial function application
\end_layout

\begin_deeper
\begin_layout Itemize
A common use of anonymous functions is to make a variant of a function that
 has certain arguments "filled in" already.
 This is called "
\series bold
partial function application
\series default
", and is implemented by 
\family sans
pryr::partial
\family default
.
\end_layout

\begin_layout Itemize

\series bold
partial()
\series default
 allows us to replace code like
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(a) g(a, b = 1) 
\end_layout

\begin_layout Standard

\family sans
compact <- function(x) Filter(Negate(is.null), x) 
\end_layout

\begin_layout Standard

\family sans
Map(function(x, y) f(x, y, zs), xs, ys)
\end_layout

\begin_layout Standard
with
\end_layout

\begin_layout Standard

\family sans
f <- partial(g, b = 1) 
\end_layout

\begin_layout Standard

\family sans
compact <- partial(Filter, Negate(is.null)) 
\end_layout

\begin_layout Standard

\family sans
Map(partial(f, zs = zs), xs, ys)
\end_layout

\end_deeper
\begin_layout Itemize
We can use this idea to simplify some of the code we used when working with
 lists of functions.
 Instead of:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
funs2 <- list( 
\end_layout

\begin_layout Standard

\family sans
sum = function(x, ...) sum(x, ..., na.rm = TRUE), 
\end_layout

\begin_layout Standard

\family sans
mean = function(x, ...) mean(x, ..., na.rm = TRUE), 
\end_layout

\begin_layout Standard

\family sans
median = function(x, ...) median(x, ..., na.rm = TRUE) )
\end_layout

\begin_layout Standard
We can write:
\end_layout

\begin_layout Standard

\family sans
library(pryr) 
\end_layout

\begin_layout Standard

\family sans
funs2 <- list( 
\end_layout

\begin_layout Standard

\family sans
sum = partial(sum, na.rm = TRUE), 
\end_layout

\begin_layout Standard

\family sans
mean = partial(mean, na.rm = TRUE), 
\end_layout

\begin_layout Standard

\family sans
median = partial(median, na.rm = TRUE) )
\end_layout

\end_deeper
\begin_layout Itemize
The repeating pattern allows us to reduce the code still further:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
funs <- c(sum = sum, mean = mean, median = median) 
\end_layout

\begin_layout Standard

\family sans
funs2 <- lapply(funs, partial, na.rm = TRUE)
\end_layout

\end_deeper
\begin_layout Itemize
Let's think about a similar, but subtly different case.
 Say we have a numeric vector and we want to generate a list of trimmed
 means with that amount of trimming.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Doesn't work: the same trims vector is assigned to every mean function
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
(trims <- seq(0, 0.9, length = 5)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.000 0.225 0.450 0.675 0.900 
\end_layout

\begin_layout Standard

\family sans
funs3 <- lapply(trims, partial, `_f` = mean) 
\end_layout

\begin_layout Standard

\family sans
sapply(funs3, call_fun, c(1:100, (1:50) * 100)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: 'trim' must be numeric of length one
\end_layout

\end_deeper
\begin_layout Itemize
Instead we could use an anonymous function, but still doesn't work because
 each function gets a promis to evaluate t, and that promise isn't evaluated
 until all of the functions are run, by which time t=0.9.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
funs4 <- lapply(trims, function(t) partial(mean, trim = t)) 
\end_layout

\begin_layout Standard

\family sans
funs4[[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (...) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(trim = t, ...) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x48aebc0> 
\end_layout

\begin_layout Standard

\family sans
sapply(funs4, call_fun, c(1:100, (1:50) * 100)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 75.5 75.5 75.5 75.5 75.5
\end_layout

\end_deeper
\begin_layout Itemize
To make it work you need to manually force the evaluation of t:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
funs5 <- lapply(trims, function(t) { 
\end_layout

\begin_layout Standard

\family sans
\series bold
force(t) 
\end_layout

\begin_layout Standard

\family sans
partial(mean, trim = t) 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
funs5[[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (...) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(trim = t, ...) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x5238158> 
\end_layout

\begin_layout Standard

\family sans
sapply(funs5, call_fun, c(1:100, (1:50) * 100)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 883.7 235.6 75.5 75.5 75.5
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
When writing functionals, you can expect your users to know of 
\series bold
partial()
\series default
 and not use 
\series bold
...

\series default
 For example, instead of implementing 
\series bold
lapply()
\series default
 like:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
lapply2 <- function(x, f, ...) { 
\end_layout

\begin_layout Standard

\family sans
out <- vector("list", length(x)) 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_along(x)) { 
\end_layout

\begin_layout Standard

\family sans
out[[i]] <- f(x[[i]], ...)
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
unlist(lapply2(1:5, log, base = 10)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.0000 0.3010 0.4771 0.6021 0.6990
\end_layout

\begin_layout Standard
we could implement it as:
\end_layout

\begin_layout Standard

\family sans
lapply3 <- function(x, f) { 
\end_layout

\begin_layout Standard

\family sans
out <- vector("list", length(x)) 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_along(x)) { 
\end_layout

\begin_layout Standard

\family sans
out[[i]] <- f(x[[i]]) } 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
unlist(lapply3(1:5, partial(log, base = 10))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.0000 0.3010 0.4771 0.6021 0.6990
\end_layout

\end_deeper
\begin_layout Itemize
Partial function application is straightforward in many functional programming
 languages, but it's not entirely clear how it should interact with R's
 lazy evaluation rules.
 The approach plyr::partial takes is to create a function as similar as
 possible to the anonymous function you'd create by hand.
 Peter Meilstrup takes a different approach in his 
\family sans
ptools package
\family default
 (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/crowding/ptools/
\end_layout

\end_inset

); you might want to read about 
\family sans
%()%, %>>%
\family default
 and 
\family sans
%<<%
\family default
 if you're interested in the topic.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Changing input types
\end_layout

\begin_deeper
\begin_layout Itemize
Instead of a minor change to the function's inputs, it's also possible to
 make a function work with a fundamentally different type of data.
 There are a few existing functions along these lines:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
base::Vectorize
\family default
 converts a scalar function to a vector function.
 
\family sans
Vectorize
\family default
 takes a non-vectorised function and vectorises with respect to the arguments
 given in the 
\family sans
vectorizge.args
\family default
 parameter.
 
\end_layout

\begin_deeper
\begin_layout Itemize
A mildly useful extension of 
\family sans
sample
\family default
 would be to vectorize it with respect to size: this would allow you to
 generate multiple samples in one call.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
sample2 <- Vectorize(sample, "size", SIMPLIFY = FALSE) 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
In this example we have used SIMPLIFY = FALSE to ensure that our newly vectorise
d function always returns a list.
 This is usually what you want.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
sample2(1:5, c(1, 1, 3))
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
This will generate 3 samples with length 1, 1 and 3 respectively.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
splat
\family default
 converts a function that takes multiple arguments to a function that takes
 a single list of arguments.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
splat <- function (f) { 
\end_layout

\begin_layout Standard

\family sans
function(args) { 
\end_layout

\begin_layout Standard

\family sans
do.call(f, args) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Itemize
This is useful if you want to invoke a function with varying arguments:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- c(NA, runif(100), 1000) 
\end_layout

\begin_layout Standard

\family sans
args <- list( 
\end_layout

\begin_layout Standard

\family sans
list(x), list(x, na.rm = TRUE), list(x, na.rm = TRUE, trim = 0.1) ) lapply(args,
 splat(mean)) #> [[1]] #> [1] NA #> #> [[2]] #> [1] 10.38 #> #> [[3]] #>
 [1] 0.4897
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
plyr::colwise()
\family default
\series default
 converts a vector function to one that works with data frames:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
summaries <- plyr::each(mean, sd, median) 
\end_layout

\begin_layout Standard

\family sans
summaries(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean sd median 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 5.500 3.028 5.500
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsubsection
Combining FOs
\end_layout

\begin_layout Itemize
Instead of operating on single functions, function operators can take multiple
 functions as input.
 
\end_layout

\begin_layout Itemize
One simple example of this is 
\family sans
plyr::each()
\family default
 which takes a list of vectorised functions and returns a single function
 that applies each in turn to the input:
\end_layout

\begin_layout Itemize
These are glue that join multiple functions together.
\end_layout

\begin_layout Itemize

\series bold
Function composition
\end_layout

\begin_deeper
\begin_layout Itemize
An important way of combining functions is through composition: 
\family sans
f(g(x))
\family default
.
 Composition takes a list of functions and applies them sequentially to
 the input.
\end_layout

\begin_layout Itemize
It's a replacement for the common anonymous function pattern where you chain
 together multiple functions to get the result you want:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
sapply(mtcars, function(x) length(unique(x))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mpg cyl disp hp drat wt qsec vs am gear carb 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 25 3 27 22 22 29 30 2 2 3 6
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
pryr::compose()
\family default
 provides a fuller-featured alternative that can accept multiple functions:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
function (...) { 
\end_layout

\begin_layout Standard

\family sans
fs <- lapply(list(...), match.fun) 
\end_layout

\begin_layout Standard

\family sans
n <- length(fs) 
\end_layout

\begin_layout Standard

\family sans
last <- fs[[n]] 
\end_layout

\begin_layout Standard

\family sans
rest <- fs[-n] 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
out <- last(...) 
\end_layout

\begin_layout Standard

\family sans
for (f in rev(rest)) { 
\end_layout

\begin_layout Standard

\family sans
out <- f(out) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
out 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\end_deeper
\begin_layout Itemize
This allows us to write:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
sapply(mtcars, compose(length, unique)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mpg cyl disp hp drat wt qsec vs am gear carb 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 25 3 27 22 22 29 30 2 2 3 6
\end_layout

\end_deeper
\begin_layout Itemize
Mathematically, function composition is often denoted with an infix operator,
 
\family sans
o
\family default
, 
\family sans
(f o g)(x)
\family default
.
\end_layout

\begin_layout Itemize
In R, we can create our own infix function that works similarly:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
"%.%" <- compose 
\end_layout

\begin_layout Standard

\family sans
sapply(mtcars, length %.% unique) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mpg cyl disp hp drat wt qsec vs am gear carb 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 25 3 27 22 22 29 30 2 2 3 6
\end_layout

\begin_layout Standard

\family sans
sqrt(1 + 8) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 3
\emph default
 
\end_layout

\begin_layout Standard

\family sans
compose(sqrt, `+`)(1, 8) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 3
\emph default
 
\end_layout

\begin_layout Standard

\family sans
(sqrt %.% `+`)(1, 8) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 3
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
compose()
\family default
 is particularly useful in conjunction with 
\family sans
partial()
\family default
, because 
\family sans
partial()
\family default
 allows you to supply additional arguments to the functions being composed.
\end_layout

\begin_layout Itemize
Compose also allows for a very succinct implement of 
\family sans
Negate
\family default
: it's just a partially evaluated version of 
\family sans
compose()
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Negate <- partial(compose, `!`)
\end_layout

\end_deeper
\begin_layout Itemize
We could also implement the standard deviation by breaking it down into
 a separate set of function compositions:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
square <- function(x) x ^ 2 
\end_layout

\begin_layout Standard

\family sans
deviation <- function(x) x - mean(x)
\end_layout

\begin_layout Standard

\family sans
sd <- sqrt %.% mean %.% square %.% deviation sd(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2.872
\end_layout

\end_deeper
\begin_layout Itemize
This type of programming is called 
\series bold
tacit
\series default
 or 
\series bold
point-free programming
\series default
.
 (The term point free comes from the use of the word point to refer values
 in topology; this style is also derogatorily known as 
\series bold
pointless
\series default
).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In this style of programming you don't explicitly refer to variables, focussing
 on the high-level composition of functions, rather than the low-level flow
 of data.
 Since we're using only functions and not parameters, we use verbs and not
 nouns, and this style leads to code that focusses on what's being done,
 not what it's being done to.
 This style is common in Haskell, and is the typical style in stack based
 programming languages like Forth and Factor.
 It's not a terribly natural or elegant style in R, but it is a useful tool
 to have in your toolbox.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
One nice side effect of this style of programming is that it keeps the arguments
 to each function near the function name.
 This is important because code gets harder to understand as the size of
 the chunk of code you have to hold in your head grows.
\end_layout

\begin_layout Itemize
Two new versions based on 
\family sans
compose
\family default
 and 
\family sans
partial
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
download <- dot_every(10, memoise(delay_by(1, download.file)))
\end_layout

\begin_layout Standard

\family sans
download <- pryr::compose( 
\end_layout

\begin_layout Standard

\family sans
partial(dot_every, 10), 
\end_layout

\begin_layout Standard

\family sans
memoise, 
\end_layout

\begin_layout Standard

\family sans
partial(delay_by, 1), 
\end_layout

\begin_layout Standard

\family sans
download.file 
\end_layout

\begin_layout Standard

\family sans
)
\end_layout

\begin_layout Standard

\family sans
download <- partial(dot_every, 10) %.% 
\end_layout

\begin_layout Standard

\family sans
memoise %.% 
\end_layout

\begin_layout Standard

\family sans
partial(delay_by, 1) %.% 
\end_layout

\begin_layout Standard

\family sans
download.file
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Logical predicates and boolean algebra
\end_layout

\begin_deeper
\begin_layout Itemize
When I use 
\family sans
Filter()
\family default
 and other functionals that work with logical predicates, we often anonymous
 functions to combine multiple conditions:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
Filter(function(x) is.character(x) || is.factor(x), iris)
\end_layout

\end_deeper
\begin_layout Itemize
As an alternative, we could define some function operators that combine
 logical predicates:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
and <- function(f1, f2) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { f1(...) && f2(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
or <- function(f1, f2) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
f1(...) || f2(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
not <- function(f1) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
!f1(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard
which would allow us to write:
\end_layout

\begin_layout Standard

\family sans
Filter(or(is.character, is.factor), iris)
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
The common pattern and a subtle bug
\end_layout

\begin_layout Itemize
Most function operators we've seen follow a similar pattern:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
funop <- function(f, otherargs) { 
\end_layout

\begin_layout Standard

\family sans
function(...) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# maybe do something 
\end_layout

\begin_layout Standard

\family sans
res <- f(...) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# maybe do something else 
\end_layout

\begin_layout Standard

\family sans
res 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
There's a subtle problem with this implementation.
 It does not work well with 
\family sans
lapply()
\family default
 because 
\family sans
\bar under
f 
\family default
is lazily evaluated
\bar default
.
\end_layout

\begin_layout Itemize
This means that if you give 
\family sans
lapply()
\family default
 a list of functions and a FO to apply it to each of them, it will look
 like it repeatedly applied the FO to the last function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
wrap <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
function(...) f(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
fs <- list(sum = sum, mean = mean, min = min) 
\end_layout

\begin_layout Standard

\family sans
gs <- lapply(fs, wrap) 
\end_layout

\begin_layout Standard

\family sans
gs$sum(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 
\end_layout

\begin_layout Standard

\family sans
environment(gs$sum)$f 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (..., na.rm = FALSE) .Primitive("min")
\end_layout

\end_deeper
\begin_layout Itemize
Another problem is that as designed, we have to pass in a funtion object,
 not the name of a function, which is often convenient.
\end_layout

\begin_layout Itemize
We can solve both problems by using 
\family sans
match.fun()
\family default
: it forces evaluation of f, and will find the function object if given
 its name:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
wrap2 <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
\series bold
f <- match.fun(f)
\series default
 
\end_layout

\begin_layout Standard

\family sans
function(...) f(...) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
fs <- c(sum = "sum", mean = "mean", min = "min") 
\end_layout

\begin_layout Standard

\family sans
hs <- lapply(fs, wrap2) 
\end_layout

\begin_layout Standard

\family sans
hs$sum(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 55 
\end_layout

\begin_layout Standard

\family sans
environment(hs$sum)$f 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (..., na.rm = FALSE) .Primitive("sum")
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Metaprogramming
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
"Flexibility in syntax, if it does not lead to ambiguity, would seem a reasonabl
e thing to ask of an interactive programming language." --- Kent Pitman
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Itemize
In R you can also access the expression used to compute them.
 Combined with R's lazy evaluation mechanism this gives function authors
 considerable power to both access the underlying expression and do special
 things with it.
\end_layout

\begin_layout Itemize
Techniques based on these tools are generally called "
\series bold
computing on the language
\series default
", and in R provide a set of tools with power equivalent to functional and
 object oriented programming.
\end_layout

\begin_layout Subsubsection
Capturing expressions
\end_layout

\begin_layout Itemize
The tool that makes non-standard evaluation possible in R is 
\family sans
substitute()
\family default
.
 It looks at a function argument, and instead of seeing the value, it looks
 to see how the value was computed:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
substitute(x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1:10 
\end_layout

\begin_layout Standard

\family sans
f(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x 
\end_layout

\begin_layout Standard

\family sans
f(x + y ^ 2 / z + exp(a * sin(b))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x + y^2/z + exp(a * sin(b))
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
substitute()
\family default
 works because function arguments in R are only evaluated when they are
 needed, not automatically when the function is called.
\end_layout

\begin_layout Itemize
This means that function arguments are not just a simple value, but instead
 store both the expression to compute the value and the environment in which
 to compute it.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Together these two things are called a 
\series bold
promise
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
deparse()
\family default
 function takes an expression and converts it to a character vector.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
g <- function(x) 
\end_layout

\begin_layout Standard

\family sans
deparse(substitute(x)) 
\end_layout

\begin_layout Standard

\family sans
g(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "1:10"
\emph default
 
\end_layout

\begin_layout Standard

\family sans
g(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "x" 
\end_layout

\begin_layout Standard

\family sans
g(x + y ^ 2 / z + exp(a * sin(b))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "x + y^2/z + exp(a * sin(b))"
\end_layout

\begin_layout Itemize
There's one important caveat with 
\family sans
deparse()
\family default
: it can return a multiple strings if the input is long:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r
 + s + t + u + v + w + x + y + z)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
If you need a single string, you can work around this by using the width.cutoff
 argument (which has a maximum value of 500), or by joining the lines back
 together again with paste().
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
There are a lot of functions in base 
\family sans
R
\family default
 that use these ideas.
 Some use them to avoid quotes:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(ggplot2) 
\end_layout

\begin_layout Standard

\family sans
library("ggplot2")
\end_layout

\end_deeper
\begin_layout Itemize
Others use them to provide default labels.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
plot.default <- function(x, y = NULL, xlabel = NULL, ylabel = NULL, ...) { 
\end_layout

\begin_layout Standard

\family sans
...
 
\end_layout

\begin_layout Standard

\family sans
xlab <- if (is.null(xlabel) && !missing(x)) deparse(substitute(x)) 
\end_layout

\begin_layout Standard

\family sans
ylab <- if (is.null(ylabel) && !missing(y)) deparse(substitute(y)) 
\end_layout

\begin_layout Standard

\family sans
...
 
\end_layout

\begin_layout Standard

\family sans
}
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
the real code is more complicated because of the way base plotting methods
 work, but it's effectively the same
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family sans
data.frame()
\family default
 does a similar thing.
 It automatically labels variables with the expression used to compute them:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 1:4 
\end_layout

\begin_layout Standard

\family sans
y <- letters[1:4] 
\end_layout

\begin_layout Standard

\family sans
names(data.frame(x, y)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "x" "y"
\end_layout

\end_deeper
\begin_layout Subsubsection
Non-standard evaluation in subset
\end_layout

\begin_layout Itemize
Subset is special because 
\family sans
vs == am
\family default
 or 
\family sans
cyl == 4
\family default
 aren't evaluated in the global environment: instead they're evaluated in
 the data frame.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subset(mtcars, vs == am)
\end_layout

\end_deeper
\begin_layout Itemize
In other words, 
\family sans
subset()
\family default
 implements different scoping rules so instead of looking for those variables
 in the current environment, 
\family sans
subset()
\family default
 looks in the specified data frame.
 
\end_layout

\begin_layout Itemize
This is called 
\series bold
non-standard evaluation
\series default
: you are deliberately breaking R's usual rules in order to do something
 special.
\end_layout

\begin_layout Itemize
To do this we need 
\family sans
eval()
\family default
, which takes an expression and evaluates it in the specified environment.
\end_layout

\begin_layout Itemize

\family sans
quote()
\family default
 is similar to 
\family sans
substitute()
\family default
 but it always gives you back exactly the 
\bar under
expression
\bar default
 you entered.
 This makes it useful for interactive experimentation.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
quote(1:10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1:10 
\end_layout

\begin_layout Standard

\family sans
quote(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x 
\end_layout

\begin_layout Standard

\family sans
quote(x + y ^ 2 / z + exp(a * sin(b))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x + y^2/z + exp(a * sin(b))
\end_layout

\end_deeper
\begin_layout Itemize
If you only provide one argument, it evaluates the expression in the 
\bar under
current environment
\bar default
.
 This makes 
\family sans
eval(quote(x))
\family default
 exactly equivalent to typing x, regardless of what x is:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
eval(quote(x <- 1)) 
\end_layout

\begin_layout Standard

\family sans
eval(quote(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1
\end_layout

\begin_layout Standard

\family sans
eval(quote(cyl)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: object 'cyl' not found
\end_layout

\end_deeper
\begin_layout Itemize
Note that 
\family sans
quote()
\family default
 and 
\family sans
eval()
\family default
 are basically opposites.
 In the example below, each 
\family sans
eval()
\family default
 peels off 
\series bold
(exactly) one
\series default
 layer of quoting.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
quote(quote(2 + 2)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> quote(2 + 2) 
\end_layout

\begin_layout Standard

\family sans
eval(quote(quote(2 + 2))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 2 + 2 
\end_layout

\begin_layout Standard

\family sans
eval(eval(quote(quote(2 + 2)))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4
\end_layout

\end_deeper
\begin_layout Itemize
The second argument to 
\family sans
eval()
\family default
 controls which environment the code is evaluated in:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 10 
\end_layout

\begin_layout Standard

\family sans
eval(quote(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 10
\end_layout

\begin_layout Standard

\family sans
e <- new.env() 
\end_layout

\begin_layout Standard

\family sans
e$x <- 20 
\end_layout

\begin_layout Standard

\family sans
eval(quote(x), e) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 20
\end_layout

\end_deeper
\begin_layout Itemize
Instead of an environment, the second argument can also be a 
\bar under
list or a data frame
\bar default
.
 This works because 
\bar under
an environment is basically a set of mappings between names and values
\bar default
, in the same way as a list or data frame.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
eval(quote(x), list(x = 30)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 30 
\end_layout

\begin_layout Standard

\family sans
eval(quote(x), data.frame(x = 40)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 40
\end_layout

\end_deeper
\begin_layout Itemize
This is basically what we want for 
\family sans
subset()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
eval(quote(cyl == 4), mtcars)
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [12] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [23] FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE TRUE
\end_layout

\end_deeper
\begin_layout Itemize
We can combine 
\family sans
eval()
\family default
 and 
\family sans
substitute()
\family default
 together to write subset(): we can capture the call representing the condition,
 evaluate it in the context of the data frame, and then use the result for
 subsetting:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subset2 <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
condition_call <- 
\series bold
substitute
\series default
(condition) 
\end_layout

\begin_layout Standard

\family sans
r <- 
\series bold
eval
\series default
(condition_call, x) 
\end_layout

\begin_layout Standard

\family sans
x[r, ] 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
When you first start using 
\family sans
eval()
\family default
 it's easy to make mistakes.
 Here's a common one: forgetting to quote the input:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
eval(cyl, mtcars) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: object 'cyl' not found 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Carefully look at the difference to this error 
\end_layout

\begin_layout Standard

\family sans
eval(quote(cyl), mtcars) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
\end_layout

\end_deeper
\begin_layout Itemize
What does 
\family sans
evalq()
\family default
 do? Use it to reduce the amount of typing for the examples above that use
 both 
\family sans
eval()
\family default
 and 
\family sans
quote()
\end_layout

\begin_layout Subsubsection
Scoping issues
\end_layout

\begin_layout Itemize
If eval() can't find the variable inside the data frame (it's second argument),
 it's looking in the function environment.
 That's obviously not what we want, so we need some way to tell 
\family sans
eval()
\family default
 to look somewhere else if it can't find the variables in the data frame.
\end_layout

\begin_layout Itemize
The key is the third argument: 
\family sans
enclos
\family default
.
 This allows us to specify the parent (or enclosing) environment for objects
 that don't have one like lists and data frames (
\family sans
enclos
\family default
 is ignored if we pass in a real environment).
 The enclosing environment is where any objects that aren't found in the
 data frame will be looked for.
 By default it uses the environment of the current function, which is not
 what we want.
\end_layout

\begin_layout Itemize
We want to look for x in the environment in which subset was called.
 In R terminology this is called the 
\series bold
parent frame
\series default
 and is accessed with 
\family sans
parent.frame()
\family default
.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subset2 <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
condition_call <- substitute(condition) 
\end_layout

\begin_layout Standard

\family sans
r <- eval(condition_call, x, parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
x[r, ] }
\end_layout

\begin_layout Standard

\family sans
x <- 4 
\end_layout

\begin_layout Standard

\family sans
subset2(mtcars, cyl == x)
\end_layout

\end_deeper
\begin_layout Itemize
Using 
\family sans
enclos
\family default
 is just a short cut for converting a list or data frame to an environment
 with the desired parent yourself.
 We can use the 
\family sans
list2env()
\family default
 to turn a list into an environment and explicitly set the parent ourselves:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subset2 <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
condition_call <- substitute(condition) 
\end_layout

\begin_layout Standard

\family sans
env <- 
\series bold
list2env
\series default
(x, 
\series bold
parent = parent.frame()
\series default
) 
\end_layout

\begin_layout Standard

\family sans
r <- eval(condition_call, 
\series bold
env
\series default
) 
\end_layout

\begin_layout Standard

\family sans
x[r, ] 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
x <- 4 
\end_layout

\begin_layout Standard

\family sans
subset2(mtcars, cyl == x)
\end_layout

\end_deeper
\begin_layout Itemize
When evaluating code in a non-standard way, it's also a good idea to test
 your code works when run outside of the global environment:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
x <- 6 
\end_layout

\begin_layout Standard

\family sans
subset(mtcars, cyl == x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f()
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
plyr::arrange()
\family default
 works similarly to 
\family sans
subset()
\family default
, but instead of selecting rows, it reorders them.
\end_layout

\begin_layout Itemize
What does 
\family sans
transform()
\family default
 do?
\end_layout

\begin_layout Itemize

\family sans
plyr::mutate()
\family default
 is similar to 
\family sans
transform()
\family default
 but it applies the transformations sequentially so that transformation
 can refer to columns that were just created:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
df <- data.frame(x = 1:5) 
\end_layout

\begin_layout Standard

\family sans
transform(df, x2 = x * x, x3 = x2 * x) 
\end_layout

\begin_layout Standard

\family sans
plyr::mutate(df, x2 = x * x, x3 = x2 * x)
\end_layout

\end_deeper
\begin_layout Itemize
What does 
\family sans
with()
\family default
 do?
\end_layout

\begin_layout Itemize
What does 
\family sans
within()
\family default
 do?
\end_layout

\begin_layout Subsubsection
Calling from another function
\end_layout

\begin_layout Itemize
Typically, computing on the language is most useful for functions called
 directly by the user, not by other functions.
 While subset saves typing, it has one big disadvantage: it's now difficult
 to use non-interactively, e.g.
 from another function.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
colname <- "cyl" 
\end_layout

\begin_layout Standard

\family sans
val <- 6
\end_layout

\begin_layout Standard

\family sans
subset2(mtcars, colname == val) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] mpg cyl disp hp drat wt qsec vs am gear carb 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <0 rows> (or 0-length row.names) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Zero rows because "cyl" != 6
\end_layout

\end_deeper
\begin_layout Itemize
Or imagine we want to create a function that randomly reorders a subset
 of the data:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subset2 <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
condition_call <- substitute(condition) 
\end_layout

\begin_layout Standard

\family sans
r <- eval(condition_call, x, parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
x[r, ] 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
scramble <- function(x) x[sample(nrow(x)), ]
\end_layout

\begin_layout Standard

\family sans
subscramble <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
scramble(subset2(x, condition)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Itemize
But this doesn't work: 
\family sans
condition_call
\family default
 contains the expression 
\family sans
condition
\family default
 so when we try to evaluate that it evaluates condition which has the value
 
\family sans
cyl == 4
\family default
.
 This can't be computed in the parent environment because it doesn't contain
 an object called 
\family sans
cyl
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
This is an example of the general tension between functions that are designed
 for interactive use, and functions that are safe to program with.
 A function that uses 
\family sans
substitute()
\family default
 might save typing, but it's difficult to call from another function.
 As a developer you should also provide an alternative version that works
 when passed a quoted expression.
 For example, we could rewrite:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subset2_q <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
r <- eval(condition, x, parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
x[r, ] 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
subset2 <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
subset2_q(x, substitute(condition)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
subscramble <- function(x, condition) { 
\end_layout

\begin_layout Standard

\family sans
condition <- substitute(condition) 
\end_layout

\begin_layout Standard

\family sans
scramble(
\series bold
subset2_q
\series default
(x, condition)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Subsubsection
Substitute
\end_layout

\begin_layout Itemize
Following the examples above, whenever you write your own functions that
 use non-standard evaluation, you should always provide alternatives that
 others can use.
\end_layout

\begin_layout Itemize
what happens if you want to call a function that uses non-standard evaluation
 and doesn't have a form that takes expressions? 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- quote(mpg) 
\end_layout

\begin_layout Standard

\family sans
y <- quote(disp) 
\end_layout

\begin_layout Standard

\family sans
xyplot(x ~ y, data = mtcars)
\end_layout

\end_deeper
\begin_layout Itemize
Again, we can turn to substitute and use it for another purpose: 
\bar under
modifying expressions
\bar default
.
\end_layout

\begin_layout Itemize
Unfortunately 
\family sans
substitute()
\family default
 has a "feature" that makes experimenting with it interactively a bit of
 a pain: it never does substitutions when run from the global environment,
 and 
\bar under
just behaves like 
\family sans
quote()
\family default
\bar default
:
\end_layout

\begin_layout Itemize
But if we run it inside a function, 
\family sans
substitute()
\family default
 substitutes what it can and leaves everything else the same:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
a <- 1 
\end_layout

\begin_layout Standard

\family sans
b <- 2 
\end_layout

\begin_layout Standard

\family sans
substitute(a + b + x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1 + 2 + x
\end_layout

\end_deeper
\begin_layout Itemize
To make it easier to experiment with 
\family sans
substitute()
\family default
, pryr provides the 
\family sans
subs()
\family default
 function.
 It works exactly the same way as 
\family sans
substitute()
\family default
 except it has a shorter name and if the second argument is the global environme
nt it turns it into a list.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(pryr) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Loading required package: Rcpp 
\end_layout

\begin_layout Standard

\family sans
subs(a + b + x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + b + mpg
\end_layout

\end_deeper
\begin_layout Itemize
The second argument (to both 
\family sans
subs()
\family default
 and 
\family sans
substitute()
\family default
) can override the use of the current environment, and provide an alternative
 list of name-value pairs to use.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subs(a + b, list(a = "y")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> "y" + b 
\end_layout

\begin_layout Standard

\family sans
subs(a + b, list(a = quote(y))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> y + b 
\end_layout

\begin_layout Standard

\family sans
subs(a + b, list(a = quote(y()))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> y() + b
\end_layout

\end_deeper
\begin_layout Itemize
Remember that every action in R is a function call, so we can also replace
 
\family sans
+
\family default
 with another function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
subs(a + b, list("+" = quote(f))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> f(a, b) 
\end_layout

\begin_layout Standard

\family sans
subs(a + b, list("+" = quote(`*`))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a * b
\end_layout

\end_deeper
\begin_layout Itemize
And you can use 
\family sans
substitute
\family default
 to insert any arbitrary object into an expression.
\end_layout

\begin_layout Itemize
This is technically ok, but often results in surprising and undesirable
 behaviour.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
df <- data.frame(x = 1) 
\end_layout

\begin_layout Standard

\family sans
(x <- subs(class(df))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> class(list(x = 1)) 
\end_layout

\begin_layout Standard

\family sans
eval(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "data.frame"
\end_layout

\end_deeper
\begin_layout Itemize
Formally, substitution takes place by examining each name in the expression.
 If the name refers to:
\end_layout

\begin_deeper
\begin_layout Itemize
an 
\bar under
ordinary variable
\bar default
, it's replaced by the 
\bar under
value of the variable
\bar default
.
\end_layout

\begin_layout Itemize
a 
\bar under
promise
\bar default
, it's replaced by the 
\bar under
expression associated with the promise
\bar default
.
\end_layout

\begin_layout Itemize

\bar under
...
\bar default
, it's replaced by the contents of ...
 (only if the substitution occurs in a function)
\end_layout

\end_deeper
\begin_layout Itemize
Otherwise the name is left as is.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- quote(mpg) 
\end_layout

\begin_layout Standard

\family sans
y <- quote(disp) 
\end_layout

\begin_layout Standard

\family sans
subs(xyplot(x ~ y, data = mtcars)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> xyplot(mpg ~ disp, data = mtcars)
\end_layout

\end_deeper
\begin_layout Itemize
It's even simpler inside a function, because we don't need to explicitly
 quote the x and y variables.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
xyplot2 <- function(x, y, data = data) { 
\end_layout

\begin_layout Standard

\family sans
substitute(xyplot(x ~ y, data = data)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
xyplot2(mpg, disp, data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> xyplot(mpg ~ disp, data = mtcars)
\end_layout

\end_deeper
\begin_layout Itemize
If we include 
\family sans
...

\family default
 in the call to substitute, we can add additional arguments to the call:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
xyplot3 <- function(x, y, ...) { 
\end_layout

\begin_layout Standard

\family sans
substitute(xyplot(x ~ y, ...)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
xyplot3(mpg, disp, data = mtcars, col = "red", aspect = "xy") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> xyplot(mpg ~ disp, data = mtcars, col = "red", aspect = "xy")
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Non-standard evaluation in substitute
\end_layout

\begin_deeper
\begin_layout Itemize
One application of this idea is to make a version of substitute that evaluates
 its first argument (i.e.
 a version that uses standard evaluation).
 
\end_layout

\begin_layout Itemize
Note that
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- quote(a + b) 
\end_layout

\begin_layout Standard

\family sans
substitute(x, list(a = 1, b = 2)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x
\end_layout

\end_deeper
\begin_layout Itemize
Instead we can use 
\family sans
pryr::substitute2
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- quote(a + b) 
\end_layout

\begin_layout Standard

\family sans
substitute2(x, list(a = 1, b = 2)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1 + 2
\end_layout

\end_deeper
\begin_layout Itemize
The implementation of 
\family sans
substitute2
\family default
 is short, but deep:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
substitute2 <- function(x, env) { 
\end_layout

\begin_layout Standard

\family sans
call <- substitute(substitute(y, env), list(y = x)) 
\end_layout

\begin_layout Standard

\family sans
eval(call) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
It's a little tricky because of 
\family sans
substitute()
\family default
's non-standard evaluation rules, we can't use the usual technique of working
 through the parentheses inside-out.
\end_layout

\begin_deeper
\begin_layout Enumerate
First 
\family sans
substitute(substitute(y, env), list(y = x))
\family default
 is evaluated.
 The first argument is specially evaluated in the environment containing
 only one item, the value of x with the name y.
 Because we've put x inside a list, it will be evaluated and the rules of
 substitute will replace y with it's value.
 
\bar under
This yields the expression 
\family sans
substitute(a + b, env).
\end_layout

\begin_layout Enumerate
Next we evaluate that expression inside the current function.
 
\family sans
substitute()
\family default
 specially evaluates its first argument, and looks for name value pairs
 in env, which evaluates to 
\family sans
list(a = 1, b = 2)
\family default
.
 Those are both values (not promises) so the result will be 
\family sans
a + b
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Capturing unevaluated ...
\end_layout

\begin_deeper
\begin_layout Itemize
Another frequently useful technique is to capture all of the unevaluated
 expressions in 
\family sans
...
\family default
.
 Base R functions do this in many ways, but there's one technique that works
 well in a wide variety of situations:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
dots <- function(...) { 
\end_layout

\begin_layout Standard

\family sans
eval(substitute(alist(...))) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
This uses the 
\family sans
alist()
\family default
 function which simply captures all its arguments.
 This function is the same as 
\family sans
pryr::dots()
\family default
, and 
\family sans
pryr
\family default
 also provides 
\family sans
pryr::named_dots()
\family default
, which ensures all arguments are named, using the deparsed expressions
 as default names.
\end_layout

\end_deeper
\begin_layout Subsubsection
The downsides of nonstandard evaluation
\end_layout

\begin_layout Itemize
There are usually two principles you can follow when modelling the evaluation
 of R code:
\end_layout

\begin_deeper
\begin_layout Enumerate
If the underlying values are the same, the results will be the same.
 i.e.
 the three results will all be the same:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 10; y <- 10 
\end_layout

\begin_layout Standard

\family sans
f(10); f(x); f(y)
\end_layout

\end_deeper
\begin_layout Enumerate
You can model evaluation by working from the innermost parentheses to the
 outermost.
\end_layout

\end_deeper
\begin_layout Itemize
Non-standard evaluation can break both principles.
 This makes the mental model needed to correctly predict the output much
 more complicated, so it's only worthwhile to do so if there is significant
 gain.
\end_layout

\begin_layout Itemize
For example,
\family sans
 library()
\family default
 and 
\family sans
require()
\family default
 allow you to call them either with or without quotes, because internally
 they use deparse(substitute(x)) plus a couple of tricks.
 
\end_layout

\begin_layout Itemize
However, things start to get complicated if the variable has a value.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
ggplot2 <- "plyr" 
\end_layout

\begin_layout Standard

\family sans
library(ggplot2)
\end_layout

\begin_layout Standard
loads 
\family sans
ggplot2
\family default
, not 
\family sans
plyr
\family default
.
 If you want to load plyr (the value of the 
\family sans
ggplot2
\family default
 variable), you need to use an additional argument:
\end_layout

\begin_layout Standard

\family sans
library(ggplot2, character.only = TRUE)
\end_layout

\end_deeper
\begin_layout Itemize
Using an argument to change the behaviour of another argument is not a great
 idea because it means you must completely and carefully read all of the
 function arguments to understand what one function argument means.
 You can't understand the effect of each argument in isolation, and hence
 it's harder to reason about the results of a function call.
\end_layout

\begin_layout Itemize
There are a number of other R functions that use 
\family sans
substitute()
\family default
 and 
\family sans
deparse()
\family default
 in this way: 
\family sans
ls(), rm(), data(), demo(), example(), vignette().
\end_layout

\begin_layout Itemize
These all use non-standard evaluation and then have special ways of enforcing
 the usual rules.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Author: To me, eliminating two quotes is not worth the cognitive cost of
 non-standard evaluation, and I don't recommend you use substitute() for
 this purpose.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
One situtation where non-standard evaluation is more useful is 
\family sans
data.frame()
\family default
, which uses the input expressions to automatically name the output variables
 if not otherwise provided:
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Author: I think it is worthwhile in 
\family sans
data.frame()
\family default
 because it eliminates a lot of redundancy in the common scenario when you're
 creating a data frame from existing variables, and importantly, it's easy
 to override this behaviour by supplying names for each variable.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 10 
\end_layout

\begin_layout Standard

\family sans
y <- "a" 
\end_layout

\begin_layout Standard

\family sans
df <- data.frame(x, y) 
\end_layout

\begin_layout Standard

\family sans
names(df) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "x" "y"
\end_layout

\end_deeper
\begin_layout Itemize
The code for 
\family sans
data.frame()
\family default
 is rather complicated, but we can create our own simple version for lists
 to see how a function that does this might work.
 The key is 
\family sans
pryr::named_dots()
\family default
, a function which returns the unevaluated ...
 arguments, with default names.
 Then it's just a matter of arranging the evaluated results in a list:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
list2 <- function(...) { 
\end_layout

\begin_layout Standard

\family sans
dots <- named_dots(...) 
\end_layout

\begin_layout Standard

\family sans
lapply(dots, eval, parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 1; y <- 2 
\end_layout

\begin_layout Standard

\family sans
list2(x, y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 
\end_layout

\begin_layout Standard

\family sans
list2(x, z = y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $z 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2
\end_layout

\end_deeper
\begin_layout Subsubsection
Applications
\end_layout

\begin_layout Itemize

\family sans
\series bold
plyr::
\family default
.
 and 
\family sans
ggplot2::aes
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
ggplot2
\family default
 uses the 
\family sans
aes()
\family default
 to define a set of mappings between variables in your data and visual propertie
s on your graphic.
\end_layout

\begin_layout Itemize

\family sans
plyr
\family default
 uses the .
 function to capture the names (or more complicated expressions) of variables
 used to split a data frame into pieces.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
.
 <- function (..., .env = parent.frame()) { 
\end_layout

\begin_layout Standard

\family sans
structure( as.list(match.call()[-1]), 
\end_layout

\begin_layout Standard

\family sans
env = .env, 
\end_layout

\begin_layout Standard

\family sans
class = "quoted" 
\end_layout

\begin_layout Standard

\family sans
) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
aes <- function (x = NULL, y = NULL, ...) { 
\end_layout

\begin_layout Standard

\family sans
aes <- structure( 
\end_layout

\begin_layout Standard

\family sans
as.list(match.call()[-1]), 
\end_layout

\begin_layout Standard

\family sans
class = "uneval") 
\end_layout

\begin_layout Standard

\family sans
class(aes) <- "uneval" 
\end_layout

\begin_layout Standard

\family sans
ggplot2:::rename_aes(aes) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
ggplot2
\family default
 provides 
\family sans
aes_string()
\family default
 which allows you to specify variables by the string representation of their
 name, and 
\family sans
plyr
\family default
 uses S3 methods so that you can either supply an object of class quoted
 (as created with 
\family sans
.()
\family default
), or a regular character vector.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Plyr: summarise, mutate and arrage
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\family sans
plyr
\family default
 package also uses non-standard evaluation to complete the set of tools
 provided by the base 
\family sans
subset()
\family default
 and 
\family sans
transform()
\family default
 functions with 
\family sans
mutate(), summarise()
\family default
 and 
\family sans
arrange()
\family default
.
 
\end_layout

\begin_layout Itemize
Each of these functions has the same interface: the first argument is a
 data frame and the subsequent arguments are evaluated in the context of
 that data frame (i.e.
 they look there first for variables, and then in the current environment)
 and they return a data frame.
\end_layout

\begin_layout Itemize
*The code for the four function go here.
\end_layout

\begin_layout Itemize
Combined with a by operator (e.g.
 
\family sans
ddply()
\family default
) these four functions allow you to express the majority of data manipulation
 operations.
 
\end_layout

\begin_layout Itemize
Then when you have a new problem, solving it becomes a matter of thinking
 about which operations you need to apply and in what order.
 The realm of possible actions has been shrunk to a manageable number.
\end_layout

\end_deeper
\begin_layout Subsubsection
Conclusion
\end_layout

\begin_layout Itemize
Now that you understand how our version of subset works, go back and read
 the source code for 
\family sans
subset.data.frame
\family default
, the base R version which does a little more.
 Other functions that work similarly are 
\family sans
with.default
\family default
, 
\family sans
within.data.frame
\family default
, 
\family sans
transform.data.frame
\family default
, and in the 
\family sans
plyr
\family default
 package ., arrange, and summarise.
 Look at the source code for these functions and see if you can figure out
 how they work.
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Itemize
It's generally a bad idea to create code by operating on its string representati
on: there is no guarantee that you'll create valid code.
\end_layout

\begin_layout Itemize
pasting strings together will often allow you to solve your problem in the
 least amount of time, but it may create subtle bugs that will take your
 users hours to track down.
\end_layout

\begin_layout Subsubsection
Structure of expressions
\end_layout

\begin_layout Itemize
We want to distinguish between the action of multiplying x by 10 and assigning
 the results to y versus the actual result (40).
 In R, we can capture the action with 
\family sans
quote()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
z <- quote(y <- x * 10) 
\end_layout

\begin_layout Standard

\family sans
z 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> y <- x * 10
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
quote()
\family default
 gives us back an expression, an object that represents an action that can
 be performed by R.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Confusingly the 
\family sans
expression()
\family default
 function produces expression lists, but since you'll never need to use
 that function we can safely ignore it
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
An expression is also called an 
\bar under
abstract syntax tree
\bar default
 (
\series bold
AST)
\series default
 because it represents the abstract structure of the code in a tree form.
 We can use 
\family sans
pryr::call_tree()
\family default
 to see the hierarchy more clearly:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(pryr) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Loading required package: Rcpp
\emph default
 
\end_layout

\begin_layout Standard

\family sans
call_tree(z) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- <-() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- *() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 10
\end_layout

\end_deeper
\begin_layout Itemize
There are three basic things you'll commonly see in a call tree: 
\bar under
constants
\bar default
, 
\bar under
names
\bar default
 and 
\bar under
calls
\bar default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
constants
\series default
 are atomic vectors, like "a" or 10.
 These appear as is.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
call_tree(quote("a")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- "a" 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(1)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(1L)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1L 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(TRUE)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- TRUE
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
names
\series default
 which represent the name of a variable, not its value.
 (Names are also sometimes called symbols).
 These are prefixed with '
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
call_tree(quote(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `x 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(mean)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `mean
\emph default
 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(`an unusual name`)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `an unusual name
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
calls
\series default
 represent the 
\bar under
action
\bar default
 of calling a function, not its result.
 These are suffixed with 
\family sans
()
\family default
.
 The arguments to the function are listed below it, and can be constants,
 names or other calls.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
call_tree(quote(f(a, b))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `b 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(f(g(), h(1, a)))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- f() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- g() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- h() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `a
\end_layout

\end_deeper
\begin_layout Itemize
As mentioned in Functions, even things that don't look like function calls
 still follow this same hierarchical structure
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In general, it's possible for any type of R object to live in a call tree,
 but these are the only three types you'll get from parsing R code.
 It's possible to put anything else inside an expression using the tools
 described below, but while technically correct, support is often patchy
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
call_tree(quote(a + b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- +() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `b 
\end_layout

\begin_layout Standard

\family sans
call_tree(quote(if (x > 1) x else 1/x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- if() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- >() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- /() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `x call_tree(quote(function(x, y) {x * y})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- function() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- list(x = , y = ) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- {() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- *() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- structure(c(3L, 17L, 3L, 38L, 17L, 38L, 3L, 3L), srcfile = <environ...
\end_layout

\end_deeper
\begin_layout Itemize
Together, names and calls are sometimes called 
\bar under
language objects
\bar default
, and can be tested for with 
\family sans
is.language()
\family default
.
 Note that 
\family sans
str()
\family default
 is somewhat inconsistent with respect to this naming convention, describing
 names as symbols, and calls as a language objects.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Constants
\end_layout

\begin_deeper
\begin_layout Itemize
Quoting a single atomic vector gives it back to you:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
is.atomic(quote(1)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE 
\end_layout

\begin_layout Standard

\family sans
identical(1, quote(1)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE 
\end_layout

\begin_layout Standard

\family sans
is.atomic(quote("test")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE 
\end_layout

\begin_layout Standard

\family sans
identical("test", quote("test")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\begin_layout Itemize
But quoting a vector of values gives you something different because you
 always use a function to create a vector:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
identical(1:3, quote(1:3)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE 
\end_layout

\begin_layout Standard

\family sans
identical(c(FALSE, TRUE), quote(c(FALSE, TRUE))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE
\end_layout

\end_deeper
\begin_layout Itemize
It's possible to use 
\family sans
substitute()
\family default
 to directly insert a vector into a call tree, but use this with caution
 as you are creating a call that is not be generated during the normal operation
 of R.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
y <- substitute(f(x), list(x = 1:3)) 
\end_layout

\begin_layout Standard

\family sans
is.atomic(y)
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Names
\end_layout

\begin_deeper
\begin_layout Itemize
As well as capturing names with 
\family sans
quote()
\family default
, it's also possible to convert strings to names.
 This is mostly useful when your function receives strings as input, as
 it's more typing than using 
\family sans
quote()
\family default
:
\end_layout

\begin_layout Itemize
As well as capturing names with 
\family sans
quote()
\family default
, it's also possible to convert strings to names.
 This is mostly useful when your function receives strings as input, as
 it's more typing than using 
\family sans
quote()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
identical(quote(name), as.name("name")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\begin_layout Standard

\family sans
as.name("a b") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> `a b`
\end_layout

\end_deeper
\begin_layout Itemize
Note that the second example produces the name 
\family sans
`a b `
\family default
: the backticks are the standard way of escape non-standard names in R.
\end_layout

\begin_layout Itemize
There's one special name that needs a little extra discussion: the name
 that represents missing values.
 You can get this from the formals of a function, or with 
\family sans
alist()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
formals(plot)$x
\end_layout

\begin_layout Standard

\family sans
alist(x =)[[1]]
\end_layout

\end_deeper
\begin_layout Itemize
It is basically a special name, that you can create by using
\family sans
 quote()
\family default
 in a slightly unusual way:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
quote(expr =)
\end_layout

\end_deeper
\begin_layout Itemize
Note that this object behaves strangely, and is rarely useful, except when
 (as we'll see later) you want to try a function with arguments that don't
 have defaults.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- quote(expr =) 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: argument "x" is missing, with no default
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Calls
\end_layout

\begin_deeper
\begin_layout Itemize
As well as capturing complete calls using 
\family sans
quote()
\family default
, modifying existing calls using 
\family sans
substitute()
\family default
 you can also create calls from their constituent pieces using using 
\family sans
as.call()
\family default
 or 
\family sans
call()
\family default
.
\end_layout

\begin_layout Itemize
The first argument to 
\family sans
call()
\family default
 is 
\bar under
a string
\bar default
 giving a function name, and the other arguments should be expressions that
 are used as the arguments to the call.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
call(":", 1, 10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1:10 
\end_layout

\begin_layout Standard

\family sans
call("mean", 1:10, na.rm = TRUE) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(1:10, na.rm = TRUE)
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
as.call()
\family default
 is a minor variation that takes a list where the first argument is the
 
\bar under
name
\bar default
 of a function (not a string), and the subsequent values are the arguments.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x_call <- quote(1:10) 
\end_layout

\begin_layout Standard

\family sans
mean_call <- as.call(list(quote(mean), x_call)) 
\end_layout

\begin_layout Standard

\family sans
identical(mean_call, quote(mean(1:10))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\begin_layout Itemize
Note that the following two calls look the same, but are actually different:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
(a <- call("mean", 1:10)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(1:10) 
\end_layout

\begin_layout Standard

\family sans
(b <- call("mean", quote(1:10))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(1:10) identical(a, b) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE 
\end_layout

\begin_layout Standard

\family sans
call_tree(a) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- mean() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1:10 
\end_layout

\begin_layout Standard

\family sans
\emph on
call_tree(b) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- mean() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- :() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 10
\end_layout

\begin_layout Standard
In 
\family sans
a
\family default
, the first argument to mean is an integer vector containing the numbers
 1 to 10, and in 
\family sans
b
\family default
 the first argument is a call to 
\family sans
:
\family default
.
 You can put any R object into an expression, but the printing of expression
 objects will not always show the difference.
\end_layout

\end_deeper
\begin_layout Itemize
The key difference is where/when evaluation occurs:
\end_layout

\begin_layout Itemize
You may want to capture the expression that caused the current function
 to run.
 There are two ways to do this:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
a <- call("print", Sys.time()) 
\end_layout

\begin_layout Standard

\family sans
b <- call("print", quote(Sys.time())) 
\end_layout

\begin_layout Standard

\family sans
eval(a); Sys.sleep(1); eval(a) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "2014-01-30 19:08:18 UTC" 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "2014-01-30 19:08:18 UTC" 
\end_layout

\begin_layout Standard

\family sans
eval(b); Sys.sleep(1); eval(b) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "2014-01-30 19:08:19 UTC" 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "2014-01-30 19:08:20 UTC"
\end_layout

\end_deeper
\begin_layout Itemize
The first element of a call doesn't have to be the name of a function, and
 instead 
\bar under
can be a call that generates a function
\bar default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
(function(x) x + 1)(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 11 
\end_layout

\begin_layout Standard

\family sans
add <- function(y) function(x) x + y 
\end_layout

\begin_layout Standard

\family sans
add(1)(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 11
\end_layout

\begin_layout Standard

\family sans
\emph on
# Note that you can't create this sort of call with call 
\end_layout

\begin_layout Standard

\family sans
call("add(1)", 10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> `add(1)`(10) 
\end_layout

\begin_layout Standard

\family sans
\emph on
# But you can with as.call 
\end_layout

\begin_layout Standard

\family sans
as.call(list(quote(add(1)), 10)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> add(1)(10)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
An interesting use of 
\family sans
call()
\end_layout

\begin_deeper
\begin_layout Itemize
One interesting use of call lies inside the 
\family sans
mode<-
\family default
 function which is an alternative way to change the mode of a vector.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
`mode2<-` <- function (x, value) { 
\end_layout

\begin_layout Standard

\family sans
mde <- paste0("as.", value) 
\end_layout

\begin_layout Standard

\family sans
eval(call(mde, x), parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 1:10 
\end_layout

\begin_layout Standard

\family sans
mode2(x) <- "character" 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "1" "2" "3" "4" "5" "6" "7" "8" "9" "10"
\end_layout

\end_deeper
\begin_layout Itemize
Another way to achieve the same goal would be find the function and then
 call it:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
`mode3<-` <- function(x, value) { 
\end_layout

\begin_layout Standard

\family sans
mde <- match.fun(paste0("as.", value))
\end_layout

\begin_layout Standard

\family sans
mde(x) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 1:10 
\end_layout

\begin_layout Standard

\family sans
mode3(x) <- "character" 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "1" "2" "3" "4" "5" "6" "7" "8" "9" "10"
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Author: Generally, I'd prefer 
\family sans
mode3<-
\family default
 over 
\family sans
mode2<-
\family default
 because it uses concepts familiar to more 
\family sans
R
\family default
 programmers, and generally it's a good idea to use the simplest and most
 commonly understood techniques that solve a given problem.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Extracting elements of a call
\end_layout

\begin_deeper
\begin_layout Itemize
When it comes to modifying calls, they behave almost exactly like lists:
 a call has 
\family sans
length
\family default
, '
\family sans
[[
\family default
 and
\family sans
 [
\family default
 methods.
 The length of a call minus 1 gives the number of arguments:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- quote(read.csv("important.csv", row.names = FALSE)) length(x) - 1 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2
\end_layout

\end_deeper
\begin_layout Itemize
The first element of the call is the name of the function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x[[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv 
\end_layout

\begin_layout Standard

\family sans
\emph on
# read.csv
\end_layout

\end_deeper
\begin_layout Itemize
The remaining elements are the arguments to the function, which can be extracted
 by name or by position.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x$row.names 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE 
\end_layout

\begin_layout Standard

\family sans
x[[3]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE
\end_layout

\begin_layout Standard

\family sans
names(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "" "" "row.names"
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Standardising function calls
\end_layout

\begin_deeper
\begin_layout Itemize
Generally, extracting arguments by position is dangerous, because R's function
 calling semantics are so flexible.
 
\end_layout

\begin_layout Itemize
It's better to match by name, but all arguments might not be named.
 The solution to this problem is to use 
\family sans
match.call()
\family default
, which takes a function and a call as arguments:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
y <- match.call(read.csv, x) 
\end_layout

\begin_layout Standard

\family sans
names(y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "" "file" "row.names"
\end_layout

\begin_layout Standard

\family sans
\emph on
# Or if you don't know in advance what the function is 
\end_layout

\begin_layout Standard

\family sans
match.call(eval(x[[1]]), x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv(file = "important.csv", row.names = FALSE)
\end_layout

\end_deeper
\begin_layout Itemize
This will be an important tool when we start manipulating existing function
 calls.
 If we don't use match.call we'll need a lot of extra code to deal with all
 the possible ways to call a function.
\end_layout

\begin_layout Itemize
We can wrap this up into a function.
 To figure out the definition of the associated function we evaluate the
 first component of the call, the name of the function.
 
\end_layout

\begin_layout Itemize
We need to specify an environment here, because the function might be different
 in different places.
 Whenever we provide an environment parameter, 
\family sans
parent.frame()
\family default
 is usually a good default.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
standardise_call <- function(call, env = parent.frame()) {
\end_layout

\begin_layout Standard

\family sans
stopifnot(is.call(call)) 
\end_layout

\begin_layout Standard

\family sans
f <- eval(call[[1]], env) 
\end_layout

\begin_layout Standard

\family sans
if (is.primitive(f)) return(call)
\end_layout

\begin_layout Standard

\family sans
match.call(f, call) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
standardise_call(y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv(file = "important.csv", row.names = FALSE)
\emph default
 standardise_call(quote(standardise_call(y))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> standardise_call(call = y)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Modifying a call
\end_layout

\begin_deeper
\begin_layout Itemize
You can add, modify and delete elements of the call with the standard replacemen
t operators, 
\family sans
$<-
\family default
 and 
\family sans
[[<-
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
y$row.names <- TRUE 
\end_layout

\begin_layout Standard

\family sans
y$col.names <- FALSE 
\end_layout

\begin_layout Standard

\family sans
y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv(file = "important.csv", row.names = TRUE, col.names = FALSE)
\end_layout

\begin_layout Standard

\family sans
y[[2]] <- "less-important.csv" 
\end_layout

\begin_layout Standard

\family sans
y[[4]] <- NULL 
\end_layout

\begin_layout Standard

\family sans
y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv(file = "less-important.csv", row.names = TRUE)
\end_layout

\begin_layout Standard

\family sans
y$file <- quote(paste0(filename, ".csv")) 
\end_layout

\begin_layout Standard

\family sans
y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv(file = paste0(filename, ".csv"), row.names = TRUE)
\end_layout

\end_deeper
\begin_layout Itemize
Calls also support the [ method, but use it with care: since the first element
 is the function to call, removing it is unlikely to create a call that
 will evaluate without error.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x[-3]
\emph on
 # remove the second argument 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv("important.csv") 
\end_layout

\begin_layout Standard

\family sans
x[-1] 
\emph on
# remove the function name - but it's still a call! 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> "important.csv"(row.names = FALSE) 
\end_layout

\begin_layout Standard

\family sans
x 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> read.csv("important.csv", row.names = FALSE)
\end_layout

\end_deeper
\begin_layout Itemize
If you want to get a list of the unevaluated arguments, explicitly convert
 it to a list:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\emph on
# A list of the unevaluated arguments 
\end_layout

\begin_layout Standard

\family sans
as.list(x[-1]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "important.csv" 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $row.names 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] FALSE
\end_layout

\end_deeper
\begin_layout Itemize
We can use these ideas to create an easy way modify a call given a list.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
modify_call <- function(call, new_args) { 
\end_layout

\begin_layout Standard

\family sans
call <- standardise_call(call) 
\end_layout

\begin_layout Standard

\family sans
nms <- names(new_args) %||% rep("", length(new_args))
\end_layout

\begin_layout Standard

\family sans
if (any(nms == "")) { 
\end_layout

\begin_layout Standard

\family sans
stop("All new arguments must be named", call.
 = FALSE) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
for(nm in nms) { 
\end_layout

\begin_layout Standard

\family sans
call[[nm]] <- new_args[[nm]] 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
call 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
modify_call(quote(mean(x, na.rm = TRUE)), list(na.rm = NULL)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(x = x) 
\end_layout

\begin_layout Standard

\family sans
modify_call(quote(mean(x, na.rm = TRUE)), list(na.rm = FALSE)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> mean(x = x, na.rm = FALSE) 
\end_layout

\begin_layout Standard

\family sans
modify_call(quote(mean(x, na.rm = TRUE)), list(x = quote(y))) 
\emph on
#> mean(x = y, na.rm = TRUE)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsubsection
Parsing and deparsing
\end_layout

\begin_layout Subsubsection
Capturing the current call
\end_layout

\begin_layout Itemize
You can convert quoted calls back and forth between text with 
\family sans
parse()
\family default
 and 
\family sans
deparse()
\family default
.
 
\end_layout

\begin_layout Itemize

\family sans
deparse()
\family default
 takes an expression and returns a character vector.
 
\family sans
parse()
\family default
 does the opposite: it takes a character vector and returns a list of expression
s, also known as an expression object or expression list.
\end_layout

\begin_layout Itemize
Note that because the primary use of 
\family sans
parse()
\family default
 is parsing files of code on disk, the first argument is a file path, and
 if you have the code in a character vector, you need to use the 
\family sans
text
\family default
 argument.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
z <- quote(y <- x * 10) 
\end_layout

\begin_layout Standard

\family sans
deparse(z) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "y <- x * 10"
\end_layout

\begin_layout Standard

\family sans
parse(text = deparse(z)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> expression(y <- x * 10)
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
deparse()
\family default
 returns a character vector with an entry for each line, and by default
 it will try to make lines that are around 60 characters long.
 If you want a single string be sure to 
\family sans
paste()
\family default
 it back together, and read the other options in the documentation.
\end_layout

\begin_layout Itemize

\family sans
parse()
\family default
 can't return just a single expression, because there might be many top-level
 calls in an file.
\end_layout

\begin_layout Itemize
Instead it returns expression objects, or expression lists.
 You should never need to create expression objects yourself, and all you
 need to know about them is that they're a list of calls:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
exp <- parse(text = c("x <- 4
\backslash
ny <- x * 10")) 
\end_layout

\begin_layout Standard

\family sans
length(exp) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 2 
\end_layout

\begin_layout Standard

\family sans
exp[[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x <- 4
\emph default
 
\end_layout

\begin_layout Standard

\family sans
is.call(exp[[1]]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\begin_layout Itemize
It's not possible for 
\family sans
parse()
\family default
 and 
\family sans
deparse()
\family default
 be completely symmetric.
 See the help for 
\family sans
deparse()
\family default
 for more details.
\end_layout

\begin_layout Itemize

\family sans
\series bold
Sourcing files from disk
\end_layout

\begin_deeper
\begin_layout Itemize
With 
\family sans
parse()
\family default
 and 
\family sans
eval()
\family default
 you can write your own simple version of 
\family sans
source()
\family default
.
\end_layout

\begin_layout Itemize
We read in the file on disk, 
\family sans
parse()
\family default
 it and then 
\family sans
eval()
\family default
 each component in the specified environment.
\end_layout

\begin_layout Itemize
This version defaults to a new environment, so it doesn't affect existing
 objects.
\end_layout

\begin_layout Itemize

\family sans
source()
\family default
 invisibly returns the result of the last expression in the file, so 
\family sans
simple_source()
\family default
 does the same.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The real 
\family sans
source()
\family default
 is considerably more complicated because it preserves the underlying source
 code, can echo input and output, and has many additional settings to control
 behaviour.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
simple_source <- function(file, envir = new.env()) {
\end_layout

\begin_layout Standard

\family sans
stopifnot(file.exists(file)) stopifnot(is.environment(envir))
\end_layout

\begin_layout Standard

\family sans
lines <- readLines(file, warn = FALSE) 
\end_layout

\begin_layout Standard

\family sans
exprs <- parse(text = lines, n = -1)
\end_layout

\begin_layout Standard

\family sans
n <- length(exprs) 
\end_layout

\begin_layout Standard

\family sans
if (n == 0L) return(invisible())
\end_layout

\begin_layout Standard

\family sans
for (i in seq_len(n - 1)) { 
\end_layout

\begin_layout Standard

\family sans
eval(exprs[i], envir) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
invisible(eval(exprs[n], envir)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Capturing the current call
\end_layout

\begin_layout Itemize
You may want to capture the expression that caused the current function
 to run.
 There are two ways to do this:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
sys.call()
\family default
 captures exactly what the user typed.
\end_layout

\begin_layout Enumerate

\family sans
match.call()
\family default
 uses R's regular argument matching rules and converts everything to full
 name matching.
 This is usually easier to work with because you know that the call will
 always have the same structure.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function(abc = 1, def = 2, ghi = 3, ...) { 
\end_layout

\begin_layout Standard

\family sans
list(sys = sys.call(), match = match.call()) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f(d = 2, 2) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $sys 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> f(d = 2, 2) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $match 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> f(abc = 2, def = 2)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
A cautionary tale: write.csv
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
write.csv()
\family default
 is a base R function where call manipulation is used in a suboptimal manner.
 It captures the call to 
\family sans
write.csv()
\family default
 and mangles it to instead call 
\family sans
write.table()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
write.csv <- function (...) { 
\end_layout

\begin_layout Standard

\family sans
Call <- match.call(expand.dots = TRUE) 
\end_layout

\begin_layout Standard

\family sans
for (argname in c("append", "col.names", "sep", "dec", "qmethod")) { 
\end_layout

\begin_layout Standard

\family sans
if (!is.null(Call[[argname]])) { 
\end_layout

\begin_layout Standard

\family sans
warning(gettextf("attempt to set '%s' ignored", argname), domain = NA) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
rn <- eval.parent(Call$row.names) 
\end_layout

\begin_layout Standard

\family sans
Call$append <- NULL 
\end_layout

\begin_layout Standard

\family sans
Call$col.names <- if (is.logical(rn) && !rn) TRUE else NA 
\end_layout

\begin_layout Standard

\family sans
Call$sep <- "," 
\end_layout

\begin_layout Standard

\family sans
Call$dec <- "." 
\end_layout

\begin_layout Standard

\family sans
Call$qmethod <- "double" 
\end_layout

\begin_layout Standard

\family sans
Call[[1L]] <- as.name("write.table") 
\end_layout

\begin_layout Standard

\family sans
eval.parent(Call) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
We could write a function that behaves identically using regular function
 call semantics:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
write.csv <- function(x, file = "", sep = ",", qmethod = "double", ...) { 
\end_layout

\begin_layout Standard

\family sans
write.table(x = x, file = file, sep = sep, qmethod = qmethod, ...) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Itemize
This makes the function much easier to understand: it's just calling write.table
 with different defaults.
\end_layout

\begin_layout Itemize
This also fixes a subtle bug in the original 
\family sans
write.csv
\family default
: 
\family sans
write.csv(mtcars, row = FALSE)
\family default
 raises an error, but 
\family sans
write.csv(mtcars, row.names = FALSE)
\family default
 does not.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Generally, you always want to use the simplest tool that will solve a problem
 - that makes it more likely that others will understand your code.
 Again, there's no point in using non-standard evaluation unless there's
 a big win: non-standard evaluation will make your function behave much
 less predictably.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Other uses of call capturing
\end_layout

\begin_deeper
\begin_layout Itemize
Many modelling functions use 
\family sans
match.call()
\family default
 to capture the call used to create the model.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is one reason that creating lists of models using a function doesn't
 give the greatest output
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This makes it possible to 
\family sans
update()
\family default
 a model, modifying only a few components of the original model (but note
 that 
\bar under
it doesn't preserve any of the computation
\bar default
, even if possible).
 
\end_layout

\begin_layout Itemize
We can rewrite it using some of the tools (
\family sans
dots()
\family default
 and 
\family sans
modify_call()
\family default
) we've developed in this chapter to make it easier to see exactly what's
 going on.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
update_call <- function (object, formula., ...) { 
\end_layout

\begin_layout Standard

\family sans
call <- object$call 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Use a update.formula to deal with formulas like .
 ~ .
 
\end_layout

\begin_layout Standard

\family sans
if (!missing(formula.)) { 
\end_layout

\begin_layout Standard

\family sans
call$formula <- update.formula(formula(object), formula.) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
modify_call(call, dots(...)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
update2 <- function(object, formula., ...) { 
\end_layout

\begin_layout Standard

\family sans
call <- update_call(object, formula., ...) 
\end_layout

\begin_layout Standard

\family sans
eval(call, parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
update_call(mod, formula = .
 ~ .
 + cyl) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> lm(formula = mpg ~ wt + cyl, data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
update_call(mod, subset = cyl == 4) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> lm(formula = mpg ~ wt, data = mtcars, subset = cyl == 4)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
Authoer:The original update() has an evaluate argument that controls whether
 the function returns a call or the result, but I think it's good principle
 for a function to only return one type of object (not different types depending
 on the arguments) so I split it into two.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This rewrite also allows us to fix a small bug in update: it evaluates the
 call in the global environment, when really we want to re-evaluate it in
 the environment where the model was originally fit.
 This happens to be stored in the formula (called terms) so we can easily
 extract it.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
n <- 3 lm(mpg ~ poly(wt, n), data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
mod <- f() update(mod, data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Error: object 'n' not found
\end_layout

\begin_layout Standard

\family sans
update2 <- function(object, formula., ...) { 
\end_layout

\begin_layout Standard

\family sans
call <- update_call(object, formula., ...) 
\end_layout

\begin_layout Standard

\family sans
eval(call, environment(
\series bold
object$terms
\series default
)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
update2(mod, data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Call: 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> lm(formula = mpg ~ poly(wt, n), data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Coefficients: 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> (Intercept) poly(wt, n)1 poly(wt, n)2 poly(wt, n)3 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 20.091 -29.116 8.636 0.275
\end_layout

\end_deeper
\begin_layout Itemize
This is a good principle to remember: if you want to later replay the code
 you've captured using 
\family sans
match.call()
\family default
 you really also need to capture the environment in which the code was evaluated.
\end_layout

\begin_layout Itemize
There is a big potential downside: because you've captured that environment
 and saved it in an object, that environment will hang around and any objects
 in the environment will also hang around.
 That can have big implications for memory use.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
f <- function() { 
\end_layout

\begin_layout Standard

\family sans
x <- runif(1e7) 
\end_layout

\begin_layout Standard

\family sans
y <- runif(1e7)
\end_layout

\begin_layout Standard

\family sans
lm(mpg ~ wt, data = mtcars) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
mod <- f() 
\end_layout

\begin_layout Standard

\family sans
object.size(environment(mod$terms)$x)
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 80000040 bytes
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Creating a function
\end_layout

\begin_layout Itemize
There's one function call that's so special it's worth devoting a little
 extra attention to: the 
\family sans
function
\family default
 function that creates functions.
\end_layout

\begin_layout Itemize
This is one place we'll see pairlists (the object type that predated lists
 in R's history).
 The arguments of a function are stored as a pairlist: for our purposes
 we can treat a pairlist like a list, but we need to remember to cast arguments
 with 
\family sans
as.pairlist()
\family default
.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
str(quote(function(x, y = 1) x + y)[[2]]) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> Dotted pair list of 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ x: symbol 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> $ y: num 1
\end_layout

\end_deeper
\begin_layout Itemize
Building up a function by hand is also useful when you can't use a closure
 because you don't know in advance what the arguments will be.
 
\end_layout

\begin_layout Itemize
The function itself is fairly simple: it creates a call to function with
 the args and body as arguments, and then evaluates that in the correct
 environment so that the function has the right scope.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
make_function <- function(args, body, env = parent.frame()) { 
\end_layout

\begin_layout Standard

\family sans
args <- as.pairlist(args)
\end_layout

\begin_layout Standard

\family sans
eval(call("function", args, body), env) 
\end_layout

\begin_layout Standard

\family sans
}
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
pryr::make_function() includes a little more error checking but is otherwise
 identical.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
add <- make_function(alist(a = 1, b = 2), quote(a + b)) 
\end_layout

\begin_layout Standard

\family sans
add(1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 3 
\end_layout

\begin_layout Standard

\family sans
add(1, 2) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 3
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
Note our use of the alist() (argument list) function.
 We used this earlier when capturing unevaluated ..., and we use it again here.
 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Note that 
\family sans
alist()
\family default
 doesn't evaluate its arguments and supports arguments with and without
 defaults (although if you don't want a default you need to be explicit).
 There's one small trick if you want to have ...
 in the argument list: you need to use it on the left-hand side of an equals
 sign.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
make_function(alist(a = , b = a), quote(a + b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (a, b = a) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + b 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1e96240> 
\end_layout

\begin_layout Standard

\family sans
make_function(alist(a = , b = ), quote(a + b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (a, b) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + b 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1e96240> 
\end_layout

\begin_layout Standard

\family sans
make_function(alist(a = , b = , ...
 =), quote(a + b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (a, b, ...) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + b 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1e96240>
\end_layout

\end_deeper
\begin_layout Itemize
If you want to mix evaluated and unevaluated arguments, it might be easier
 to make the list by hand:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
args <- list() 
\end_layout

\begin_layout Standard

\family sans
args$a <- x 
\end_layout

\begin_layout Standard

\family sans
args$b <- quote(expr = )
\end_layout

\begin_layout Standard

\family sans
make_function(args, quote(a + b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (a = 1, b) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + b 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1e96240>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Unenclose
\end_layout

\begin_deeper
\begin_layout Itemize
Most of the time it's simpler to use closures to create new functions, but
 
\family sans
make_function()
\family default
 is useful if we want to make it obvious to the user what the function does
 (printing out a closure isn't usually that helpful because all the variables
 are 
\bar under
present by name, not by value
\bar default
).
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
unenclose <- function(f) { 
\end_layout

\begin_layout Standard

\family sans
env <- environment(f) 
\end_layout

\begin_layout Standard

\family sans
new_body <- substitute2(body(f), env) 
\end_layout

\begin_layout Standard

\family sans
make_function(formals(f), new_body, parent.env(env)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
f <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
function(y) x + y 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
f(1) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function(y) 
\end_layout

\begin_layout Standard

\family sans
x + y 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x3f89b08> 
\end_layout

\begin_layout Standard

\family sans
unenclose(f(1)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function (y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1 + y
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <environment: 0x1e96240>
\end_layout

\end_deeper
\begin_layout Itemize
Read the documentation and source for 
\family sans
pryr::partial()
\family default
 - what does it do? How does it work?
\end_layout

\end_deeper
\begin_layout Subsubsection
Walking the call tree with recursive functions
\end_layout

\begin_layout Itemize
The 
\family sans
codetools
\family default
 package, included in the base distribution, provides some built-in tools
 for automated code inspection that use these ideas:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
findGlobals():
\family default
 locates all global variables used by a function.
 This can be useful if you want to check that your functions don't inadvertently
 rely on variables defined in their parent environment.
\end_layout

\begin_layout Itemize

\family sans
checkUsage()
\family default
: checks for a range of common problems including unused local variables,
 unused parameters and use of partial argument matching.
\end_layout

\begin_layout Itemize
The key to any function that works with the parse tree right is getting
 the recursion right, which means making sure that you know what the base
 case is (the leaves of the tree) and figuring out how to combine the results
 from the recursive case.
\end_layout

\begin_layout Itemize
The nodes of a tree are always calls (except in the rare case of function
 arguments, which are pairlists), and the leaves are names, single argument
 calls or constants.
\end_layout

\begin_layout Itemize
R provides a helpful function to distinguish whether an object is a node
 or a leaf: 
\family sans
is.recursive()
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Finding F and T
\end_layout

\begin_deeper
\begin_layout Itemize
We'll start with a function that returns a single logical value, indicating
 whether or not a function uses the logical abbreviations T and F.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Using T and F is generally considered to be poor coding practice, and it's
 something that R CMD check will warn about.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
When writing a recursive function, it's useful to first think about the
 simplest case: how do we tell if a leaf is a T or a F?
\end_layout

\begin_layout Itemize
The base case is simple: if the object isn't recursive, then we just return
 the value of 
\family sans
is_logical_abbr()
\family default
 applied to the object.
 If the object is not a node, then we work through each of the elements
 of the node in turn, recursively calling 
\family sans
logical_abbr()
\family default
.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
logical_abbr <- function(x) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Base case 
\end_layout

\begin_layout Standard

\family sans
if (!is.recursive(x)) return(is_logical_abbr(x))
\end_layout

\begin_layout Standard

\family sans
\emph on
# Recursive cases 
\end_layout

\begin_layout Standard

\family sans
if (is.function(x)) { 
\end_layout

\begin_layout Standard

\family sans
if (logical_abbr(body(x))) return(TRUE) 
\end_layout

\begin_layout Standard

\family sans
if (logical_abbr(formals(x))) return(TRUE) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
for (i in seq_along(x)) { 
\end_layout

\begin_layout Standard

\family sans
if (logical_abbr(x[[i]])) return(TRUE) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
FALSE 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
logical_abbr(quote(T)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE 
\end_layout

\begin_layout Standard

\family sans
logical_abbr(quote(mean(x, na.rm = T))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\begin_layout Standard

\family sans
f <- function(x = TRUE) { 
\end_layout

\begin_layout Standard

\family sans
g(x + T) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
logical_abbr(f) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Finding all variables created by assignment
\end_layout

\begin_deeper
\begin_layout Itemize
One reason to start with this function is because the recursion is a little
 bit simpler - we never need to go all the way down to the leaves because
 we are looking for assignment, a call to 
\family sans
<-
\family default
.
\end_layout

\begin_layout Itemize
This means that our base case is simple: if we're at a leaf, we've gone
 too far and can immediately return.
 
\end_layout

\begin_layout Itemize
We have two other cases: we have hit a call, in which case we should check
 if it's 
\family sans
<-
\family default
, otherwise it's some other recursive structure and we should call the function
 recursively on each element.
\end_layout

\begin_layout Itemize
Note the use of 
\family sans
identical()
\family default
 to compare the call to the name of the assignment function, and recall
 that the second element of a call object is the first argument, which for
 
\family sans
<-
\family default
 is the left hand side: the object being assigned to.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
is_call_to <- function(x, name) { 
\end_layout

\begin_layout Standard

\family sans
is.call(x) && identical(x[[1]], as.name(name)) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
find_assign <- function(obj) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Base case 
\end_layout

\begin_layout Standard

\family sans
if (!is.recursive(obj)) return()
\end_layout

\begin_layout Standard

\family sans
if (is_call_to(obj, "<-")) {
\end_layout

\begin_layout Standard

\family sans
obj[[2]] 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
lapply(obj, find_assign) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
find_assign(quote(a <- 1)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a 
\end_layout

\begin_layout Standard

\family sans
find_assign(quote({ a <- 1 b <- 2 })) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[1]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> NULL 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[2]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [[3]] 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> b
\end_layout

\end_deeper
\begin_layout Itemize
Instead of returning a list, let's keep it simple and stick with a character
 vector.
 We'll also test it with two slightly more complicated examples:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
find_assign <- function(obj) { 
\end_layout

\begin_layout Standard

\family sans
# Base case 
\end_layout

\begin_layout Standard

\family sans
if (!is.recursive(obj)) return(character())
\end_layout

\begin_layout Standard

\family sans
if (is_call_to(obj, "<-")) { 
\end_layout

\begin_layout Standard

\family sans
as.character(obj[[2]]) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
else { 
\end_layout

\begin_layout Standard

\family sans
unlist(lapply(obj, find_assign)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
find_assign(quote({ a <- 1 b <- 2 a <- 3 })) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" "b" "a"
\end_layout

\begin_layout Standard

\family sans
find_assign(quote({ system.time(x <- print(y <- 5)) })) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "x"
\end_layout

\begin_layout Itemize
This is better, but we have two problems: repeated names, and we miss assignment
s inside function calls.
\end_layout

\end_deeper
\begin_layout Itemize
The fix for the first problem is easy: we need to wrap 
\family sans
unique()
\family default
 around the recursive case to remove duplicate assignments.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
find_assign <- function(obj) { 
\end_layout

\begin_layout Standard

\family sans
# Base case 
\end_layout

\begin_layout Standard

\family sans
if (!is.recursive(obj)) return(character())
\end_layout

\begin_layout Standard

\family sans
if (is_call_to(obj, "<-")) { 
\end_layout

\begin_layout Standard

\family sans
call <- as.character(obj[[2]]) 
\end_layout

\begin_layout Standard

\family sans
c(call, unlist(lapply(obj[[3]], find_assign))) 
\end_layout

\begin_layout Standard

\family sans
} else {
\end_layout

\begin_layout Standard

\family sans
unique(unlist(lapply(obj, find_assign))) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
find_assign(quote({
\end_layout

\begin_layout Standard

\family sans
a <- 1 
\end_layout

\begin_layout Standard

\family sans
b <- 2 
\end_layout

\begin_layout Standard

\family sans
a <- 3 
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" "b"
\end_layout

\begin_layout Standard

\family sans
find_assign(quote({
\end_layout

\begin_layout Standard

\family sans
system.time(x <- print(y <- 5)) 
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "x" "y"
\end_layout

\end_deeper
\begin_layout Itemize
There's one more case we need to test:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
find_assign(quote({ 
\end_layout

\begin_layout Standard

\family sans
ls <- list() 
\end_layout

\begin_layout Standard

\family sans
ls$a <- 5 
\end_layout

\begin_layout Standard

\family sans
names(ls) <- "b" 
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "ls" "$" "a" "names"
\end_layout

\begin_layout Standard

\family sans
call_tree(quote({ 
\end_layout

\begin_layout Standard

\family sans
ls <- list() 
\end_layout

\begin_layout Standard

\family sans
ls$a <- 5 
\end_layout

\begin_layout Standard

\family sans
names(ls) <- "b" 
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- {() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- <-() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `ls 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- list() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- <-() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- $() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `ls 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `a 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- 5 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- <-() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- names() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- `ls 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 
\backslash
- "b"
\end_layout

\end_deeper
\begin_layout Itemize
This behaviour might be ok, but we probably just want assignment into whole
 objects, not assignment that modifies some property of the object.
 Drawing the tree for that quoted object helps us see what condition we
 should test for - we want the object on the left hand side of assignment
 to be a name.
 This gives the final version of the find_assign function.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
find_assign <- function(obj) { 
\end_layout

\begin_layout Standard

\family sans
# Base case 
\end_layout

\begin_layout Standard

\family sans
if (!is.recursive(obj)) return(character())
\end_layout

\begin_layout Standard

\family sans
if (is_call_to(obj, "<-")) { 
\end_layout

\begin_layout Standard

\family sans
call <- if (is.name(obj[[2]])) as.character(obj[[2]]) 
\end_layout

\begin_layout Standard

\family sans
c(call, unlist(lapply(obj[[3]], find_assign))) 
\end_layout

\begin_layout Standard

\family sans
} else { 
\end_layout

\begin_layout Standard

\family sans
unique(unlist(lapply(obj, find_assign))) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
find_assign(quote({ 
\end_layout

\begin_layout Standard

\family sans
ls <- list() 
\end_layout

\begin_layout Standard

\family sans
ls$a <- 5 
\end_layout

\begin_layout Standard

\family sans
names(ls) <- "b" 
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "ls"
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
Making this function work absolutely correct requires quite a lot more work,
 because we need to figure out all the other ways that assignment might
 happen: with =, assign(), or delayedAssign().
 But a static tool can never be perfect: the best you can hope for is a
 set of heuristics that catches the most common 90% of cases.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Modifying the call tree
\end_layout

\begin_deeper
\begin_layout Itemize
Instead of returning vectors computed from the contents of an expression,
 you can also return a modified expression, such as base R's 
\family sans
bquote()
\family default
.
\end_layout

\begin_layout Itemize

\family sans
bquote()
\family default
 is a slightly more flexible form of quote: it allows you to optionally
 quote and unquote some parts of an expression (it's similar to the backtick
 operator in Lisp).
\end_layout

\begin_layout Itemize
Everything is quoted, unless it's encapsulated in 
\family sans
.()
\family default
 in which case it's evaluated and the result is inserted.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
a <- 1 b <- 3 bquote(a + b) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + b 
\end_layout

\begin_layout Standard

\family sans
bquote(a + .(b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> a + 3 
\end_layout

\begin_layout Standard

\family sans
bquote(.(a) + .(b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> 1 + 3 
\end_layout

\begin_layout Standard

\family sans
bquote(.(a + b)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 4
\end_layout

\end_deeper
\begin_layout Itemize
This provides a fairly easy way to control what gets evaluated when you
 call 
\family sans
bquote()
\family default
, and what gets evaluated when the expression is evaluated.
 
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
bquote2 <- function (x, where = parent.frame()) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Base case 
\end_layout

\begin_layout Standard

\family sans
if (!is.recursive(x)) return(x)
\end_layout

\begin_layout Standard

\family sans
if (is.call(x)) { 
\end_layout

\begin_layout Standard

\family sans
if (identical(x[[1]], quote(.))) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# Call to .(), so evaluate 
\end_layout

\begin_layout Standard

\family sans
eval(x[[2]], where) 
\end_layout

\begin_layout Standard

\family sans
} else { 
\end_layout

\begin_layout Standard

\family sans
as.call(lapply(x, bquote2, where = where)) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} else if (is.pairlist(x)) { 
\end_layout

\begin_layout Standard

\family sans
as.pairlist(lapply(x, bquote2, where = where)) 
\end_layout

\begin_layout Standard

\family sans
} else { 
\end_layout

\begin_layout Standard

\family sans
stop("Unknown case") 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 1 
\end_layout

\begin_layout Standard

\family sans
bquote2(quote(x == .(x))) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x == 1
\end_layout

\begin_layout Standard

\family sans
y <- 2 bquote2(quote(function(x = .(x)) { 
\end_layout

\begin_layout Standard

\family sans
x + .(y)
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function(x = 1) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x + 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> }
\end_layout

\end_deeper
\begin_layout Itemize
Note that functions that modify the source tree are most useful for creating
 expressions that are used at run-time, not saved back into the original
 source file.
 That's because all non-code information is lost:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
bquote2(quote(function(x = .(x)) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
# This is a comment 
\end_layout

\begin_layout Standard

\family sans
x + 
\emph on
# funky spacing 
\end_layout

\begin_layout Standard

\family sans
.(y) 
\end_layout

\begin_layout Standard

\family sans
})) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> function(x = 1) { 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> x + 2 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> }
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
bquote()
\family default
 is rather like a macro from a 
\family sans
languages
\family default
 like Lisp.
 But unlike macros the modifications occur at runtime, not compile time
 (which doesn't have any meaning in 
\family sans
R
\family default
).
 And unlike a macro there is no restriction to return an expression: a macro-lik
e function in 
\family sans
R
\family default
 can return anything.
 More like 
\family sans
fexprs.

\family default
 a fexpr is like a function where the arguments aren't evaluated by default;
 or a macro where the result is a value, not code.
\end_layout

\begin_layout Itemize
Programmers Niche: Macros in R by Thomas Lumley.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf#page=11
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Special environments
\end_layout

\begin_layout Itemize
R's 
\bar under
lexical scoping
\bar default
 rules, l
\bar under
azy argument evaluation
\bar default
 and 
\bar under
first-class environments
\bar default
 make it an excellent language in which to design special environments that
 allow you to create 
\series bold
domain specific languages (DSLs)
\series default
.
 
\end_layout

\begin_layout Itemize
This chapter uses ideas from the breadth of the book including non-standard
 evaluation, environment manipulation, active bindings, ...
\end_layout

\begin_deeper
\begin_layout Itemize
Evaluate code in a special context: 
\family sans
local, capture.output, with_*
\end_layout

\begin_layout Itemize
Supply an expression instead of a function: 
\family sans
curve
\end_layout

\begin_layout Itemize
Combine evaluation with extra processing: 
\family sans
test_that, assert_that
\end_layout

\begin_layout Itemize
Create a full-blown DSL: 
\family sans
html, plotmath, deriv, parseNamespace, sql
\end_layout

\end_deeper
\begin_layout Subsubsection
Evaluation code in a special context
\end_layout

\begin_layout Itemize
It's often useful to evaluate a chun of code in a special context
\end_layout

\begin_deeper
\begin_layout Itemize
Temporarily modifying global state, like the working directory, environment
 variables, plot options or locale.
\end_layout

\begin_layout Itemize
Capture side-effects of a function, like the text it prints, or the warings
 it emits
\end_layout

\begin_layout Itemize
Evaluate code in a new environmentw
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
with_something
\end_layout

\begin_deeper
\begin_layout Itemize
There are a number of parameters in R that have global state (e.g.
 
\family sans
option()
\family default
, environmental variables, 
\family sans
par()
\family default
, ...) and it's useful to be able to run code temporarily in a different context.
 
\end_layout

\begin_layout Itemize
it's often useful to be able to run code with the working directory temporarily
 set to a new location:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
in_dir <- function(dir, code) { 
\end_layout

\begin_layout Standard

\family sans
old <- setwd(dir) 
\end_layout

\begin_layout Standard

\family sans
on.exit(setwd(old))
\end_layout

\begin_layout Standard

\family sans
force(code) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
getwd() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "/home/travis/build/hadley/adv-r" 
\end_layout

\begin_layout Standard

\family sans
in_dir("~", getwd()) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "/home/travis"
\end_layout

\begin_layout Standard
The basic pattern is simple:
\end_layout

\begin_layout Enumerate
We first set the directory to a new location, capturing the current location
 from the output of setwd.
\end_layout

\begin_layout Enumerate
We then use 
\family sans
on.exit()
\family default
 to ensure that the working directory is returned to the previous value
 regardless of how the function exits.
\end_layout

\begin_layout Enumerate
Finally, we explicitly force evaluation of the code.
 (We don't actually need 
\family sans
force()
\family default
 here, but it makes it clear to readers what we're doing)
\end_layout

\end_deeper
\begin_layout Itemize
We could use similar code to temporarily set global options:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
with_options <- function(opts, code) { 
\end_layout

\begin_layout Standard

\family sans
old <- options(opts) 
\end_layout

\begin_layout Standard

\family sans
on.exit(options(old))
\end_layout

\begin_layout Standard

\family sans
force(code) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
x <- 0.123456 
\end_layout

\begin_layout Standard

\family sans
print(x) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.1235 
\end_layout

\begin_layout Standard

\family sans
with_options(list(digits = 3), print(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.123 
\end_layout

\begin_layout Standard

\family sans
with_options(list(digits = 1), print(x)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 0.1
\end_layout

\end_deeper
\begin_layout Itemize
We could extract out that commonality with a function operator that takes
 the setter function as an input:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
with_something <- function(set) { 
\end_layout

\begin_layout Standard

\family sans
function(new, code) { 
\end_layout

\begin_layout Standard

\family sans
old <- set(new) 
\end_layout

\begin_layout Standard

\family sans
on.exit(set(old))
\end_layout

\begin_layout Standard

\family sans
force(code) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Itemize
Then we can easily generate a whole set of with functions:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
in_dir <- with_something(setwd) 
\end_layout

\begin_layout Standard

\family sans
with_options <- with_something(options) 
\end_layout

\begin_layout Standard

\family sans
with_par <- with_something(par)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
However, many of the setter functions that affect global state in R don't
 return the previous values in a way that can easily be passed back in.
\end_layout

\begin_layout Itemize
In that case, like for 
\family sans
.libPaths()
\family default
, which controls where R looks for packages to load, we first create a wrapper
 that enforces the behaviour we want, and then use 
\family sans
with_something()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
set_libpaths <- function(paths) { 
\end_layout

\begin_layout Standard

\family sans
libpath <- normalizePath(paths, mustWork = TRUE)
\end_layout

\begin_layout Standard

\family sans
old <- .libPaths() 
\end_layout

\begin_layout Standard

\family sans
.libPaths(paths) 
\end_layout

\begin_layout Standard

\family sans
invisible(old) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
with_libpaths <- with_something(set_libpaths)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family sans
capture.output
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
capture.output()
\family default
 is a useful function when the output you really want from a function is
 printed to the console.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
y <- 1:10 
\end_layout

\begin_layout Standard

\family sans
y_str <- str(y) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> int [1:10] 1 2 3 4 5 6 7 8 9 10
\emph default
 
\end_layout

\begin_layout Standard

\family sans
y_str 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> NULL
\end_layout

\begin_layout Standard

\family sans
y_str <- capture.output(str(y)) 
\end_layout

\begin_layout Standard

\family sans
y_str 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] " int [1:10] 1 2 3 4 5 6 7 8 9 10"
\end_layout

\end_deeper
\begin_layout Itemize
To work its magic, 
\family sans
capture.output()
\family default
 uses 
\family sans
sink()
\family default
, which allows you to redirect the output stream to an arbitrary connection.
\end_layout

\begin_deeper
\begin_layout Itemize
first write a helper function that allows us to execute code in the context
 of a 
\family sans
sink()
\family default
, automatically un-
\family sans
sink()
\family default
ing when the function finishes:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
with_sink <- function(connection, code, ...) { 
\end_layout

\begin_layout Standard

\family sans
sink(connection, ...) 
\end_layout

\begin_layout Standard

\family sans
on.exit(sink())
\end_layout

\begin_layout Standard

\family sans
code 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard

\family sans
with_sink("temp.txt", print("Hello")) 
\end_layout

\begin_layout Standard

\family sans
readLines("temp.txt") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "[1] 
\backslash
"Hello
\backslash
"" 
\end_layout

\begin_layout Standard

\family sans
file.remove("temp.txt") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] TRUE
\end_layout

\end_deeper
\begin_layout Itemize
add a little extra wrapping to our 
\family sans
capture.output2()
\family default
 to write to a temporary file, read from it and clean up after ourselves:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
capture.output2 <- function(code) { 
\end_layout

\begin_layout Standard

\family sans
temp <- tempfile() 
\end_layout

\begin_layout Standard

\family sans
on.exit(file.remove(temp)) 
\end_layout

\begin_layout Standard

\family sans
with_sink(temp, force(code)) 
\end_layout

\begin_layout Standard

\family sans
readLines(temp) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
capture.output2(cat("a", "b", "c", sep = "
\backslash
n")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] "a" "b" "c"
\end_layout

\end_deeper
\begin_layout Itemize
The real 
\family sans
capture.output()
\family default
 is a bit more complicated: it uses a local 
\family sans
textConnection
\family default
 to capture the data sent to 
\family sans
sink,
\family default
 and it allows you to supply multiple expressions which are evaluated in
 turn.
 Using 
\family sans
with_sink()
\family default
 this looks like 
\family sans
capture.output3()
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
capture.output3 <- function(..., env = parent.frame()) { 
\end_layout

\begin_layout Standard

\family sans
txtcon <- textConnection("rval", "w", local = TRUE) 
\end_layout

\begin_layout Standard

\family sans
with_sink(txtcon, { 
\end_layout

\begin_layout Standard

\family sans
args <- dots(...) 
\end_layout

\begin_layout Standard

\family sans
for(i in seq_along(args)) { 
\end_layout

\begin_layout Standard

\family sans
out <- withVisible(eval(args[[i]], env)) 
\end_layout

\begin_layout Standard

\family sans
if (out$visible) print(out$value) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
})
\end_layout

\begin_layout Standard

\family sans
rval
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
If you want to capture more types of output (like messages and warnings),
 you may find the 
\family sans
evaluate
\family default
 package helpful.
 It powers
\family sans
 knitr
\family default
, and does its best to ensure high fidelity between its output and what
 you'd see if you copied and pasted the code at the console.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family sans
\series bold
Evaluating code in a new environment
\end_layout

\begin_deeper
\begin_layout Itemize
In the process of performing a data analysis, you may create variables that
 are necessarily because they help break a complicated sequence of steps
 down in to easily digestible chunks, but are not needed afterwards.
\end_layout

\begin_layout Itemize
It's useful to be able to store only the final result, preventing the intermedia
te results from cluttering your workspace.
 We already know one way of doing this, using a function
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In JavaScript this is called the immediately invoked function expression
 (IIFE), and is used extensively in modern JavaScript to encapsulate different
 JavaScript libraries
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- (function() { 
\end_layout

\begin_layout Standard

\family sans
a <- 10 b <- 30 a + b 
\end_layout

\begin_layout Standard

\family sans
})()
\end_layout

\end_deeper
\begin_layout Itemize
R provides another tool that's a little less verbose, the 
\family sans
local()
\family default
 function:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- local({
\end_layout

\begin_layout Standard

\family sans
a <- 10 b <- 30 a + b 
\end_layout

\begin_layout Standard

\family sans
})
\end_layout

\end_deeper
\begin_layout Itemize
The idea of local is to create a new environment (inheriting from the current
 environment) and run the code in that.
 The essence of 
\family sans
local() 
\family default
is captured in this code:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
local2 <- function(expr) { 
\end_layout

\begin_layout Standard

\family sans
envir <- new.env(parent = parent.frame()) 
\end_layout

\begin_layout Standard

\family sans
eval(substitute(expr), envir) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\end_deeper
\begin_layout Itemize
The real 
\family sans
local()
\family default
 code is considerably more complicated because it adds a second environment
 parameter.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
I don't think this is necessary because if you have an explicit environment
 parameter, then you can already evaluate code in that environment with
 evalq().
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The original code is also hard to understand because it is very concise
 and uses some sutble features of evaluation (including non-standard evaluation
 of both arguments).
 If you have read metaprogramming, you might be able to puzzle it out, but
 to make it a bit easier I have rewritten it in a simpler style below.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
local2 <- function(expr, envir = new.env()) { 
\end_layout

\begin_layout Standard

\family sans
env <- parent.frame() 
\end_layout

\begin_layout Standard

\family sans
call <- substitute(eval(quote(expr), envir))
\end_layout

\begin_layout Standard

\family sans
eval(call, env) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
a <- 100 
\end_layout

\begin_layout Standard

\family sans
local2({ 
\end_layout

\begin_layout Standard

\family sans
b <- a + sample(10, 1) 
\end_layout

\begin_layout Standard

\family sans
my_get <<- function() b 
\end_layout

\begin_layout Standard

\family sans
}) 
\end_layout

\begin_layout Standard

\family sans
my_get() 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> [1] 103
\end_layout

\end_deeper
\begin_layout Itemize
You might wonder we can't simplify to this:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
local3 <- function(expr, envir = new.env()) { 
\end_layout

\begin_layout Standard

\family sans
eval(substitute(expr), envir) 
\end_layout

\begin_layout Standard

\family sans
}
\end_layout

\begin_layout Standard
But it's because of how the arguments are evaluated - default arguments
 are evalauted in the scope of the function so that local(x) would not be
 the same as local(x, new.env()) without special effort.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Anaphoric functions
\end_layout

\begin_layout Itemize
Another variant along these lines is an "
\series bold
anaphoric function
\series default
", or a function that uses a pronoun.
\end_layout

\begin_layout Itemize
Example: 
\family sans
curve()
\family default
 draws a plot of the specified function, but interestingly you don't need
 to use a function, you just supply an expression that uses x:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
curve(x ^ 2)
\end_layout

\begin_layout Standard

\family sans
curve(sin(x), to = 3 * pi)
\end_layout

\begin_layout Standard

\family sans
curve(sin(exp(4 * x)), n = 1000)
\end_layout

\end_deeper
\begin_layout Itemize
Here x plays a role like a pronoun in an English sentence: it doesn't represent
 a single concrete value, but instead is a place holder that varies over
 the range of the plot.
 
\end_layout

\begin_layout Itemize
Note that it doesn't matter what the value of x outside of 
\family sans
curve()
\family default
 is: the expression is evaluated in a special environment where x has a
 special meaning:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
x <- 1 curve(sin(exp(4 * x)), n = 1000)
\end_layout

\end_deeper
\begin_layout Itemize
The essence of 
\family sans
curve()
\family default
, omitting many useful but incidental details like plot labelling, looks
 like this:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
curve2 <- function(expr, xlim = c(0, 1), n = 100, env = parent.frame()) {
 
\end_layout

\begin_layout Standard

\family sans
\series bold
env2 <- new.env(parent = env) 
\end_layout

\begin_layout Standard

\family sans
env2$x <- seq(xlim[1], xlim[2], length = n)
\end_layout

\begin_layout Standard

\family sans
y <- eval(substitute(expr), env2) 
\end_layout

\begin_layout Standard

\family sans
plot(env2$x, y, type = "l", ylab = deparse(substitute(expr))) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
curve2(sin(exp(4 * x)), n = 1000)
\end_layout

\end_deeper
\begin_layout Itemize
Creating a new environment containing the pronoun is the key technique for
 implementing anaphoric functions.
\end_layout

\begin_layout Itemize
Another way to solve the problem would be to 
\bar under
turn the expression into a function
\bar default
 using 
\family sans
make_function()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
curve3 <- function(expr, xlim = c(0, 1), n = 100, env = parent.frame()) {
 
\end_layout

\begin_layout Standard

\family sans
f <- pryr::make_function(alist(x = ), substitute(expr), env)
\end_layout

\begin_layout Standard

\family sans
x <- seq(xlim[1], xlim[2], length = n) 
\end_layout

\begin_layout Standard

\family sans
y <- f(x)
\end_layout

\begin_layout Standard

\family sans
plot(x, y, type = "l", ylab = deparse(substitute(expr))) 
\end_layout

\begin_layout Standard

\family sans
} 
\end_layout

\begin_layout Standard

\family sans
curve3(sin(exp(4 * x)), n = 1000)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family sans
Author: I would have a slight preference for the second because it would
 be easier to reuse the part of the curve3() that turns an expression into
 a function.
 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
All anaphoric functions need careful documentation so that the user knows
 that some variable will have special properties inside the anaphoric function
 and must otherwise be avoided.
\end_layout

\begin_layout Itemize
If you're interesting in learning more, there are some good resources for
 anaphoric functions in Arc (a list like language)
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.arcfn.com/doc/anaphoric.html
\end_layout

\end_inset

, Perl
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.perlmonks.org/index.pl?node_id=666047
\end_layout

\end_inset

 and Clojure
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-pro
fit
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Domain specific languages
\end_layout

\begin_layout Itemize
Embedded DSLs take advantage of a host language's parsing and execution
 framework, but adjust the semantics somewhat to make them more suitable
 for a specific task.
\end_layout

\begin_layout Itemize
R already has a simple and popular DSL built in: the formula specification,
 which offers a succinct way of describing the relationship between predictors
 and the response.
\end_layout

\begin_layout Itemize
Another package that makes extensive use of these ideas is dplyr, which
 provides 
\family sans
translate_sql()
\family default
 to convert R expressions into SQL:
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
library(dplyr) translate_sql(sin(x) + tan(y)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <SQL> SIN("x") + TAN("y") 
\end_layout

\begin_layout Standard

\family sans
translate_sql(x < 5 & !(y >= 5)) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <SQL> "x" < 5.0 AND NOT(("y" >= 5.0)) 
\end_layout

\begin_layout Standard

\family sans
translate_sql(first %like% "Had*") 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <SQL> "first" LIKE 'Had*'
\emph default
 
\end_layout

\begin_layout Standard

\family sans
translate_sql(first %in% c("John", "Roger", "Robert")) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <SQL> "first" IN ('John', 'Roger', 'Robert') 
\end_layout

\begin_layout Standard

\family sans
translate_sql(like == 7) 
\end_layout

\begin_layout Standard

\family sans
\emph on
#> <SQL> "like" = 7.0
\end_layout

\end_deeper
\begin_layout Itemize
An important part of the overall structure of the package is
\family sans
 partial_eval()
\family default
 which helps manage expressions where some of the components refer to variables
 in the database and some refer to local R objects.
 
\end_layout

\begin_layout Itemize
R is well suited for hosting DSLs because the combination of a small amount
 of computing on the language and constructing special evaluation environments
 is very powerful.
 
\end_layout

\begin_layout Itemize
If you're interested in learning more, I highly recommend 
\emph on
Domain Specific Languages
\emph default
 by Martin Fowler: it discusses many options for creating a DSL and provides
 many examples of different languages.
\end_layout

\begin_layout Subsubsection
HTML
\end_layout

\begin_layout Itemize
HTML is the language that underlies the majority of the web.
 It is a special case of SGML, and similar (but not identical) to XML.
\end_layout

\begin_layout Itemize
HTML is composed of tags that look like 
\family sans
<tag></tag>
\family default
.
\end_layout

\begin_layout Itemize
Tags can be contained inside other tags and intermingled with text.
\end_layout

\begin_layout Itemize
Generally, HTML ignores whitespace: an sequence of whitespace is equivalent
 to a single space.
\end_layout

\begin_layout Itemize
There are over 100 HTML tags, but to illustrate HTML we're going to focus
 on just a few:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
<body>
\family default
: the top-level tag that all content is enclosed within 
\end_layout

\begin_layout Itemize

\family sans
<h1>
\family default
: creates a heading-1, the top level heading 
\end_layout

\begin_layout Itemize

\family sans
<p>
\family default
: creates a paragraph 
\end_layout

\begin_layout Itemize

\family sans
<b>
\family default
: emboldens text 
\end_layout

\begin_layout Itemize

\family sans
<img>
\family default
: embeds an image
\end_layout

\end_deeper
\begin_layout Itemize
Two important attributes used on just about every tag are
\family sans
 id
\family default
 and 
\family sans
class
\family default
.
 These are used in conjunction with CSS (cascading style sheets) in order
 to control the style of the document.
\end_layout

\begin_layout Itemize
Some tags, like
\family sans
 <img>
\family default
, can't have any content.
 These are called void tags and have a slightly different syntax: instead
 of writing 
\family sans
<img></img>
\family default
 you write 
\family sans
<img />
\family default
.
 Since they have no content, attributes are more imporant, and img has three
 that are used for almost every image: src (where the image lives), width
 and height.
\end_layout

\begin_layout Itemize
Because 
\family sans
<
\family default
 and 
\family sans
>
\family default
 have special meanings in HTML, you can't write them directly.
 Instead you have to use the HTML escapes 
\family sans
&gt;
\family default
 and 
\family sans
&lt
\family default
;.
 And since those escapes use 
\family sans
&
\family default
, you also have to escape it with 
\family sans
&amp
\family default
; if you want a literal ampersand.
\end_layout

\begin_layout Itemize

\series bold
Goal
\end_layout

\begin_deeper
\begin_layout Itemize
Our goal is to make it easy to generate HTML from R.
 To give a concrete example, we want to generate the following HTML:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

with_html(body(  
\end_layout

\begin_layout Plain Layout

h1("A heading", id = "first"),
\end_layout

\begin_layout Plain Layout

p("Some text &", b("some bold text.")),
\end_layout

\begin_layout Plain Layout

img(src = "myimg.png", width = 100, height = 100)
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the nesting of function calls is the same as the nesting of tags,
 unnamed arguments become the content of the tag, and named arguments become
 the attributes.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Escaping
\end_layout

\begin_deeper
\begin_layout Itemize
The easiest way to do this is to create an S3 class that allows us to distinguis
h between regular text (that needs escaping) and HTML (that doesn't).
\end_layout

\begin_layout Itemize
We then write an escape method that leaves HTML unchanged and escapes the
 special characters (
\family sans
&, <, >
\family default
) in ordinary text.
 We also add a method for lists for convenience
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

html <- function(x) structure(x, class = "html") 
\end_layout

\begin_layout Plain Layout

print.html <- function(x, ...) cat("<HTML> ", x, "
\backslash
n", sep = "") 
\end_layout

\begin_layout Plain Layout

escape <- function(x) UseMethod("escape") 
\end_layout

\begin_layout Plain Layout

escape.html <- function(x) x 
\end_layout

\begin_layout Plain Layout

escape.character <- function(x) {   
\end_layout

\begin_layout Plain Layout

x <- gsub("&", "&amp;", x)   
\end_layout

\begin_layout Plain Layout

x <- gsub("<", "&lt;", x)   
\end_layout

\begin_layout Plain Layout

x <- gsub(">", "&gt;", x)      
\end_layout

\begin_layout Plain Layout

html(x) 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

escape.list <- function(x) {   
\end_layout

\begin_layout Plain Layout

lapply(x, escape.character) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# Now we check that it works 
\end_layout

\begin_layout Plain Layout

escape("This is some text.")
\end_layout

\begin_layout Plain Layout

escape("x > 1 & y < 2")
\end_layout

\begin_layout Plain Layout

# Double escaping is not a problem 
\end_layout

\begin_layout Plain Layout

escape(escape("This is some text.
 1 > 2"))
\end_layout

\begin_layout Plain Layout

# And text we know is HTML doesn't get escaped.
 
\end_layout

\begin_layout Plain Layout

escape(html("<hr />"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Basic tag functions
\end_layout

\begin_deeper
\begin_layout Itemize
HTML tags can have both attributes (e.g.
 id, or class) and children (like <b> or <i>).
\end_layout

\begin_layout Itemize
We need some way of separating these in the function call: since attributes
 are named values and children don't have names, it seems natural to separate
 using named vs.
 unnamed arguments.
 
\end_layout

\begin_layout Itemize
Then a call to p() might look like:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

p("Some text.", b("some bold text"), class = "mypara")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We could list all the possible attributes of the p tag in the function definitio
n, but that's hard because there are so many, and it's possible to use custom
 attributes Instead we'll just use ...
 and separate the components based on whether or not they are named.
 
\end_layout

\begin_layout Itemize
To do this correctly, we need to be aware of a "feature" of 
\family sans
names()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

names(c(a = 1, b = 2))
\end_layout

\begin_layout Plain Layout

names(c(a = 1, 2))
\end_layout

\begin_layout Plain Layout

names(c(1, 2))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
With this in mind we create two helper functions to extract the named and
 unnamed components of a vector:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

named <- function(x) {
\end_layout

\begin_layout Plain Layout

 if (is.null(names(x))) return(NULL)
\end_layout

\begin_layout Plain Layout

x[names(x) != ""]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unnamed <- function(x) {
\end_layout

\begin_layout Plain Layout

if (is.null(names(x))) return(x)
\end_layout

\begin_layout Plain Layout

x[names(x) == ""]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We can now create our 
\family sans
p()
\family default
 function.
 There's one new function here: 
\family sans
html_attributes()
\family default
.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

source("code/html-attributes.r", local = TRUE)
\end_layout

\begin_layout Plain Layout

p <- function(...) {
\end_layout

\begin_layout Plain Layout

args <- list(...)
\end_layout

\begin_layout Plain Layout

attribs <- html_attributes(named(args))
\end_layout

\begin_layout Plain Layout

children <- unlist(escape(unnamed(args)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

html(paste0(
\end_layout

\begin_layout Plain Layout

"<p", attribs, ">",
\end_layout

\begin_layout Plain Layout

paste(children, collapse = ""),
\end_layout

\begin_layout Plain Layout

"</p>"
\end_layout

\begin_layout Plain Layout

 ))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

p("Some text")
\end_layout

\begin_layout Plain Layout

#> [1] "<p>Some text</p>" 
\end_layout

\begin_layout Plain Layout

#> attr(,"class") 
\end_layout

\begin_layout Plain Layout

#> [1] "html"
\end_layout

\begin_layout Plain Layout

p("Some text", id = "myid")
\end_layout

\begin_layout Plain Layout

#> [1] "<p id = 'myid'>Some text</p>" 
\end_layout

\begin_layout Plain Layout

#> attr(,"class") 
\end_layout

\begin_layout Plain Layout

#> [1] "html"
\end_layout

\begin_layout Plain Layout

p("Some text", image = NULL)
\end_layout

\begin_layout Plain Layout

#> [1] "<p image>Some text</p>" 
\end_layout

\begin_layout Plain Layout

#> attr(,"class") 
\end_layout

\begin_layout Plain Layout

#> [1] "html"
\end_layout

\begin_layout Plain Layout

p("Some text", class = "important", "data-value" = 10)
\end_layout

\begin_layout Plain Layout

#> [1] "<p class = 'important' data-value = '10'>Some text</p>" 
\end_layout

\begin_layout Plain Layout

#> attr(,"class") 
\end_layout

\begin_layout Plain Layout

#> [1] "html"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Tag functions
\end_layout

\begin_deeper
\begin_layout Itemize
With this definition of p() it's pretty easy to see what will change for
 different tags: we just need to replace "p" with a variable.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We're forcing the evaluation tag with the expectation we'll be calling this
 function from a loop later on - that avoids potential bugs caused by lazy
 evaluation.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

tag <- function(tag) {   
\end_layout

\begin_layout Plain Layout

	force(tag)   
\end_layout

\begin_layout Plain Layout

	function(...) {     
\end_layout

\begin_layout Plain Layout

	 args <- list(...)     
\end_layout

\begin_layout Plain Layout

	 attribs <- html_attributes(named(args))     
\end_layout

\begin_layout Plain Layout

	 children <- unlist(escape(unnamed(args)))
\end_layout

\begin_layout Plain Layout

		html(paste0(       
\end_layout

\begin_layout Plain Layout

		"<", tag, attribs, ">", 
\end_layout

\begin_layout Plain Layout

		paste(children, collapse = ""),        
\end_layout

\begin_layout Plain Layout

		"</", tag, ">"     
\end_layout

\begin_layout Plain Layout

		))   
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Before we continue to generate functions for every possible HTML tag, we
 need a variant of 
\family sans
tag()
\family default
 for void tags.
 It can be very similar to 
\family sans
tag()
\family default
, but needs to throw an error if there are any unnamed tags, and the tag
 itself looks slightly different:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

void_tag <- function(tag) {   
\end_layout

\begin_layout Plain Layout

force(tag)   
\end_layout

\begin_layout Plain Layout

function(...) {     
\end_layout

\begin_layout Plain Layout

args <- list(...)     
\end_layout

\begin_layout Plain Layout

if (length(unnamed(args)) > 0) {       
\end_layout

\begin_layout Plain Layout

stop("Tag ", tag, " can not have children", call.
 = FALSE)     
\end_layout

\begin_layout Plain Layout

}     
\end_layout

\begin_layout Plain Layout

attribs <- html_attributes(named(args))          html(paste0("<", tag, attribs,
 " />"))   
\end_layout

\begin_layout Plain Layout

} }
\end_layout

\begin_layout Plain Layout

img <- void_tag("img") 
\end_layout

\begin_layout Plain Layout

img(src = "myimage.png", width = 100, height = 100)
\end_layout

\begin_layout Plain Layout

#> [1] "<img src = 'myimage.png' width = '100' height = '100' />" 
\end_layout

\begin_layout Plain Layout

#> attr(,"class") 
\end_layout

\begin_layout Plain Layout

#> [1] "html"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Processing all tags 
\end_layout

\begin_deeper
\begin_layout Itemize
Next we need a list of all the HTML tags:
\end_layout

\end_deeper
\begin_layout Subsubsection
LaTeX
\end_layout

\begin_layout Itemize
LaTeX mathematics are complex, and well documented.
 They have a fairly simple structure:
\end_layout

\begin_deeper
\begin_layout Itemize
Most simple mathematical equations are represented in the way you'd type
 them into R: x * y, z ^ 5.
 Subscripts are written using _, e.g.
 x_1.
\end_layout

\begin_layout Itemize
Special characters start with a 
\backslash
: 
\backslash
pi = , 
\backslash
pm = , and so on.
 There are a huge number of symbols available in LaTeX.
 Googling for latex math symbols finds many lists, and there's even a service
 where you can sketch a symbol in the browser and it will look it up for
 you.
\end_layout

\begin_layout Itemize
More complicated functions look like 
\backslash
name{arg1}{arg2}.
 For example to represent a fraction you use 
\backslash
frac{a}{b}, and a sqrt looks like 
\backslash
sqrt{a}.
\end_layout

\begin_layout Itemize
To group elements together use {}: i.e.
 x ^ a + b vs.
 x ^ {a + b}
\end_layout

\begin_layout Itemize
In good math typesetting, a distinction is made between variables and functions,
 but without extra information, LaTeX doesn't know whether f(a * b) represents
 calling the function f with argument a * b, or is shorthand for f * a *
 b.
 If f is a function, you can tell LaTeX to typeset it using an upright font
 with
\family sans
 
\backslash
textrm{f}(a * b)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Goal
\end_layout

\begin_deeper
\begin_layout Itemize
Our goal is to use these rules to automatically convert from an R expression
 to a LaTeX representation of that expression.
 We will tackle it in four stages:
\end_layout

\begin_deeper
\begin_layout Enumerate
Convert known symbols: pi -> 
\backslash
pi
\end_layout

\begin_layout Enumerate
Leave other symbols unchanged: x -> x, y -> y
\end_layout

\begin_layout Enumerate
Convert known functions: x * pi -> x * 
\backslash
pi, sqrt(frac(a, b)) -> 
\backslash
sqrt{
\backslash
frac{a, b}}
\end_layout

\begin_layout Enumerate
Wrap unknown functions with 
\backslash
textrm: f(a) -> 
\backslash
textrm{f}(a)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
to_math
\end_layout

\begin_deeper
\begin_layout Itemize
To begin, we need a wrapper function that we'll use to convert R expressions
 into LaTeX math expressions.
\end_layout

\begin_layout Itemize
This works the same way as to_html: we capture the unevaluated expression
 and evaluate it in a special environment.
\end_layout

\begin_layout Itemize
However, the special environment is no longer fixed, and will vary depending
 on the expression.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

to_math <- function(x) {   
\end_layout

\begin_layout Plain Layout

expr <- substitute(x)   
\end_layout

\begin_layout Plain Layout

eval(expr, latex_env(expr)) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Known symbols
\end_layout

\begin_deeper
\begin_layout Itemize
Our first step is to create an environment that allows us to convert the
 special LaTeX symbols used for Greek, e.g.
 pi to 
\backslash
pi.
\end_layout

\begin_layout Itemize
First we create than environment by creating a named vector, converting
 that vector into a list, and then turn that list into an environment.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

greek <- c(   "alpha", "theta", "tau", "beta", "vartheta", "pi", "upsilon",
    "gamma", "gamma", "varpi", "phi", "delta", "kappa", "rho",    "varphi",
 "epsilon", "lambda", "varrho", "chi", "varepsilon",    "mu", "sigma", "psi",
 "zeta", "nu", "varsigma", "omega", "eta",    "xi", "Gamma", "Lambda", "Sigma",
 "Psi", "Delta", "Xi", "Upsilon",    "Omega", "Theta", "Pi", "Phi")
\end_layout

\begin_layout Plain Layout

greek_list <- setNames(paste0("
\backslash

\backslash
", greek), greek)
\end_layout

\begin_layout Plain Layout

greek_env <- list2env(as.list(greek_list), parent = emptyenv())
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Now we can check it
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

to_math <- function(x) {   
\end_layout

\begin_layout Plain Layout

expr <- substitute(x)   
\end_layout

\begin_layout Plain Layout

eval(expr, latex_env(expr)) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

latex_env <- function(expr) {   
\end_layout

\begin_layout Plain Layout

greek_env }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

to_math(pi)
\end_layout

\begin_layout Plain Layout

to_math(beta)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Unknown symbols
\end_layout

\begin_deeper
\begin_layout Itemize
If a symbol isn't greek, we want to leave it as is.
 This is trickier because we don't know in advance what symbols will be
 used, and we can't possibly generate them all.
\end_layout

\begin_layout Itemize
So we'll use a little bit of computing on the language to find out what
 symbols are present in an expression.
 
\end_layout

\begin_layout Itemize
The 
\family sans
all_names
\family default
 function takes an expression: if it's a name, it converts it to a string;
 if it's a call, it recurses down through its arguments.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

all_names <- function(x) {
\end_layout

\begin_layout Plain Layout

# Base cases
\end_layout

\begin_layout Plain Layout

if (is.name(x)) return(as.character(x))
\end_layout

\begin_layout Plain Layout

if (!is.call(x)) return(NULL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Recursive case
\end_layout

\begin_layout Plain Layout

children <- lapply(x[-1], all_names)
\end_layout

\begin_layout Plain Layout

unique(unlist(children))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

all_names(quote(x + y + f(a, b, c, 10)))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We now want to take that list of symbols, and convert it to an environment
 so that each symbol is mapped to a string representing itself (e.g.
 so 
\family sans
eval(quote(x), env) yields "x"
\family default
).
 We again use the pattern of converting a named character vector to a list,
 then an environment.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

latex_env <- function(expr) {
\end_layout

\begin_layout Plain Layout

names <- all_names(expr)
\end_layout

\begin_layout Plain Layout

symbol_list <- setNames(as.list(names), names)
\end_layout

\begin_layout Plain Layout

symbol_env <- list2env(symbol_list)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

symbol_env
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

to_math(x)
\end_layout

\begin_layout Plain Layout

to_math(longvariablename)
\end_layout

\begin_layout Plain Layout

to_math(pi)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This works, but we need to combine it with the enviroment of the Greek symbols.
 Since we want to prefer Greek to the defaults (e.g.
 
\family sans
to_math(pi)
\family default
 should give 
\family sans
"
\backslash

\backslash
pi"
\family default
, not 
\family sans
"pi"
\family default
), 
\family sans
\bar under
symbol_env
\family default
 needs to be the parent of 
\family sans
greek_env
\family default
\bar default
, and thus we need to make a copy of greek_env with a new parent.
 
\end_layout

\begin_layout Itemize
Strangely R doesn't come with a function for cloning environments, but we
 can easily create one by combining two existing functions:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

clone_env <- function(env, parent = parent.env(env)) {
\end_layout

\begin_layout Plain Layout

list2env(as.list(env), parent = parent)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This gives us a function that can convert both known (Greek) and unknown
 symbols.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

latex_env <- function(expr) {
\end_layout

\begin_layout Plain Layout

# Unknown symbols
\end_layout

\begin_layout Plain Layout

names <- all_names(expr)
\end_layout

\begin_layout Plain Layout

symbol_list <- setNames(as.list(names), names)
\end_layout

\begin_layout Plain Layout

symbol_env <- list2env(symbol_list)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Known symbols
\end_layout

\begin_layout Plain Layout

clone_env(greek_env, symbol_env)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

to_math(x)
\end_layout

\begin_layout Plain Layout

to_math(longvariablename)
\end_layout

\begin_layout Plain Layout

to_math(pi)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Known functions
\end_layout

\begin_deeper
\begin_layout Itemize
We'll start with a couple of helper closures that make it easy to add new
 unary and binary operators.
 These functions are very simple since they only have to assemble strings.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

unary_op <- function(left, right) {
\end_layout

\begin_layout Plain Layout

force(left)
\end_layout

\begin_layout Plain Layout

force(right)
\end_layout

\begin_layout Plain Layout

function(e1) {
\end_layout

\begin_layout Plain Layout

paste0(left, e1, right)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

binary_op <- function(sep) {
\end_layout

\begin_layout Plain Layout

force(sep)
\end_layout

\begin_layout Plain Layout

function(e1, e2) {
\end_layout

\begin_layout Plain Layout

paste0(e1, sep, e2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Using these helpers, we can map a few illustrative examples from R to LaTeX.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# Binary operators
\end_layout

\begin_layout Plain Layout

f_env <- new.env(parent = emptyenv())
\end_layout

\begin_layout Plain Layout

f_env$"+" <- binary_op(" + ")
\end_layout

\begin_layout Plain Layout

f_env$"-" <- binary_op(" - ")
\end_layout

\begin_layout Plain Layout

f_env$"^" <- binary_op("^")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Grouping
\end_layout

\begin_layout Plain Layout

f_env$"{" <- unary_op("
\backslash

\backslash
left{ ", " 
\backslash

\backslash
right}")
\end_layout

\begin_layout Plain Layout

f_env$"(" <- unary_op("
\backslash

\backslash
left( ", " 
\backslash

\backslash
right)")
\end_layout

\begin_layout Plain Layout

f_env$paste <- paste
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Other math functions 
\end_layout

\begin_layout Plain Layout

f_env$sqrt <- unary_op("
\backslash

\backslash
sqrt{", "}")
\end_layout

\begin_layout Plain Layout

f_env$sin <- unary_op("
\backslash

\backslash
sin(", ")")
\end_layout

\begin_layout Plain Layout

f_env$log <- unary_op("
\backslash

\backslash
log(", ")")
\end_layout

\begin_layout Plain Layout

f_env$frac <- function(a, b) {
\end_layout

\begin_layout Plain Layout

paste0("
\backslash

\backslash
frac{", a, "}{", b, "}") 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Labelling
\end_layout

\begin_layout Plain Layout

f_env$hat <- unary_op("
\backslash

\backslash
hat{", "}")
\end_layout

\begin_layout Plain Layout

f_env$tilde <- unary_op("
\backslash

\backslash
tilde{", "}")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We again modify 
\family sans
latex_env()
\family default
 to include this environment.
 It should be 
\bar under
the last
\bar default
 environment in which names are looked for, so that 
\family sans
sin(sin) 
\family default
works.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

latex_env <- function(expr) {
\end_layout

\begin_layout Plain Layout

# Known functions
\end_layout

\begin_layout Plain Layout

f_env
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Default symbols
\end_layout

\begin_layout Plain Layout

names <- all_names(expr)
\end_layout

\begin_layout Plain Layout

symbol_list <- setNames(as.list(names), names)
\end_layout

\begin_layout Plain Layout

symbol_env <- list2env(symbol_list, parent = f_env)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Known symbols
\end_layout

\begin_layout Plain Layout

greek_env <- clone_env(greek_env, parent = symbol_env)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

to_math(sin(x + pi))
\end_layout

\begin_layout Plain Layout

to_math(log(x_i ^ 2))
\end_layout

\begin_layout Plain Layout

to_math(sin(sin))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Unknown functions
\end_layout

\begin_deeper
\begin_layout Itemize
Finally, we'll add a default for functions that we don't know about.
 Like the unknown names, we can't know in advance what these will be, so
 we again use a little computing on the language to figure them out:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

all_calls <- function(x) {
\end_layout

\begin_layout Plain Layout

# Base name
\end_layout

\begin_layout Plain Layout

if (!is.call(x)) return(NULL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Recursive case
\end_layout

\begin_layout Plain Layout

fname <- as.character(x[[1]])
\end_layout

\begin_layout Plain Layout

children <- lapply(x[-1], all_calls)
\end_layout

\begin_layout Plain Layout

unique(c(fname, unlist(children, use.names = FALSE)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

all_calls(quote(f(g + b, c, d(a))))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
And we need a closure that will generate the functions for each unknown
 call
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

unknown_op <- function(op) {
\end_layout

\begin_layout Plain Layout

force(op)
\end_layout

\begin_layout Plain Layout

function(...) {
\end_layout

\begin_layout Plain Layout

contents <- paste(..., collapse = ", ")
\end_layout

\begin_layout Plain Layout

paste0("
\backslash

\backslash
mathrm{", op, "}(", contents, ")")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
And again we update 
\family sans
latex_env()
\family default
:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

latex_env <- function(expr) {
\end_layout

\begin_layout Plain Layout

calls <- all_calls(expr)
\end_layout

\begin_layout Plain Layout

call_list <- setNames(lapply(calls, unknown_op), calls)
\end_layout

\begin_layout Plain Layout

call_env <- list2env(call_list)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Known functions
\end_layout

\begin_layout Plain Layout

f_env <- clone_env(f_env, call_env)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Default symbols
\end_layout

\begin_layout Plain Layout

symbols <- all_names(expr)
\end_layout

\begin_layout Plain Layout

symbol_list <- setNames(as.list(symbols), symbols)
\end_layout

\begin_layout Plain Layout

symbol_env <- list2env(symbol_list, parent = f_env)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Known symbols
\end_layout

\begin_layout Plain Layout

greek_env <- clone_env(greek_env, parent = symbol_env)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

to_math(f(a * b))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Performant Code
\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Itemize
R is not a fast computer language.
 This is not an accident: R has been thoughtfully designed to make it easier
 for you to solve data analysis and statistics challenges, not to make your
 computer's life easier.
\end_layout

\begin_layout Subsubsection
Why is R slow?
\end_layout

\begin_layout Itemize
To understand R's performance it helps to think about R in two ways: as
 a 
\bar under
language
\bar default
 and an
\bar under
 implementation
\bar default
.
\end_layout

\begin_layout Itemize
The R-language is abstract.
 It defines what R code means and how it should work.
\end_layout

\begin_layout Itemize
An implementation is concrete: you give it R code and it computes the result.
\end_layout

\begin_layout Itemize
R has the R language definition, but it is informal and incomplete: the
 R-language is mostly defined in terms of how GNU-R works.
\end_layout

\begin_layout Itemize
Even though the distinction between R-language and GNU-R isn't clear cut,
 it's still useful because poor performance due to the implementation can
 be fixed relatively easily, while poor performance related to the language
 is hard to fix without changing what R code means.
\end_layout

\begin_layout Itemize
While language design constrains the maximum possible performance, GNU-R
 is currently far from the optimum.
\end_layout

\begin_layout Itemize
As well as performance limitations imposed by the language design and current
 implementation, a lot of R code is slow because it's poorly written.
 
\end_layout

\begin_layout Subsubsection
Microbenchmarking
\end_layout

\begin_layout Itemize
A 
\series bold
microbenchmark
\series default
 is a performance measurement of a very small piece of code, something that
 might take microseconds (s) or nanoseconds (ns) to run.
\end_layout

\begin_layout Itemize
the small times in microbenchmarks are typically dominated by higher-order
 effects in real code.
 Don't change the way you code because of these microbenchmarks; instead
 wait until the next chapter to see how to improve the performance of real
 code.
\end_layout

\begin_layout Itemize
The best tool for microbenchmarking in R is the 
\series bold
microbenchmark
\series default
 package.
 It provides very precise timings and makes it possible to compare operations
 that only take a tiny amount of time.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(microbenchmark)
\end_layout

\begin_layout Plain Layout

x <- runif(100)
\end_layout

\begin_layout Plain Layout

microbenchmark(
\end_layout

\begin_layout Plain Layout

sqrt(x),
\end_layout

\begin_layout Plain Layout

x ^ 0.5
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To help calibrate the impact of a microbenchmark on run time, it's useful
 to think about how many times a function needs to run before it takes a
 second.
 If a microbenchmark takes:
\end_layout

\begin_deeper
\begin_layout Itemize
1 ms, then one thousand calls takes a second 
\end_layout

\begin_layout Itemize
1 s, then one million calls takes a second 
\end_layout

\begin_layout Itemize
1 ns, then one billion calls takes a second 
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
microbenchmark()
\family default
 takes multiple expressions as input, and displays summaries of the distribution
 of times.
 
\end_layout

\begin_layout Subsubsection
Language performance
\end_layout

\begin_layout Itemize
You can't benchmark a language, since it's an abstract construct, so the
 benchmarks are only suggestive of the cost of these decisions to the language,
 but are nevertheless useful.
 
\end_layout

\begin_layout Itemize
Designing a useful language is a delicate balancing act.
 There are many options and many tradeoffs, and you need to balance between
 speed, flexibility and ease of implementation.
\end_layout

\begin_layout Itemize
If you'd like to learn more about the performance characteristics of the
 R-language and how they affect real code, I highly recommend
\emph on
 Evaluating the Design of the R Language
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.cs.purdue.edu/homes/jv/pubs/ecoop12.pdf
\end_layout

\end_inset


\emph default
 It discusses a powerful methodology for understanding the performance character
istics of GNU-R using a modified R interpreter and a wide set of code found
 in the wild.
\end_layout

\end_inset


\emph default
 by Floreal Morandat, Brandon Hill, Leo Osvald and Jan Vitek.
 
\end_layout

\begin_layout Itemize

\series bold
Extreme dynamism
\end_layout

\begin_deeper
\begin_layout Itemize
R is an extremely dynamic programming language, and almost anything can
 be modified after it is created.
\end_layout

\begin_deeper
\begin_layout Itemize
change the body, arguments and environment of functions 
\end_layout

\begin_layout Itemize
change the S4 methods for a generic 
\end_layout

\begin_layout Itemize
add new fields to an S3 object, or even change its class 
\end_layout

\begin_layout Itemize
modify objects outside of the local environment with <<-
\end_layout

\end_deeper
\begin_layout Itemize
Pretty much the only thing you can't change are objects in sealed namespaces.
 After a package is loaded its namespace is sealed and it is harder (although
 still not impossible) to change objects defined by the package.
\end_layout

\begin_layout Itemize
The advantage of dynamism is that you don't need to do upfront planning,
 and you don't need an initial compilation step.
 You can change your mind at any point, iterating you way to a solution
 without having to start afresh.
\end_layout

\begin_layout Itemize
The disadvantage of dynamism is that it makes it difficult to predict exactly
 what will happen for a given function call.
 
\end_layout

\begin_layout Itemize
If an interpreter can't predict what's going to happen, it has to look through
 many options to find the right one, a slow operation.
\end_layout

\begin_layout Itemize
For example, code like the following loop is slow in R, because R can't
 know that the type of x never changes.
 That means R has to look for the right + method (e.g.
 is it adding doubles, or integers) in every iteration of the loop.
 The cost of finding the right method is higher for non-primitive functions.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- 0L
\end_layout

\begin_layout Plain Layout

for (i in 1:1e6) {
\end_layout

\begin_layout Plain Layout

x <- x + 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The following microbenchmark illustrates the cost of method dispatch for
 S3, S4, and RC.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

f <- function(x) NULL
\end_layout

\begin_layout Plain Layout

s3 <- function(x) UseMethod("s3")
\end_layout

\begin_layout Plain Layout

s3.integer <- f
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A <- setClass("A", representation(a = "list"))
\end_layout

\begin_layout Plain Layout

setGeneric("s4", function(x) standardGeneric("s4"))
\end_layout

\begin_layout Plain Layout

setMethod(s4, "A", f)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

B <- setRefClass("B", methods = list(rc = f))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- A()
\end_layout

\begin_layout Plain Layout

b <- B$new()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

microbenchmark(
\end_layout

\begin_layout Plain Layout

fun = f(),
\end_layout

\begin_layout Plain Layout

S3 = s3(1L),
\end_layout

\begin_layout Plain Layout

S4 = s4(a),
\end_layout

\begin_layout Plain Layout

RC = b$rc()
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

#> Unit: nanoseconds 
\end_layout

\begin_layout Plain Layout

#>  expr    min     lq median     uq       max neval 
\end_layout

\begin_layout Plain Layout

#>   fun    432    595    662    762     1,340   100 
\end_layout

\begin_layout Plain Layout

#>    S3  5,390  6,000  6,550  6,820    40,300   100 
\end_layout

\begin_layout Plain Layout

#>    S4 26,700 28,100 28,900 29,700   109,000   100 
\end_layout

\begin_layout Plain Layout

#>    RC 30,000 31,300 32,100 33,000 1,150,000   100
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
the function call takes about 280 ns.
 S3 method dispatch takes an additional 3,000 ns; S4 dispatch, 13,000 ns;
 and RC dispatch, 11,000 ns.
 S3 and S4 method dispatch is so expensive because R must search for the
 right method every time the generic is called; it might have changed between
 this call and the last.
\end_layout

\begin_layout Itemize
R could do better by caching methods between calls, but caching is hard
 to do correctly and a notorious source of bugs.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Name lookup with mutable environments
\end_layout

\begin_deeper
\begin_layout Itemize
It's surprisingly difficult to find the value associated with a name in
 the R-language because of the combination of lexical scoping and extreme
 dynamism.
\end_layout

\begin_layout Itemize
Take the following example.
 Each time we print a it comes from a different environment:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a <- 1
\end_layout

\begin_layout Plain Layout

f <- function() {
\end_layout

\begin_layout Plain Layout

g <- function() {
\end_layout

\begin_layout Plain Layout

print(a)
\end_layout

\begin_layout Plain Layout

assign("a", 2, envir = parent.frame())
\end_layout

\begin_layout Plain Layout

print(a)
\end_layout

\begin_layout Plain Layout

a <- 3
\end_layout

\begin_layout Plain Layout

print(a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

f()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This means that you can't rely on the binding associated with a name being
 in the same place as it was last time you looked: you have to start from
 scratch each time.
 
\end_layout

\begin_layout Itemize
Since many basic functions are in the base environment, R has to look through
 every environment on the search path, which could easily be 10 or 20 environmen
ts.
\end_layout

\begin_layout Itemize
The following microbenchmark hints at the performance costs.
 We create four versions of f(), each with one more environment (containing
 26 bindings) between the environment of f() and the base environment where
 +, ^, (, and { are defined.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

random_env <- function(parent = globalenv()) {
\end_layout

\begin_layout Plain Layout

letter_list <- setNames(as.list(runif(26)), LETTERS)
\end_layout

\begin_layout Plain Layout

list2env(letter_list, envir = new.env(parent = parent)) 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

set_env <- function(f, e) {   
\end_layout

\begin_layout Plain Layout

environment(f) <- e   
\end_layout

\begin_layout Plain Layout

f 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

f2 <- set_env(f, random_env()) 
\end_layout

\begin_layout Plain Layout

f3 <- set_env(f, random_env(environment(f2))) 
\end_layout

\begin_layout Plain Layout

f4 <- set_env(f, random_env(environment(f3)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

microbenchmark(   
\end_layout

\begin_layout Plain Layout

f(1, 2),   
\end_layout

\begin_layout Plain Layout

f2(1, 2),   
\end_layout

\begin_layout Plain Layout

f3(1, 2),   
\end_layout

\begin_layout Plain Layout

f4(1, 2),   
\end_layout

\begin_layout Plain Layout

times = 1000 
\end_layout

\begin_layout Plain Layout

) 
\end_layout

\begin_layout Plain Layout

#> Unit: nanoseconds 
\end_layout

\begin_layout Plain Layout

#>      expr   min    lq median    uq    max neval 
\end_layout

\begin_layout Plain Layout

#>   f(1, 2) 2,500 3,250  3,370 3,520 45,400  1000 
\end_layout

\begin_layout Plain Layout

#>  f2(1, 2) 1,770 2,430  2,540 2,680 14,800  1000 
\end_layout

\begin_layout Plain Layout

#>  f3(1, 2) 1,930 2,550  2,660 2,770 10,600  1000 
\end_layout

\begin_layout Plain Layout

#>  f4(1, 2) 2,030 2,690  2,810 2,940 11,900  1000
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each additional environment between 
\family sans
f()
\family default
 and the base environment makes the function slower by about 50ns.
\end_layout

\end_deeper
\begin_layout Itemize
It might be possible to implement a caching system so that R only needs
 to look up the value of each name once.
 This is hard because there are so many ways to change the value associated
 with a name: 
\family sans
<<-, assign(), eval()
\family default
, ...
 
\end_layout

\begin_layout Itemize
Any caching system would have to connect to each of these tools to make
 sure the cache was correctly invalidated and you didn't get an old (incorrect)
 value.
\end_layout

\begin_layout Itemize
Another simple fix would be to add more built in constants that you can't
 override.
 This, for example, would mean that you always know exactly what +, -, {
 and ( mean, and you don't need to repeatedly look up their definitions.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Lazy evaluation overhead
\end_layout

\begin_deeper
\begin_layout Itemize
In R, functions arguments are evaluated lazily (as discussed in lazy evaluation
 and capturing expressions).
\end_layout

\begin_layout Itemize
To implement lazy evaluation, R uses a promise object that contains the
 expression needed to compute the result, and the environment in which to
 perform the computation.
 
\end_layout

\begin_layout Itemize
Creating these objects has some overhead, so 
\family sans
every
\family default
 additional argument to an R function slows it down a little.
\end_layout

\begin_layout Itemize
The following microbenchmark compares the run time of a very simple function.
 Each version of the function has one extra argument.
 This suggests that each additional argument slows the function down by
 20 ns.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

f0 <- function() NULL
\end_layout

\begin_layout Plain Layout

f1 <- function(a = 1) NULL
\end_layout

\begin_layout Plain Layout

f2 <- function(a = 1, b = 1) NULL
\end_layout

\begin_layout Plain Layout

f3 <- function(a = 1, b = 2, c = 3) NULL
\end_layout

\begin_layout Plain Layout

f4 <- function(a = 1, b = 2, c = 4, d = 4) NULL
\end_layout

\begin_layout Plain Layout

f5 <- function(a = 1, b = 2, c = 4, d = 4, e = 5) NULL
\end_layout

\begin_layout Plain Layout

microbenchmark(f0(), f1(), f2(), f3(), f4(), f5(), times = 1000)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In most other programming languages there is little overhead for adding
 extra arguments.
 Many compiled languages will even warn you if arguments are never used
 (like in the above example), and automatically remove them from the function.
\end_layout

\end_deeper
\begin_layout Subsubsection
Implementation performance
\end_layout

\begin_layout Itemize
The design of R-language limits its maximum theoretical performance.
 But GNU-R is currently nowhere close to that maximum, and there are many
 things that can (and will) be done to speed it up.
\end_layout

\begin_layout Itemize

\series bold
Extracting a single value from a data frame
\end_layout

\begin_deeper
\begin_layout Itemize
The following microbenchmark shows seven ways to access a single value (the
 number in the bottom-right corner) from the built-in mtcars dataset.
 
\end_layout

\begin_layout Itemize
The variation in performance is startling: 
\end_layout

\begin_layout Itemize
There's no reason for there to be such a huge difference in performance,
 but no one has spent the time to make the slowest methods faster.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

microbenchmark(
\end_layout

\begin_layout Plain Layout

mtcars[32, 11],
\end_layout

\begin_layout Plain Layout

mtcars[[c(11,32)]],
\end_layout

\begin_layout Plain Layout

mtcars[[11]][32],
\end_layout

\begin_layout Plain Layout

mtcars$carb[32]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family sans
ifelse(), pmin(),
\family default
 and 
\family sans
pmax()
\family default
.
\end_layout

\begin_deeper
\begin_layout Itemize
the following three implementations of a function to 
\family sans
squish()
\family default
 a vector to ensure that the smallest value is at least a and the largest
 value is at most b.
\end_layout

\begin_layout Itemize

\family sans
squish_ife()
\family default
 uses 
\family sans
ifelse()
\family default
.
 
\family sans
ifelse()
\family default
 is known to be slow because it is relatively general, and must evaluate
 all arguments fully.
 
\end_layout

\begin_layout Itemize

\family sans
squish_p()
\family default
, uses
\family sans
 pmin()
\family default
 and 
\family sans
pmax()
\family default
 which should be much faster because they're so specialised.
 But they're actually rather slow because they can take any number of arguments
 and have to do some relatively complicated checks to determine which method
 to use.
 
\end_layout

\begin_layout Itemize
The final implementation uses basic subassignment.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

squish_ife <- function(x, a, b) {
\end_layout

\begin_layout Plain Layout

ifelse(x <= a, a, ifelse(x >= b, b, x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

squish_p <- function(x, a, b) {
\end_layout

\begin_layout Plain Layout

pmax(pmin(x, b), a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

squish_in_place <- function(x, a, b) {
\end_layout

\begin_layout Plain Layout

x[x <= a] <- a
\end_layout

\begin_layout Plain Layout

x[x >= b] <- b
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x <- runif(100, -1.5, 1.5)
\end_layout

\begin_layout Plain Layout

microbenchmark(
\end_layout

\begin_layout Plain Layout

squish_ife(x, -1, 1),
\end_layout

\begin_layout Plain Layout

squish_p(x, -1, 1),
\end_layout

\begin_layout Plain Layout

squish_in_place(x, -1, 1)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
There's quite a variation in speed: using 
\family sans
pmin()
\family default
 and 
\family sans
pmax()
\family default
 is about 3x faster than using 
\family sans
ifelse()
\family default
, and using subsetting directly is about twice as fast again.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#include <Rcpp.h>
\end_layout

\begin_layout Plain Layout

using namespace Rcpp;
\end_layout

\begin_layout Plain Layout

// [[Rcpp::export]]
\end_layout

\begin_layout Plain Layout

NumericVector squish_cpp(NumericVector x, double a, double b) {
\end_layout

\begin_layout Plain Layout

int n = x.length();
\end_layout

\begin_layout Plain Layout

NumericVector out(n);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (int i = 0; i < n; ++i) {
\end_layout

\begin_layout Plain Layout

double xi = x[i];
\end_layout

\begin_layout Plain Layout

if (xi < a) {
\end_layout

\begin_layout Plain Layout

out[i] = a;
\end_layout

\begin_layout Plain Layout

} else if (xi > b) {
\end_layout

\begin_layout Plain Layout

out[i] = b;
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

out[i] = xi;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return out;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

microbenchmark(
\end_layout

\begin_layout Plain Layout

squish_in_place(x, -1, 1),
\end_layout

\begin_layout Plain Layout

squish_cpp(x, -1, 1)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Alternative R implementations
\end_layout

\begin_layout Itemize
The four most mature open-source projects are: (These are roughly ordered
 in from most practical to most ambitious.
 )
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
pqR
\series default
 (pretty quick R), by Radford Neal.
 It's built on top of the existing R code base (2.15.0), and fixes many obvious
 performance issues.
 It provides better memory management, and some support for automatic multithrea
ding.
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.pqr-project.org
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Renjin
\series default
 by BeDataDriven.
 Renjin uses the java virtual machine, and has an extensive test suite.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.renjin.org/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
fastr,
\series default
 by a team from Purdue.
 fastr is similar to Renjin, but it makes more ambitious optimisations and
 is somewhat less mature.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/allr/fastr
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Riposte
\series default
, by Justin Talbot and Zachary DeVito.
 Riposte is experimental and ambitious, and for the parts of R it implements
 is extremely fast.
 Riposte is described in more detail in Riposte: A Trace-Driven Compiler
 and Parallel VM for Vector Code in R.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/jtalbot/riposte
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
However, even if these implementations never make a dent in the use of GNU-R,
 they have other benefits:
\end_layout

\begin_deeper
\begin_layout Itemize
Simpler implementations make it easy to validate new approaches before porting
 to GNU-R.
\end_layout

\begin_layout Itemize
Gain understanding about which aspects of language could be changed with
 minimal impact to existing code and maximal impact on performance.
\end_layout

\begin_layout Itemize
Alternative implementations put pressure on the R-core to incorporate performanc
e improvements.
\end_layout

\end_deeper
\begin_layout Itemize
One of the most important approaches that pqR, renjin, fastR and riposte
 are exploring is the idea of deferred evaluation.
\end_layout

\begin_layout Itemize
As Justin Talbot, the author of riposte, points out "for long vectors, R's
 execution is 
\bar under
completely memory bound
\bar default
.
 It spends almost all of its time reading and writing vector intermediates
 to memory".
 If you can eliminate intermediate vectors, you can not only decrease memory
 usage, you can also considerably improve performance.
\end_layout

\begin_layout Itemize
The following example shows a very simple example of where deferred evaluation
 might help.
 We have three vectors, x, y, z each containing 1 million elements, and
 we want to find the sum of x + y where z is TRUE.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- runif(1e6)
\end_layout

\begin_layout Plain Layout

y <- runif(1e6)
\end_layout

\begin_layout Plain Layout

z <- sample(c(T, F), 1e6, rep = TRUE)
\end_layout

\begin_layout Plain Layout

#sum((x + y)[z])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In R, this creates two big temporary vectors: 
\family sans
x + y
\family default
, 1 million elements long, and 
\family sans
(x + y)[z]
\family default
, about 500,000 elements long.
 This means you need to have extra memory free for the intermediate calculation,
 and you have to shuttle the data back and forth between the CPU and memory.
 This slows computation down because the CPU can't work at maximum efficiency
 if it's always waiting for more data to come in.
\end_layout

\begin_layout Itemize
If we rewrote the function using a loop in a language like C++, we could
 recognise that we only need one intermediate value: the sum of all the
 values we've seen:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#include <Rcpp.h>
\end_layout

\begin_layout Plain Layout

using namespace Rcpp;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// [[Rcpp::export]] double cond_sum_cpp(NumericVector x, NumericVector y,
 LogicalVector z) {
\end_layout

\begin_layout Plain Layout

double sum = 0;
\end_layout

\begin_layout Plain Layout

int n = x.length();
\end_layout

\begin_layout Plain Layout

  for(int i = 0; i < n; i++) {
\end_layout

\begin_layout Plain Layout

if (!z[i]) continue;
\end_layout

\begin_layout Plain Layout

sum += x[i] + y[i];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  return sum;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cond_sum_r <- function(x, y, z) {
\end_layout

\begin_layout Plain Layout

sum((x + y)[z])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

microbenchmark(
\end_layout

\begin_layout Plain Layout

cond_sum_cpp(x, y, z),
\end_layout

\begin_layout Plain Layout

cond_sum_r(x, y, z),
\end_layout

\begin_layout Plain Layout

unit = "ms" ) 
\end_layout

\begin_layout Plain Layout

#> Unit: milliseconds 
\end_layout

\begin_layout Plain Layout

#>                   expr  min    lq median    uq  max neval 
\end_layout

\begin_layout Plain Layout

#>  cond_sum_cpp(x, y, z)  7.5  7.76   7.97  8.53 10.4   100 
\end_layout

\begin_layout Plain Layout

#>    cond_sum_r(x, y, z) 30.7 31.80  32.70 34.40 89.0   100
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The goal of deferred evaluation is to perform this transformation automatically,
 so you can write concise R code and have it automatically translated into
 efficient machine code.
\end_layout

\begin_layout Subsection
Profiling
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
"We should forget about small efficiencies, say about 97% of the time: premature
 optimization is the root of all evil" --- Donald Knuth.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Your code should be correct, maintainable and fast.
 Notice that speed comes last - if your function is incorrect or unmaintainable
 (i.e.
 will eventually become incorrect) it doesn't matter if it's fast.
\end_layout

\begin_layout Itemize
This often means vectorising code, or avoiding some of the most obvious
 traps discussed in the [R inferno]
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.burns-stat.com/documents/books/the-r-inferno/
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Itemize
Making fast code is a four part process:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Profiling
\series default
 helps you discover which parts of your code are taking up the most time.
\end_layout

\begin_layout Enumerate

\series bold
Microbenchmarking
\series default
 lets you experiment with small parts of your code to find faster approaches.
\end_layout

\begin_layout Enumerate

\series bold
Timing
\series default
 helps you check that the micro-optimisations have a macro effect, and helps
 experiment with larger changes (like totally rethinking your approach)
\end_layout

\begin_layout Enumerate

\series bold
A performance testing tool
\series default
 makes sure your code stays fast in the future (e.g.
 Vbench, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://wesmckinney.com/blog/?p=373
\end_layout

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Sometimes there's no way to improve performance within R, and you'll need
 to use C++, the topic of Rcpp.
\end_layout

\begin_layout Itemize
Having a good test suite is important when tuning the performance of your
 code: you don't want to make your code fast at the expense of making it
 incorrect.
\end_layout

\begin_deeper
\begin_layout Itemize
Good exploration from Winston: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://rpubs.com/wch/3797
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Find out what is slow.
 Then make it fast.
\end_layout

\begin_layout Itemize
Mature optimisation (PDF) 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://carlos.bueno.org/optimization/mature-optimization.pdf
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
A recurring theme throughout this part of the book is the importance of
 differentiating between absolute and relative speed, and fast vs fast enough.
 
\end_layout

\begin_deeper
\begin_layout Itemize
First, whenever you compare the speed of two approaches to a problem, be
 very wary of just looking at a relative differences.
\end_layout

\begin_layout Itemize
You also need to think about the costs of modifying your code.
 For example, if it takes you an hour to implement a change that makes you
 code 10x faster, saving 9 s each run, then you'll have to run at least
 400 times before you'll see a net benefit.
\end_layout

\begin_layout Itemize
Be careful that you don't spend hours to save seconds.
\end_layout

\end_deeper
\begin_layout Subsubsection
Performance profiling
\end_layout

\begin_layout Subsubsection
Timing
\end_layout

\begin_layout Subsubsection
Performance testing
\end_layout

\begin_layout Subsubsection
Caching
\end_layout

\begin_layout Subsubsection
Byte code compilation
\end_layout

\begin_layout Subsubsection
Other people's code
\end_layout

\begin_layout Subsubsection
Rewrite in a lower-level language
\end_layout

\begin_layout Subsubsection
Brainstorming
\end_layout

\begin_layout Subsection
Memory
\end_layout

\begin_layout Itemize
Understanding how memory works in R can not only help you analyse larger
 datasets with the same amount of memory, but is also important for writing
 fast code, as accidental copies are a major cause of slow code.
\end_layout

\begin_layout Itemize
Places to learn memory management in R
\end_layout

\begin_deeper
\begin_layout Itemize
reading of the documentation (particularly ?Memory and ?gc)
\end_layout

\begin_layout Itemize
the memory profiling section of R-exts (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://cran.r-project.org/doc/manuals/R-exts.html#Profiling-R-code-for-memory-use
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
the SEXPs section of R-ints.
 (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://cran.r-project.org/doc/manuals/R-ints.html#SEXPs
\end_layout

\end_inset

)
\end_layout

\end_deeper
\begin_layout Subsubsection
object.size()
\end_layout

\begin_layout Itemize
One of the most useful tools for understanding memory usage in R is 
\family sans
object.size()
\family default
, which tells you how much memory an object occupies.
 
\end_layout

\begin_layout Itemize
You might have expected that the size of an empty vector would be 0 and
 that the memory usage would grow proportionately with length.
 Neither of those things are true!
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<out.width="0.5
\backslash

\backslash
maxwidth">>=
\end_layout

\begin_layout Plain Layout

sizes <- sapply(0:50,function(n) object.size(seq_len(n)))
\end_layout

\begin_layout Plain Layout

plot(0:50,sizes,xlab="Length",ylab="Bytes",type="s")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This isn't just an artefact of integer vectors: every vector of length 0
 occupies 40 bytes of memory:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

object.size(numeric())
\end_layout

\begin_layout Plain Layout

object.size(logical())
\end_layout

\begin_layout Plain Layout

object.size(raw())
\end_layout

\begin_layout Plain Layout

object.size(list())
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
What are those 40 bytes of memory used for? Every object in R has four component
s:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
object metadata
\series default
, the 
\emph on
sxpinfo
\emph default
 (4 bytes).
 This metadata includes the base type, and information used for debugging
 and memory management.
\end_layout

\begin_layout Itemize

\series bold
Two pointers
\series default
: one to the next object in memory, and one to the previous object (2 *
 8 bytes).
 This doubly-linked list makes it easy for internal R code to loop iterate
 through every object in memory.
\end_layout

\begin_layout Itemize

\series bold
A pointer to the attributes
\series default
 (8 bytes).
\end_layout

\end_deeper
\begin_layout Itemize
All vector types (e.g.
 atomic vectors and lists), have three more components:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
The length of the vector
\series default
 (4 bytes).
 Using 4 bytes should mean that R can only support vectors up to 2 ^ (4
 * 8 - 1) (2 ^ 31, about two billion) elements long.
 But in R 3.0.0 and later you can have vectors up to 2 ^ 52 long: read R-internals
 to see how support for long vectors was added without changing the size
 of this field.
\end_layout

\begin_layout Itemize

\series bold
The "true" length of the vector
\series default
 (4 bytes).
 This is basically never used, except when the object is the hash table
 for an environment, where the truelength represents the allocated space
 and the length represents the space currenty used.
\end_layout

\begin_layout Itemize

\series bold
The data
\series default
 (?? bytes).
 An empty vector has 0 bytes of data, but it's obviously very important
 otherwise!
\end_layout

\end_deeper
\begin_layout Itemize
If you're counting closely you'll note that only this adds up to 36 bytes.
 The other 4 bytes are needed as padding after the sxpinfo, so that the
 pointers start on 8 byte (=64-bit) boundaries.
\end_layout

\begin_layout Itemize
Most process architectures require this alignment for pointers, and even
 if not required, accessing non-aligned pointers tends to be rather slow.
 (If you're interested, you can read more about C structure package
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.catb.org/esr/structure-packing/
\end_layout

\end_inset


\end_layout

\end_inset

.)
\end_layout

\begin_layout Itemize
That explains the intercept on the graph.
\end_layout

\begin_layout Itemize
But why does the memory size grow in irregular jumps? To understand that,
 you need to know a little bit about how R requests memory from the operating
 system.
 
\end_layout

\begin_layout Itemize
Requesting memory, using the 
\family sans
malloc()
\family default
 function, is a relatively expensive operation, and it would make R slow
 if it had to request memory every time you created a little vector.
\end_layout

\begin_layout Itemize
Instead, it asks for a big block of memory and then manages it itself: this
 is called the 
\series bold
\bar under
small vector pool
\series default
\bar default
.
\end_layout

\begin_layout Itemize
R uses this pool for vectors less than 128 bytes long, and for efficiency
 and simplicity, it only allocates vectors that are 8, 16, 32, 48, 64 or
 128 bytes long.
\end_layout

\begin_layout Itemize
If we adjust our previous plot by removing the 40 bytes of overhead we can
 see that those values correspond to the jumps.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<out.width="0.8
\backslash

\backslash
maxwidth">>=
\end_layout

\begin_layout Plain Layout

plot(0:50, sizes - 40, xlab = "Length", ylab = "Bytes excluding overhead",
 type = "n")
\end_layout

\begin_layout Plain Layout

abline(h = 0, col = "grey80")
\end_layout

\begin_layout Plain Layout

abline(h = c(8, 16, 32, 48, 64, 128), col = "grey80")
\end_layout

\begin_layout Plain Layout

abline(a = 0, b = 4, col = "grey90", lwd = 4)
\end_layout

\begin_layout Plain Layout

lines(sizes - 40, type = "s")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
It only remains to explain the steps after 128 bytes.
 While it makes sense for R to manage memory for small vectors, it doesn't
 make sense to manage it for large vectors: allocating big chunks of memory
 is something that operating systems are very good at.
 
\end_layout

\begin_layout Itemize
R always asks for memory in 
\bar under
multiples of 8 bytes
\bar default
: this ensures good alignment for the data, in the same way we needed good
 alignment for the pointers.
\end_layout

\begin_layout Itemize
There are a few other subtleties to 
\family sans
object.size()
\family default
: it only promises to give an estimate of the memory usage, not the actual
 usage.
\end_layout

\begin_layout Itemize
This is because for more complex objects it's not immediately obvious what
 memory usage means.
 
\end_layout

\begin_layout Itemize
Take environments for example.
 Using 
\family sans
object.size()
\family default
 on an environment tells you the size of the environment, not the size of
 its contents.
 
\end_layout

\begin_layout Itemize
It would be easy to create a function that did this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

env_size <- function(x) {
\end_layout

\begin_layout Plain Layout

if (!is.environment(x)) return(object.size(x))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

objs <- ls(x, all = TRUE)
\end_layout

\begin_layout Plain Layout

sizes <- vapply(objs, function(o) env_size(get(o, x)), double(1))
\end_layout

\begin_layout Plain Layout

structure(sum(sizes) + object.size(x), class = "object_size")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

object.size(environment())
\end_layout

\begin_layout Plain Layout

env_size(environment())
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This function isn't quite correct because it's very difficult to cover every
 special case.
 For example, you might have an object with an attribute that's an environment
 that contains a formula which has an environment containing a large object...
\end_layout

\begin_layout Itemize
But even if you could cover all these special cases there's another problem.
 Environment objects are reference based so you can point to the same object
 from multiple locations.
 
\end_layout

\begin_layout Itemize
For example, In the following example, what should the size of b be?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a <- new.env()
\end_layout

\begin_layout Plain Layout

a$x <- 1:1e6
\end_layout

\begin_layout Plain Layout

b <- new.env()
\end_layout

\begin_layout Plain Layout

b$a <- a
\end_layout

\begin_layout Plain Layout

env_size(a)
\end_layout

\begin_layout Plain Layout

env_size(b)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You could argue that the size of b is actually only 56 bytes, because if
 you remove b, that's how much memory will be freed.
 But if you deleted a first, and then deleted b it would free 4000152 bytes.
 So is the size of b 56 or 4000152 bytes? The answer depends on the context.
\end_layout

\end_deeper
\begin_layout Itemize
Another challenge for 
\family sans
object.size()
\family default
 is strings:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

object.size("banana")
\end_layout

\begin_layout Plain Layout

object.size(rep("banana",100))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
the size of a vector containing "banana" is 96 bytes, but the size of a
 vector containing 100 "banana"s is 888 bytes.
 Why the difference? The key is 888 = 96 + 99 * 8.
\end_layout

\begin_layout Itemize
R has a global string pool, which means that every unique string is only
 stored once in memory.
 Every other instance of that string is just a pointer, and only needs 8
 bytes of storage.
\end_layout

\begin_layout Itemize

\family sans
object.size()
\family default
 does tries to take this into account for individual vectors, but like with
 environments it's not obvious exactly how the accounting should work.
\end_layout

\end_deeper
\begin_layout Subsubsection
Total memory use
\end_layout

\begin_layout Itemize

\family sans
object.size()
\family default
 tells you the size of a single object; 
\family sans
gc()
\family default
 (among other things) tells you the total size of all objects in memory:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

gc()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
R breaks down memory usage into 
\series bold
Vcells
\series default
 (memory used by vectors) and 
\series bold
Ncells
\series default
 (memory used by everything else).
\end_layout

\begin_layout Itemize
But this distinction isn't usually important, and neither are the gc trigger
 and max used columns.
 What you're usually most interested in is the total memory used.
\end_layout

\begin_layout Itemize
The function below wraps around gc() to return just the amount of memory
 (in megabytes) that R is currently using.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

rm(list=ls())
\end_layout

\begin_layout Plain Layout

mem <- function() {
\end_layout

\begin_layout Plain Layout

bit <- 8L * .Machine$sizeof.pointer
\end_layout

\begin_layout Plain Layout

if (!(bit == 32L || bit == 64L)) {
\end_layout

\begin_layout Plain Layout

stop("Unknown architecture", call.
 = FALSE)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

node_size <- if (bit == 32L) 28L else 56L
\end_layout

\begin_layout Plain Layout

usage <- gc()
\end_layout

\begin_layout Plain Layout

sum(usage[, 1] * c(node_size, 8)) / (1024 ^ 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

mem()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Don't expect this number to agree with the amount of memory that your operating
 system says that R is using:
\end_layout

\begin_deeper
\begin_layout Itemize
Some overhead associated with the R interpreter is not captured by these
 numbers.
\end_layout

\begin_layout Itemize
Both R and the operating system are lazy: they won't try and reclaim memory
 until it's actually needed.
 So R might be holding on to memory because the OS hasn't asked for it back
 yet.
\end_layout

\begin_layout Itemize
R counts the memory occupied by objects; there may be gaps from objects
 that have been deleted.
 This problem is known as memory fragmentation.
\end_layout

\end_deeper
\begin_layout Itemize
We can build a function on top of mem() that tells us how memory changes
 during the execution of a block of code.
 Positive numbers represent an increase in the memory used by R, and negative
 numbers a decrease.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

mem_change <- function(code) {
\end_layout

\begin_layout Plain Layout

 start <- mem()
\end_layout

\begin_layout Plain Layout

 expr <- substitute(code)
\end_layout

\begin_layout Plain Layout

 eval(expr, parent.frame())
\end_layout

\begin_layout Plain Layout

 rm(code, expr)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 round(mem() - start, 3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# Need about 4 mb to store 1 million integers
\end_layout

\begin_layout Plain Layout

mem_change(x <- 1:1e6)
\end_layout

\begin_layout Plain Layout

# We get that memory back when we delete it
\end_layout

\begin_layout Plain Layout

mem_change(rm(x))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Garbage collection
\end_layout

\begin_layout Itemize
In some languages you have to explicitly delete unnused objects so that
 their memory can be returned.
 R uses an alternative approach, called 
\series bold
garbage collection
\series default
 (GC for short), which automatically released memory when an object is no
 longer used.
 
\end_layout

\begin_layout Itemize
It does this based on environments and the regular scoping rules: when an
 environment goes out of scope (for example, when a function finishes executing)
, all of the contents of that environment are deleted and their memory is
 freed.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

f<-function(){
\end_layout

\begin_layout Plain Layout

1:1e6
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

mem_change(f())
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This is a little bit of a simplification because in order to find out how
 much memory is available, our 
\family sans
mem()
\family default
 function calls 
\family sans
gc()
\family default
.
 
\end_layout

\begin_layout Itemize
As well as returning the amount of memory currently used, 
\family sans
gc()
\family default
 also triggers garbage collection.
 
\end_layout

\begin_layout Itemize
Garbage collection normally happens lazily: R calls 
\family sans
gc()
\family default
 when it needs more space.
 In reality, that R might hold onto the memory after the function has terminated
, but it will release it as soon as it's needed.
\end_layout

\begin_layout Itemize
Despite what you might have read elsewhere, there's never any point in calling
 
\family sans
gc()
\family default
 yourself, apart to see how much memory is in use.
 
\end_layout

\begin_layout Itemize
R will automatically run garbage collection whenever it needs more space;
 if you want to see when that is, call 
\family sans
gcinfo(TRUE)
\family default
.
 
\end_layout

\begin_layout Itemize
The only reason you might want to call 
\family sans
gc()
\family default
 is that it also requests that R should return memory to the operating system.
 
\end_layout

\begin_layout Itemize
Generally, GC takes care of releasing previously used memory.
 However, you do need to be aware of situations that can cause memory leaks:
 when you think you've removed all references to an object, but some are
 still hanging around so the object never gets freed.
 
\end_layout

\begin_layout Itemize
In R, the two main causes of memory leaks are 
\bar under
formulas and closures
\bar default
.
 They both capture the enclosing environment, so objects in that environment
 will not be reclaimed automatically.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

f1<-function(){
\end_layout

\begin_layout Plain Layout

x<-1:1e6
\end_layout

\begin_layout Plain Layout

10
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

mem_change(x<-f1())
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

rm(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f2<-function(){
\end_layout

\begin_layout Plain Layout

x<-1:1e6
\end_layout

\begin_layout Plain Layout

a~b
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

mem_change(y<-f2())
\end_layout

\begin_layout Plain Layout

object.size(y)
\end_layout

\begin_layout Plain Layout

rm(y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f3<-function(){
\end_layout

\begin_layout Plain Layout

x<-1:1e6
\end_layout

\begin_layout Plain Layout

function() 10
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

mem_change(z<-f3())
\end_layout

\begin_layout Plain Layout

object.size(z)
\end_layout

\begin_layout Plain Layout

rm(z)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Memory profiling with lineprof
\end_layout

\begin_layout Itemize
As well as using 
\family sans
mem_change()
\family default
 to explicitly capture the change in memory caused by running a block of
 code, we can use memory profiling to automatically capture memory usage
 every few milliseconds.
\end_layout

\begin_layout Itemize
This functionality is provided by the 
\family sans
utils::Rprof()
\family default
, but it doesn't provide a very useful display of the results.
 Instead, we'll use the lineprof
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/hadley/lineprof
\end_layout

\end_inset


\end_layout

\end_inset

 package; it's powered by 
\family sans
Rprof()
\family default
, but displays the results in a more informative manner.
\end_layout

\begin_layout Subsubsection
Modification in place
\end_layout

\begin_layout Itemize
What happens to x in the following code?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x<-1:10
\end_layout

\begin_layout Plain Layout

x[5]<-10
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's two possibilities:
\end_layout

\begin_layout Enumerate
R modifies the existing x in place.
\end_layout

\begin_layout Enumerate
R makes a copy of x in a new location, modifies that new vector, and then
 changes the name x to point to the new location.
\end_layout

\end_deeper
\begin_layout Itemize
It turns out that R can do either depending on the circumstances.
\end_layout

\begin_layout Itemize
In the example above, it will modify in place, but if another variable also
 points to x, then it will copy it to a new location: To explore what's
 going on in more detail we need some new tools found in the
\family sans
 pryr
\family default
 package.
\end_layout

\begin_layout Itemize
Given the name of a variable, 
\family sans
address()
\family default
 tells us its location in memory, and 
\family sans
refs()
\family default
 tells us how many names point to that same location.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that if you're using Rstudio this 
\family sans
refs()
\family default
 will always return two: the environment browser makes a reference to every
 object you create on the command line, but not inside a function.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(pryr)
\end_layout

\begin_layout Plain Layout

x<-1:10
\end_layout

\begin_layout Plain Layout

c(address(x),refs(x))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y<-x
\end_layout

\begin_layout Plain Layout

c(address(y),refs(y))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Note that refs is only an estimate and it can only distinguish between 1
 and more than 1 references.
 This means that 
\family sans
refs() 
\family default
returns 2 in both of the following cases:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x<-1:5
\end_layout

\begin_layout Plain Layout

y<-x
\end_layout

\begin_layout Plain Layout

rm(y)
\end_layout

\begin_layout Plain Layout

# Should really be one, because we've deleted y
\end_layout

\begin_layout Plain Layout

refs(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x<-1:5
\end_layout

\begin_layout Plain Layout

y<-x
\end_layout

\begin_layout Plain Layout

z<-x
\end_layout

\begin_layout Plain Layout

# Should really be three
\end_layout

\begin_layout Plain Layout

refs(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
When 
\family sans
refs(x)
\family default
 is one, modification will occur in place; when 
\family sans
refs(x)
\family default
 is two, it will make a copy (so that the other pointers to the object contined
 unchanged).
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x<-1:10
\end_layout

\begin_layout Plain Layout

y=x
\end_layout

\begin_layout Plain Layout

c(address(x),address(y))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x[5]<-6L
\end_layout

\begin_layout Plain Layout

c(address(x),address(y))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Another useful function is 
\family sans
tracemem()
\family default
, which will print a message every time the traced object is copied:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x<-1:10
\end_layout

\begin_layout Plain Layout

# Prints the current memory location of the object
\end_layout

\begin_layout Plain Layout

tracemem(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y<-x
\end_layout

\begin_layout Plain Layout

# Prints where it has moved from and to
\end_layout

\begin_layout Plain Layout

x[5]<-6L
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Non-primitive functions that touch the object always increment the ref count.
 Primitive functions are usually written in such a way that they don't increment
 the ref count.
\begin_inset Foot
status open

\begin_layout Plain Layout
The reasons are a little complicated, but see the R-devel thread confused
 about NAMED
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://r.789695.n4.nabble.com/Confused-about-NAMED-td4103326.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

rm(list=ls())
\end_layout

\begin_layout Plain Layout

x<-1:10
\end_layout

\begin_layout Plain Layout

refs(x)
\end_layout

\begin_layout Plain Layout

mean(x)
\end_layout

\begin_layout Plain Layout

refs(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Touching the object forces an increment
\end_layout

\begin_layout Plain Layout

f <- function(x) x
\end_layout

\begin_layout Plain Layout

x <- 1:10; f(x); refs(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Sum is primitive, so doesn't increment
\end_layout

\begin_layout Plain Layout

x <- 1:10; sum(x); refs(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# f() and g() never evaluate x so refs doesn't increment
\end_layout

\begin_layout Plain Layout

f <- function(x) 10
\end_layout

\begin_layout Plain Layout

x <- 1:10; f(x); refs(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- function(x) substitute(x)
\end_layout

\begin_layout Plain Layout

x <- 1:10; g(x); refs(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Generally, any primitive replacement function will modify in place, provided
 that the object is not referred to elsewhere.
 This includes 
\family sans
[[<-, [<-, @<-, $<-, attr<-, attributes<-, class<-, dim<-, dimnames<-, names<-
\family default
, and 
\family sans
levels<-
\family default
.
 
\end_layout

\begin_layout Itemize
To be precise, all non-primitive functions increment refs, but a primitive
 function may be written in such a way that it doesn't increment refs.
 
\end_layout

\begin_layout Itemize
The rules are sufficiently complicated that there's not a lot of point in
 trying to memorise them; instead approach the problem practically; use
 
\family sans
refs()
\family default
 and 
\family sans
tracemem()
\family default
 to figure out when objects are being copied.
\end_layout

\begin_layout Itemize
If you find yourself resorting to exotic tricks to avoid copies, it may
 be time to rewrite your function in C++, as described in 
\family sans
Rcpp
\family default
.
\end_layout

\begin_layout Itemize

\series bold
Loops
\end_layout

\begin_deeper
\begin_layout Itemize
For loops in R have a reputation for being slow, but often this slowness
 is because instead of modifying in place, you're modifying a copy.
 
\end_layout

\begin_layout Itemize
Take the following code that subtracts the median from each column of a
 large data.frame:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

rm(list=ls())
\end_layout

\begin_layout Plain Layout

x <- data.frame(matrix(runif(100 * 1e4), ncol = 100))
\end_layout

\begin_layout Plain Layout

medians <- vapply(x, median, numeric(1))
\end_layout

\begin_layout Plain Layout

system.time({
\end_layout

\begin_layout Plain Layout

 for(i in seq_along(medians)) {
\end_layout

\begin_layout Plain Layout

	x[, i] <- x[, i] - medians[i]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
It's rather slow - we only have 100 columns and 10,000 rows, but it's taking
 almost eight seconds.
 We can use 
\family sans
address()
\family default
 and 
\family sans
refs()
\family default
 to see what's going on for a small sample of the loop:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

for(i in 1:5) {
\end_layout

\begin_layout Plain Layout

	x[, i] <- x[, i] - medians[i]
\end_layout

\begin_layout Plain Layout

	print(c(address(x), refs(x)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In each iteration x is moved to a new location (copying the complete data
 frame) and refs(x) is always 2.
 This is because [<-.data.frame is not a primitive function, so it always
 increments the refs.
 
\end_layout

\begin_layout Itemize
We can make the function substantially more efficient by using either a
 list or matrix instead of a data frame.
 Modifying lists and matrices use primitive functions, so the refs are not
 incremented and all modifications are in place.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

y <- as.list(x)
\end_layout

\begin_layout Plain Layout

system.time({
\end_layout

\begin_layout Plain Layout

	for(i in seq_along(medians)) {
\end_layout

\begin_layout Plain Layout

	 y[[i]] <- y[[i]] - medians[i]
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

z <- as.matrix(x)
\end_layout

\begin_layout Plain Layout

system.time({
\end_layout

\begin_layout Plain Layout

	for(i in seq_along(medians)) {
\end_layout

\begin_layout Plain Layout

	z[, i] <- z[, i] - medians[i]
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Rcpp
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
a fantastic tool written by Dirk Eddelbuettel and Romain Francois (with
 key contributions by Doug Bates, John Chambers and JJ Allaire), that makes
 it dead simple to connect C++ to R.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Sometimes R code just isn't fast enough - you've used profiling to find
 the bottleneck, but there's simply no way to make the code any faster.
 
\end_layout

\begin_layout Itemize
Typical bottlenecks that C++ can help with are:
\end_layout

\begin_deeper
\begin_layout Itemize
Loops that can't easily be vectorised because each iteration depends on
 the previous.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
C++ modifies objects in place, so there is little overhead when modifying
 a data structure many times.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Recursive functions, or problems which involve calling functions millions
 of times.
\end_layout

\begin_layout Itemize
Problems that require advanced data structures and algorithms that R doesn't
 provide.
 Through the standard template library (STL), C++ has efficient implementations
 of many important data structures, from ordered maps to double ended queues.
\end_layout

\end_deeper
\begin_layout Itemize
While pure R code is relatively slow compared to C or C++, many bottlenecks
 in base R have already been replaced with hand-written C functions.
 This means that if your function already uses vectorised operations, you
 are unlikely to see a large improvement in performance.
\end_layout

\begin_layout Itemize
Note, however, that if you do rewrite a base C function with Rcpp, it's
 likely to be much shorter, because you can use the more sophisticated tools
 provided by C++.
\end_layout

\begin_layout Itemize
Many good tutorials and references are freely available, including
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.learncpp.com/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.cplusplus.com/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
For more advanced topics, the "
\emph on
Effective C++
\emph default
" series by Scott Meyers is popular choice.
 
\end_layout

\begin_layout Itemize
Dirk Eddelbuettel has written an entire book on Rcpp, "Seamless R and C++
 integration with Rcpp" 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.springer.com/statistics/computational+statistics/book/978-1-4614-6867-7
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Getting started
\end_layout

\begin_layout Itemize
All examples in this chapter need at least version 0.10.1 of the Rcpp package.
 This version includes 
\family sans
cppFunction
\family default
 and 
\family sans
sourceCpp
\family default
, which makes it very easy to connect C++ to R.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

library(Rcpp)
\end_layout

\begin_layout Plain Layout

cppFunction('
\end_layout

\begin_layout Plain Layout

int add(int x, int y, int z){
\end_layout

\begin_layout Plain Layout

int sum=x+y+z;
\end_layout

\begin_layout Plain Layout

return sum;
\end_layout

\begin_layout Plain Layout

}'
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

add # like a regular R function, printing displays info about the function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

add(1,2,3)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

When you run this code, Rcpp will compile the C++ code and construct an
 R function that connects to the compiled C++ function.
\end_layout

\end_deeper
\begin_layout Subsubsection
Getting started with C++
\end_layout

\begin_layout Itemize

\series bold
No inputs, scalar output
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

one<-function()1L
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We can compile and use this from R with cppFunction 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

cppFunction('
\end_layout

\begin_layout Plain Layout

int one(){
\end_layout

\begin_layout Plain Layout

return 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

')
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This small function illustrates a number of important differences between
 R and C++:
\end_layout

\begin_deeper
\begin_layout Itemize
The syntax to create a function looks like the syntax to call a function;
 you don't use assignment to create functions like in R.
\end_layout

\begin_layout Itemize
You must declare the type of output the function returns.
 The classes for the most common types of R vectors are: NumericVector,
 IntegerVector, CharacterVector and LogicalVector.
\end_layout

\begin_layout Itemize
Scalars and vectors are different.
 The scalar equivalents of numeric, integer, character and logical vectors
 are: 
\family sans
double, int, String
\family default
 and 
\family sans
bool
\family default
.
\end_layout

\begin_layout Itemize
You must use an explicit return statement to return a value from the function.
\end_layout

\begin_layout Itemize
Every statement is terminated by a ;.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Scalar input, scalar output
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

signR<-function(x){
\end_layout

\begin_layout Plain Layout

if (x>0) 1
\end_layout

\begin_layout Plain Layout

else if (x==0) 0
\end_layout

\begin_layout Plain Layout

else -1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cppFunction('
\end_layout

\begin_layout Plain Layout

int signC(int x){
\end_layout

\begin_layout Plain Layout

if (x>0){
\end_layout

\begin_layout Plain Layout

return 1;
\end_layout

\begin_layout Plain Layout

}else if (x==0){
\end_layout

\begin_layout Plain Layout

return 0;
\end_layout

\begin_layout Plain Layout

}else {
\end_layout

\begin_layout Plain Layout

return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}'
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In the C++ version:
\end_layout

\begin_layout Itemize
We declare the type of each input in the same way we declare the type of
 the output.
 While this makes the code a little more verbose, it also makes it very
 obvious what type of input the function needs.
\end_layout

\begin_layout Itemize
The if syntax is identical - while there are some big differences between
 R and C++, there are also lots of similarities! C++ also has a while statement
 that works the same way as R's.
 You can also use 
\family sans
break
\family default
, but use 
\family sans
continue
\family default
 instead of 
\family sans
next
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Vector input, scalar output
\end_layout

\begin_deeper
\begin_layout Itemize
One big difference between R and C++ is that the cost of loops is much lower.
 For example, we could implement the sum function in R using a loop.
 If you've been programming in R a while, you'll probably have a visceral
 reaction to this function!
\end_layout

\end_deeper
\begin_layout Subsubsection
Rcpp classes and methods
\end_layout

\begin_layout Subsubsection
Rcpp sugar
\end_layout

\begin_layout Subsubsection
Missing values
\end_layout

\begin_layout Subsubsection
The STL
\end_layout

\begin_layout Subsubsection
Case studies
\end_layout

\begin_layout Subsubsection
Using Rcpp in a Package
\end_layout

\begin_layout Subsubsection
Adding Rcpp to an existing package (Rcpp<=0.10.6)
\end_layout

\begin_layout Subsubsection
Adding Rcpp to an existing package (Rcpp>=0.10.7)
\end_layout

\begin_layout Subsubsection
More details
\end_layout

\begin_layout Subsubsection
Learning more
\end_layout

\begin_layout Subsubsection
Acknowledgements
\end_layout

\begin_layout Subsection
R's C interface
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Subsubsection
Differences between R and C
\end_layout

\begin_layout Subsubsection
Calling C functions from R
\end_layout

\begin_layout Subsubsection
Basic data structures
\end_layout

\begin_layout Subsubsection
Coercion and object creation
\end_layout

\begin_layout Subsubsection
Modifying objects
\end_layout

\begin_layout Subsubsection
Pairlists and symbols
\end_layout

\begin_layout Subsubsection
Missing and symbols
\end_layout

\begin_layout Subsubsection
Missing and non-finite values
\end_layout

\begin_layout Subsubsection
Checking types in C
\end_layout

\begin_layout Subsubsection
Finding the C source code for a function .External
\end_layout

\begin_layout Subsubsection
Using C code in a package
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Packages
\end_layout

\begin_layout Section
Getting started
\end_layout

\begin_layout Subsection
Philosophy
\end_layout

\begin_layout Subsubsection
Getting started
\end_layout

\begin_layout Subsubsection
Introduction to devtools
\end_layout

\begin_layout Subsection
Package basics
\end_layout

\begin_layout Subsection
Package development cycle
\end_layout

\begin_layout Subsection
Quick ref
\end_layout

\begin_layout Section
Documentation
\end_layout

\begin_layout Subsection
Documenting packages
\end_layout

\begin_layout Subsection
Documenting functions
\end_layout

\begin_layout Subsection
Namespaces
\end_layout

\begin_layout Section
Best practices
\end_layout

\begin_layout Subsection
Good code style
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Subsection
Git and github
\end_layout

\begin_layout Subsection
Release
\end_layout

\end_body
\end_document
